/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/standardized-audio-context";
exports.ids = ["vendor-chunks/standardized-audio-context"];
exports.modules = {

/***/ "(ssr)/./node_modules/standardized-audio-context/build/es5/bundle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/standardized-audio-context/build/es5/bundle.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! automation-events */ \"(ssr)/./node_modules/automation-events/build/node/module.js\"), __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/slicedToArray.js\"), __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(ssr)/./node_modules/@babel/runtime/helpers/createClass.js\"), __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(ssr)/./node_modules/@babel/runtime/helpers/classCallCheck.js\"), __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"(ssr)/./node_modules/@babel/runtime/helpers/typeof.js\"), __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\"), __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"(ssr)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"), __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"(ssr)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"), __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(ssr)/./node_modules/@babel/runtime/helpers/inherits.js\"), __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"), __webpack_require__(/*! @babel/runtime/regenerator */ \"(ssr)/./node_modules/@babel/runtime/regenerator/index.js\"), __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/toConsumableArray.js\"), __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectWithoutProperties.js\")) :\n    0;\n})(this, (function (exports, automationEvents, _slicedToArray, _createClass, _classCallCheck, _typeof, _defineProperty, _possibleConstructorReturn, _getPrototypeOf, _inherits, _asyncToGenerator, _regeneratorRuntime, _toConsumableArray, _objectWithoutProperties) { 'use strict';\n\n    var createAbortError = function createAbortError() {\n      return new DOMException('', 'AbortError');\n    };\n\n    var createAddActiveInputConnectionToAudioNode = function createAddActiveInputConnectionToAudioNode(insertElementInSet) {\n      return function (activeInputs, source, _ref, ignoreDuplicates) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          output = _ref2[0],\n          input = _ref2[1],\n          eventListener = _ref2[2];\n        insertElementInSet(activeInputs[input], [source, output, eventListener], function (activeInputConnection) {\n          return activeInputConnection[0] === source && activeInputConnection[1] === output;\n        }, ignoreDuplicates);\n      };\n    };\n\n    var createAddAudioNodeConnections = function createAddAudioNodeConnections(audioNodeConnectionsStore) {\n      return function (audioNode, audioNodeRenderer, nativeAudioNode) {\n        var activeInputs = [];\n        for (var i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n          activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n          activeInputs: activeInputs,\n          outputs: new Set(),\n          passiveInputs: new WeakMap(),\n          renderer: audioNodeRenderer\n        });\n      };\n    };\n\n    var createAddAudioParamConnections = function createAddAudioParamConnections(audioParamConnectionsStore) {\n      return function (audioParam, audioParamRenderer) {\n        audioParamConnectionsStore.set(audioParam, {\n          activeInputs: new Set(),\n          passiveInputs: new WeakMap(),\n          renderer: audioParamRenderer\n        });\n      };\n    };\n\n    var ACTIVE_AUDIO_NODE_STORE = new WeakSet();\n    var AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\n    var AUDIO_NODE_STORE = new WeakMap();\n    var AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\n    var AUDIO_PARAM_STORE = new WeakMap();\n    var CONTEXT_STORE = new WeakMap();\n    var EVENT_LISTENERS = new WeakMap();\n    var CYCLE_COUNTERS = new WeakMap();\n    // This clunky name is borrowed from the spec. :-)\n    var NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\n    var NODE_TO_PROCESSOR_MAPS = new WeakMap();\n\n    var handler = {\n      construct: function construct() {\n        return handler;\n      }\n    };\n    var isConstructible = function isConstructible(constructible) {\n      try {\n        var proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    /*\n     * This massive regex tries to cover all the following cases.\n     *\n     * import './path';\n     * import defaultImport from './path';\n     * import { namedImport } from './path';\n     * import { namedImport as renamendImport } from './path';\n     * import * as namespaceImport from './path';\n     * import defaultImport, { namedImport } from './path';\n     * import defaultImport, { namedImport as renamendImport } from './path';\n     * import defaultImport, * as namespaceImport from './path';\n     */\n    var IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n    var splitImportStatements = function splitImportStatements(source, url) {\n      var importStatements = [];\n      var sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n      var result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n      while (result !== null) {\n        var unresolvedUrl = result[1].slice(1, -1);\n        var importStatementWithResolvedUrl = result[0].replace(/([\\s]+)?;?$/, '').replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n      }\n      return [importStatements.join(';'), sourceWithoutImportStatements];\n    };\n\n    var verifyParameterDescriptors = function verifyParameterDescriptors(parameterDescriptors) {\n      if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n      }\n    };\n    var verifyProcessorCtor = function verifyProcessorCtor(processorCtor) {\n      if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n      }\n      if (processorCtor.prototype === null || _typeof(processorCtor.prototype) !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n      }\n    };\n    var createAddAudioWorkletModule = function createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) {\n      var index = 0;\n      return function (context, moduleURL) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n          credentials: 'omit'\n        };\n        var resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n          return Promise.resolve();\n        }\n        var ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n          var promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n          if (promiseOfOngoingRequest !== undefined) {\n            return promiseOfOngoingRequest;\n          }\n        }\n        var nativeContext = getNativeContext(context);\n        // Bug #59: Safari does not implement the audioWorklet property.\n        var promise = nativeContext.audioWorklet === undefined ? fetchSource(moduleURL).then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            source = _ref2[0],\n            absoluteUrl = _ref2[1];\n          var _splitImportStatement = splitImportStatements(source, absoluteUrl),\n            _splitImportStatement2 = _slicedToArray(_splitImportStatement, 2),\n            importStatements = _splitImportStatement2[0],\n            sourceWithoutImportStatements = _splitImportStatement2[1];\n          /*\n           * This is the unminified version of the code used below:\n           *\n           * ```js\n           * ${ importStatements };\n           * ((a, b) => {\n           *     (a[b] = a[b] || [ ]).push(\n           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n           *             ${ sourceWithoutImportStatements }\n           *         }\n           *     );\n           * })(window, '_AWGS');\n           * ```\n           */\n          // tslint:disable-next-line:max-line-length\n          var wrappedSource = \"\".concat(importStatements, \";((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{\").concat(sourceWithoutImportStatements, \"\\n})})(window,'_AWGS')\");\n          // @todo Evaluating the given source code is a possible security problem.\n          return evaluateSource(wrappedSource);\n        }).then(function () {\n          var evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n          if (evaluateAudioWorkletGlobalScope === undefined) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            throw new SyntaxError();\n          }\n          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, function () {\n            return evaluateAudioWorkletGlobalScope(/*#__PURE__*/_createClass(function AudioWorkletProcessor() {\n              _classCallCheck(this, AudioWorkletProcessor);\n            }), undefined, function (name, processorCtor) {\n              if (name.trim() === '') {\n                throw createNotSupportedError();\n              }\n              var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n              if (nodeNameToProcessorConstructorMap !== undefined) {\n                if (nodeNameToProcessorConstructorMap.has(name)) {\n                  throw createNotSupportedError();\n                }\n                verifyProcessorCtor(processorCtor);\n                verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                nodeNameToProcessorConstructorMap.set(name, processorCtor);\n              } else {\n                verifyProcessorCtor(processorCtor);\n                verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n              }\n            }, nativeContext.sampleRate, undefined, undefined);\n          });\n        }) : Promise.all([fetchSource(moduleURL), Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))]).then(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            _ref4$ = _slicedToArray(_ref4[0], 2),\n            source = _ref4$[0],\n            absoluteUrl = _ref4$[1],\n            isSupportingPostMessage = _ref4[1];\n          var currentIndex = index + 1;\n          index = currentIndex;\n          var _splitImportStatement3 = splitImportStatements(source, absoluteUrl),\n            _splitImportStatement4 = _slicedToArray(_splitImportStatement3, 2),\n            importStatements = _splitImportStatement4[0],\n            sourceWithoutImportStatements = _splitImportStatement4[1];\n          /*\n           * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n           *\n           * This is the unminified version of the code used below.\n           *\n           * ```js\n           * class extends AudioWorkletProcessor {\n           *\n           *     __buffers = new WeakSet();\n           *\n           *     constructor () {\n           *         super();\n           *\n           *         this.port.postMessage = ((postMessage) => {\n           *             return (message, transferables) => {\n           *                 const filteredTransferables = (transferables)\n           *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n           *                     : transferables;\n           *\n           *                 return postMessage.call(this.port, message, filteredTransferables);\n           *              };\n           *         })(this.port.postMessage);\n           *     }\n           * }\n           * ```\n           */\n          var patchedAudioWorkletProcessor = isSupportingPostMessage ? 'AudioWorkletProcessor' : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n          /*\n           * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n           *\n           * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n           *\n           * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n           *\n           * This is the unminified version of the code used below:\n           *\n           * ```js\n           * `${ importStatements };\n           * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n           * })(\n           *     ${Â patchedAudioWorkletProcessor },\n           *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n           *\n           *         __collectBuffers = (array) => {\n           *             array.forEach((element) => this.__buffers.add(element.buffer));\n           *         };\n           *\n           *         process (inputs, outputs, parameters) {\n           *             inputs.forEach(this.__collectBuffers);\n           *             outputs.forEach(this.__collectBuffers);\n           *             this.__collectBuffers(Object.values(parameters));\n           *\n           *             return super.process(\n           *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n           *                 outputs,\n           *                 parameters\n           *             );\n           *         }\n           *\n           *     })\n           * );\n           *\n           * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n           *\n           *     process () {\n           *         return false;\n           *     }\n           *\n           * })`\n           * ```\n           */\n          var memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n          var bufferRegistration = isSupportingPostMessage ? '' : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n          var wrappedSource = \"\".concat(importStatements, \";((AudioWorkletProcessor,registerProcessor)=>{\").concat(sourceWithoutImportStatements, \"\\n})(\").concat(patchedAudioWorkletProcessor, \",(n,p)=>registerProcessor(n,class extends p{\").concat(memberDefinition, \"process(i,o,p){\").concat(bufferRegistration, \"return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac\").concat(currentIndex, \"',class extends AudioWorkletProcessor{process(){return !1}})\");\n          var blob = new Blob([wrappedSource], {\n            type: 'application/javascript; charset=utf-8'\n          });\n          var url = URL.createObjectURL(blob);\n          return nativeContext.audioWorklet.addModule(url, options).then(function () {\n            if (isNativeOfflineAudioContext(nativeContext)) {\n              return nativeContext;\n            }\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            var backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n            return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(function () {\n              return backupOfflineAudioContext;\n            });\n          }).then(function (nativeContextOrBackupOfflineAudioContext) {\n            if (nativeAudioWorkletNodeConstructor === null) {\n              throw new SyntaxError();\n            }\n            try {\n              // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n              new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, \"__sac\".concat(currentIndex)); // tslint:disable-line:no-unused-expression\n            } catch (_unused) {\n              throw new SyntaxError();\n            }\n          })[\"finally\"](function () {\n            return URL.revokeObjectURL(url);\n          });\n        });\n        if (ongoingRequestsOfContext === undefined) {\n          ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n          ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise.then(function () {\n          var updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n          if (updatedResolvedRequestsOfContext === undefined) {\n            resolvedRequests.set(context, new Set([moduleURL]));\n          } else {\n            updatedResolvedRequestsOfContext.add(moduleURL);\n          }\n        })[\"finally\"](function () {\n          var updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n          if (updatedOngoingRequestsOfContext !== undefined) {\n            updatedOngoingRequestsOfContext[\"delete\"](moduleURL);\n          }\n        });\n        return promise;\n      };\n    };\n\n    var getValueForKey = function getValueForKey(map, key) {\n      var value = map.get(key);\n      if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n      }\n      return value;\n    };\n\n    var pickElementFromSet = function pickElementFromSet(set, predicate) {\n      var matchingElements = Array.from(set).filter(predicate);\n      if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n      }\n      if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n      }\n      var _matchingElements = _slicedToArray(matchingElements, 1),\n        matchingElement = _matchingElements[0];\n      set[\"delete\"](matchingElement);\n      return matchingElement;\n    };\n\n    var deletePassiveInputConnectionToAudioNode = function deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input) {\n      var passiveInputConnections = getValueForKey(passiveInputs, source);\n      var matchingConnection = pickElementFromSet(passiveInputConnections, function (passiveInputConnection) {\n        return passiveInputConnection[0] === output && passiveInputConnection[1] === input;\n      });\n      if (passiveInputConnections.size === 0) {\n        passiveInputs[\"delete\"](source);\n      }\n      return matchingConnection;\n    };\n\n    var getEventListenersOfAudioNode = function getEventListenersOfAudioNode(audioNode) {\n      return getValueForKey(EVENT_LISTENERS, audioNode);\n    };\n\n    var setInternalStateToActive = function setInternalStateToActive(audioNode) {\n      if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n      }\n      ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n      getEventListenersOfAudioNode(audioNode).forEach(function (eventListener) {\n        return eventListener(true);\n      });\n    };\n\n    var isAudioWorkletNode = function isAudioWorkletNode(audioNode) {\n      return 'port' in audioNode;\n    };\n\n    var setInternalStateToPassive = function setInternalStateToPassive(audioNode) {\n      if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n      }\n      ACTIVE_AUDIO_NODE_STORE[\"delete\"](audioNode);\n      getEventListenersOfAudioNode(audioNode).forEach(function (eventListener) {\n        return eventListener(false);\n      });\n    };\n\n    // Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\n    var setInternalStateToPassiveWhenNecessary = function setInternalStateToPassiveWhenNecessary(audioNode, activeInputs) {\n      if (!isAudioWorkletNode(audioNode) && activeInputs.every(function (connections) {\n        return connections.size === 0;\n      })) {\n        setInternalStateToPassive(audioNode);\n      }\n    };\n\n    var createAddConnectionToAudioNode = function createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) {\n      var tailTimeTimeoutIds = new WeakMap();\n      return function (source, destination, output, input, isOffline) {\n        var _getAudioNodeConnecti = getAudioNodeConnections(destination),\n          activeInputs = _getAudioNodeConnecti.activeInputs,\n          passiveInputs = _getAudioNodeConnecti.passiveInputs;\n        var _getAudioNodeConnecti2 = getAudioNodeConnections(source),\n          outputs = _getAudioNodeConnecti2.outputs;\n        var eventListeners = getEventListenersOfAudioNode(source);\n        var eventListener = function eventListener(isActive) {\n          var nativeDestinationAudioNode = getNativeAudioNode(destination);\n          var nativeSourceAudioNode = getNativeAudioNode(source);\n          if (isActive) {\n            var partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n            addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n              connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isPassiveAudioNode(destination)) {\n              setInternalStateToActive(destination);\n            }\n          } else {\n            var _partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, _partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n              disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            var tailTime = getAudioNodeTailTime(destination);\n            if (tailTime === 0) {\n              if (isActiveAudioNode(destination)) {\n                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n              }\n            } else {\n              var tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n              if (tailTimeTimeoutId !== undefined) {\n                clearTimeout(tailTimeTimeoutId);\n              }\n              tailTimeTimeoutIds.set(destination, setTimeout(function () {\n                if (isActiveAudioNode(destination)) {\n                  setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                }\n              }, tailTime * 1000));\n            }\n          }\n        };\n        if (insertElementInSet(outputs, [destination, output, input], function (outputConnection) {\n          return outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input;\n        }, true)) {\n          eventListeners.add(eventListener);\n          if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n          } else {\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n          }\n          return true;\n        }\n        return false;\n      };\n    };\n\n    var createAddPassiveInputConnectionToAudioNode = function createAddPassiveInputConnectionToAudioNode(insertElementInSet) {\n      return function (passiveInputs, input, _ref, ignoreDuplicates) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          source = _ref2[0],\n          output = _ref2[1],\n          eventListener = _ref2[2];\n        var passiveInputConnections = passiveInputs.get(source);\n        if (passiveInputConnections === undefined) {\n          passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        } else {\n          insertElementInSet(passiveInputConnections, [output, input, eventListener], function (passiveInputConnection) {\n            return passiveInputConnection[0] === output && passiveInputConnection[1] === input;\n          }, ignoreDuplicates);\n        }\n      };\n    };\n\n    var createAddSilentConnection = function createAddSilentConnection(createNativeGainNode) {\n      return function (nativeContext, nativeAudioScheduledSourceNode) {\n        var nativeGainNode = createNativeGainNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: 0\n        });\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n        var _disconnect = function disconnect() {\n          nativeAudioScheduledSourceNode.removeEventListener('ended', _disconnect);\n          nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n          nativeGainNode.disconnect();\n        };\n        nativeAudioScheduledSourceNode.addEventListener('ended', _disconnect);\n      };\n    };\n\n    var createAddUnrenderedAudioWorkletNode = function createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes) {\n      return function (nativeContext, audioWorkletNode) {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n      };\n    };\n\n    function ownKeys$w(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$w(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$w(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$w(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$r(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$r() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$r() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$r = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$k = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      fftSize: 2048,\n      maxDecibels: -30,\n      minDecibels: -100,\n      smoothingTimeConstant: 0.8\n    };\n    var createAnalyserNodeConstructor = function createAnalyserNodeConstructor(audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audionNodeConstructo) {\n        function AnalyserNode(context, options) {\n          var _this;\n          _classCallCheck(this, AnalyserNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$w(_objectSpread$w({}, DEFAULT_OPTIONS$k), options);\n          var nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n          var analyserNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null;\n          _this = _callSuper$r(this, AnalyserNode, [context, false, nativeAnalyserNode, analyserNodeRenderer]);\n          _this._nativeAnalyserNode = nativeAnalyserNode;\n          return _this;\n        }\n        _inherits(AnalyserNode, _audionNodeConstructo);\n        return _createClass(AnalyserNode, [{\n          key: \"fftSize\",\n          get: function get() {\n            return this._nativeAnalyserNode.fftSize;\n          },\n          set: function set(value) {\n            this._nativeAnalyserNode.fftSize = value;\n          }\n        }, {\n          key: \"frequencyBinCount\",\n          get: function get() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n          }\n        }, {\n          key: \"maxDecibels\",\n          get: function get() {\n            return this._nativeAnalyserNode.maxDecibels;\n          },\n          set: function set(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            var maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n              this._nativeAnalyserNode.maxDecibels = maxDecibels;\n              throw createIndexSizeError();\n            }\n          }\n        }, {\n          key: \"minDecibels\",\n          get: function get() {\n            return this._nativeAnalyserNode.minDecibels;\n          },\n          set: function set(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            var minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n              this._nativeAnalyserNode.minDecibels = minDecibels;\n              throw createIndexSizeError();\n            }\n          }\n        }, {\n          key: \"smoothingTimeConstant\",\n          get: function get() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n          },\n          set: function set(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n          }\n        }, {\n          key: \"getByteFrequencyData\",\n          value: function getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n          }\n        }, {\n          key: \"getByteTimeDomainData\",\n          value: function getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n          }\n        }, {\n          key: \"getFloatFrequencyData\",\n          value: function getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n          }\n        }, {\n          key: \"getFloatTimeDomainData\",\n          value: function getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n          }\n        }]);\n      }(audionNodeConstructor);\n    };\n\n    var isOwnedByContext = function isOwnedByContext(nativeAudioNode, nativeContext) {\n      return nativeAudioNode.context === nativeContext;\n    };\n\n    var createAnalyserNodeRendererFactory = function createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAnalyserNodes = new WeakMap();\n        var createAnalyserNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAnalyserNode, nativeAnalyserNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAnalyserNode = getNativeAudioNode(proxy); // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n                  if (!nativeAnalyserNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeAnalyserNode.channelCount,\n                      channelCountMode: nativeAnalyserNode.channelCountMode,\n                      channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                      fftSize: nativeAnalyserNode.fftSize,\n                      maxDecibels: nativeAnalyserNode.maxDecibels,\n                      minDecibels: nativeAnalyserNode.minDecibels,\n                      smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                    };\n                    nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n                  _context.next = 6;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n                case 6:\n                  return _context.abrupt(\"return\", nativeAnalyserNode);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAnalyserNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAnalyserNode !== undefined) {\n              return Promise.resolve(renderedNativeAnalyserNode);\n            }\n            return createAnalyserNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var testAudioBufferCopyChannelMethodsOutOfBoundsSupport = function testAudioBufferCopyChannelMethodsOutOfBoundsSupport(nativeAudioBuffer) {\n      try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    var createIndexSizeError = function createIndexSizeError() {\n      return new DOMException('', 'IndexSizeError');\n    };\n\n    var wrapAudioBufferGetChannelDataMethod = function wrapAudioBufferGetChannelDataMethod(audioBuffer) {\n      audioBuffer.getChannelData = function (getChannelData) {\n        return function (channel) {\n          try {\n            return getChannelData.call(audioBuffer, channel);\n          } catch (err) {\n            if (err.code === 12) {\n              throw createIndexSizeError();\n            }\n            throw err;\n          }\n        };\n      }(audioBuffer.getChannelData);\n    };\n\n    function ownKeys$v(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$v(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$v(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$v(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var DEFAULT_OPTIONS$j = {\n      numberOfChannels: 1\n    };\n    var createAudioBufferConstructor = function createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n      var nativeOfflineAudioContext = null;\n      return /*#__PURE__*/function () {\n        function AudioBuffer(options) {\n          _classCallCheck(this, AudioBuffer);\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n          var _DEFAULT_OPTIONS$opti = _objectSpread$v(_objectSpread$v({}, DEFAULT_OPTIONS$j), options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n          if (nativeOfflineAudioContext === null) {\n            nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n          }\n          /*\n           * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n           * factory function. But since Firefox also supports the constructor everything should be fine.\n           */\n          var audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n            length: length,\n            numberOfChannels: numberOfChannels,\n            sampleRate: sampleRate\n          }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n          // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n          if (audioBuffer.numberOfChannels === 0) {\n            throw createNotSupportedError();\n          }\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n          } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n            return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n          })) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n          }\n          audioBufferStore.add(audioBuffer);\n          /*\n           * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n           * (Offline)AudioContexts.\n           */\n          return audioBuffer;\n        }\n        return _createClass(AudioBuffer, null, [{\n          key: Symbol.hasInstance,\n          value: function value(instance) {\n            return instance !== null && _typeof(instance) === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n          }\n        }]);\n      }();\n    };\n\n    var MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\n    var MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n\n    var isActiveAudioNode = function isActiveAudioNode(audioNode) {\n      return ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n    };\n\n    function ownKeys$u(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$u(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$u(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$u(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$q(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$q() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$q() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$q = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$i = {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      // Bug #149: Safari does not yet support the detune AudioParam.\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      playbackRate: 1\n    };\n    var createAudioBufferSourceNodeConstructor = function createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function AudioBufferSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, AudioBufferSourceNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$u(_objectSpread$u({}, DEFAULT_OPTIONS$i), options);\n          var nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;\n          _this = _callSuper$q(this, AudioBufferSourceNode, [context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer]);\n          _this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n          _this._isBufferNullified = false;\n          _this._isBufferSet = mergedOptions.buffer !== null;\n          _this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n          _this._onended = null;\n          // Bug #73: Safari does not export the correct values for maxValue and minValue.\n          _this._playbackRate = createAudioParam(_this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          return _this;\n        }\n        _inherits(AudioBufferSourceNode, _audioNodeConstructor);\n        return _createClass(AudioBufferSourceNode, [{\n          key: \"buffer\",\n          get: function get() {\n            if (this._isBufferNullified) {\n              return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n              if (this._isBufferSet) {\n                throw createInvalidStateError();\n              }\n              this._isBufferSet = true;\n            }\n          }\n        }, {\n          key: \"loop\",\n          get: function get() {\n            return this._nativeAudioBufferSourceNode.loop;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n          }\n        }, {\n          key: \"loopEnd\",\n          get: function get() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n          }\n        }, {\n          key: \"loopStart\",\n          get: function get() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n          }\n        }, {\n          key: \"onended\",\n          get: function get() {\n            return this._onended;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            var nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n          }\n        }, {\n          key: \"playbackRate\",\n          get: function get() {\n            return this._playbackRate;\n          }\n        }, {\n          key: \"start\",\n          value: function start() {\n            var _this2 = this;\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var duration = arguments.length > 2 ? arguments[2] : undefined;\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n              this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n            if (this.context.state !== 'closed') {\n              setInternalStateToActive(this);\n              var _resetInternalStateToPassive = function resetInternalStateToPassive() {\n                _this2._nativeAudioBufferSourceNode.removeEventListener('ended', _resetInternalStateToPassive);\n                if (isActiveAudioNode(_this2)) {\n                  setInternalStateToPassive(_this2);\n                }\n              };\n              this._nativeAudioBufferSourceNode.addEventListener('ended', _resetInternalStateToPassive);\n            }\n          }\n        }, {\n          key: \"stop\",\n          value: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n              this._audioBufferSourceNodeRenderer.stop = when;\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createAudioBufferSourceNodeRendererFactory = function createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAudioBufferSourceNodes = new WeakMap();\n        var start = null;\n        var stop = null;\n        var createAudioBufferSourceNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAudioBufferSourceNode, nativeAudioBufferSourceNodeIsOwnedByContext, options, _nativeAudioBufferSou;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n                  if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                    options = {\n                      buffer: nativeAudioBufferSourceNode.buffer,\n                      channelCount: nativeAudioBufferSourceNode.channelCount,\n                      channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                      channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                      // Bug #149: Safari does not yet support the detune AudioParam.\n                      loop: nativeAudioBufferSourceNode.loop,\n                      loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                      loopStart: nativeAudioBufferSourceNode.loopStart,\n                      playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                    };\n                    nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                    if (start !== null) {\n                      (_nativeAudioBufferSou = nativeAudioBufferSourceNode).start.apply(_nativeAudioBufferSou, _toConsumableArray(start));\n                    }\n                    if (stop !== null) {\n                      nativeAudioBufferSourceNode.stop(stop);\n                    }\n                  }\n                  renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n                  if (nativeAudioBufferSourceNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeAudioBufferSourceNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAudioBufferSourceNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          set start(value) {\n            start = value;\n          },\n          set stop(value) {\n            stop = value;\n          },\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioBufferSourceNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioBufferSourceNode);\n            }\n            return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var isAudioBufferSourceNode = function isAudioBufferSourceNode(audioNode) {\n      return 'playbackRate' in audioNode;\n    };\n\n    var isBiquadFilterNode = function isBiquadFilterNode(audioNode) {\n      return 'frequency' in audioNode && 'gain' in audioNode;\n    };\n\n    var isConstantSourceNode = function isConstantSourceNode(audioNode) {\n      return 'offset' in audioNode;\n    };\n\n    var isGainNode = function isGainNode(audioNode) {\n      return !('frequency' in audioNode) && 'gain' in audioNode;\n    };\n\n    var isOscillatorNode = function isOscillatorNode(audioNode) {\n      return 'detune' in audioNode && 'frequency' in audioNode && !('gain' in audioNode);\n    };\n\n    var isStereoPannerNode = function isStereoPannerNode(audioNode) {\n      return 'pan' in audioNode;\n    };\n\n    var getAudioNodeConnections = function getAudioNodeConnections(audioNode) {\n      return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n    };\n\n    var getAudioParamConnections = function getAudioParamConnections(audioParam) {\n      return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n    };\n\n    function _createForOfIteratorHelper$b(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$b(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$b(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$b(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$b(r, a) : void 0; } }\n    function _arrayLikeToArray$b(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var _deactivateActiveAudioNodeInputConnections = function deactivateActiveAudioNodeInputConnections(audioNode, trace) {\n      var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n        activeInputs = _getAudioNodeConnecti.activeInputs;\n      activeInputs.forEach(function (connections) {\n        return connections.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 1),\n            source = _ref2[0];\n          if (!trace.includes(audioNode)) {\n            _deactivateActiveAudioNodeInputConnections(source, [].concat(_toConsumableArray(trace), [audioNode]));\n          }\n        });\n      });\n      var audioParams = isAudioBufferSourceNode(audioNode) ? [\n      // Bug #149: Safari does not yet support the detune AudioParam.\n      audioNode.playbackRate] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];\n      var _iterator = _createForOfIteratorHelper$b(audioParams),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var audioParam = _step.value;\n          var audioParamConnections = getAudioParamConnections(audioParam);\n          if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 1),\n                source = _ref4[0];\n              return _deactivateActiveAudioNodeInputConnections(source, trace);\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n      }\n    };\n\n    var deactivateAudioGraph = function deactivateAudioGraph(context) {\n      _deactivateActiveAudioNodeInputConnections(context.destination, []);\n    };\n\n    var isValidLatencyHint = function isValidLatencyHint(latencyHint) {\n      return latencyHint === undefined || typeof latencyHint === 'number' || typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback');\n    };\n\n    function _callSuper$p(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$p() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$p() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$p = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createAudioContextConstructor = function createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) {\n      return /*#__PURE__*/function (_baseAudioContextCons) {\n        function AudioContext() {\n          var _this;\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          _classCallCheck(this, AudioContext);\n          if (nativeAudioContextConstructor === null) {\n            throw new Error('Missing the native AudioContext constructor.');\n          }\n          var nativeAudioContext;\n          try {\n            nativeAudioContext = new nativeAudioContextConstructor(options);\n          } catch (err) {\n            // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n            if (err.code === 12 && err.message === 'sampleRate is not in range') {\n              throw createNotSupportedError();\n            }\n            throw err;\n          }\n          // Bug #131 Safari returns null when there are four other AudioContexts running already.\n          if (nativeAudioContext === null) {\n            throw createUnknownError();\n          }\n          // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n          if (!isValidLatencyHint(options.latencyHint)) {\n            throw new TypeError(\"The provided value '\".concat(options.latencyHint, \"' is not a valid enum value of type AudioContextLatencyCategory.\"));\n          }\n          // Bug #150 Safari does not support setting the sampleRate.\n          if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n            throw createNotSupportedError();\n          }\n          _this = _callSuper$p(this, AudioContext, [nativeAudioContext, 2]);\n          var latencyHint = options.latencyHint;\n          var _nativeAudioContext = nativeAudioContext,\n            sampleRate = _nativeAudioContext.sampleRate;\n          // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n          _this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n          /*\n           * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n           * ScriptProcessorNode.\n           */\n          Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n          _this._nativeAudioContext = nativeAudioContext;\n          // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n          if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            _this._nativeGainNode = nativeAudioContext.createGain();\n            _this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n            _this._nativeGainNode.gain.value = 1e-37;\n            _this._nativeOscillatorNode.connect(_this._nativeGainNode).connect(nativeAudioContext.destination);\n            _this._nativeOscillatorNode.start();\n          } else {\n            _this._nativeGainNode = null;\n            _this._nativeOscillatorNode = null;\n          }\n          _this._state = null;\n          /*\n           * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n           * to 'running'.\n           */\n          if (nativeAudioContext.state === 'running') {\n            _this._state = 'suspended';\n            var _revokeState = function revokeState() {\n              if (_this._state === 'suspended') {\n                _this._state = null;\n              }\n              nativeAudioContext.removeEventListener('statechange', _revokeState);\n            };\n            nativeAudioContext.addEventListener('statechange', _revokeState);\n          }\n          return _this;\n        }\n        _inherits(AudioContext, _baseAudioContextCons);\n        return _createClass(AudioContext, [{\n          key: \"baseLatency\",\n          get: function get() {\n            return this._baseLatency;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n          }\n        }, {\n          key: \"close\",\n          value: function close() {\n            var _this2 = this;\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n              return this._nativeAudioContext.close().then(function () {\n                throw createInvalidStateError();\n              });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n              this._state = null;\n            }\n            return this._nativeAudioContext.close().then(function () {\n              if (_this2._nativeGainNode !== null && _this2._nativeOscillatorNode !== null) {\n                _this2._nativeOscillatorNode.stop();\n                _this2._nativeGainNode.disconnect();\n                _this2._nativeOscillatorNode.disconnect();\n              }\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"createMediaElementSource\",\n          value: function createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, {\n              mediaElement: mediaElement\n            });\n          }\n        }, {\n          key: \"createMediaStreamDestination\",\n          value: function createMediaStreamDestination() {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n          }\n        }, {\n          key: \"createMediaStreamSource\",\n          value: function createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, {\n              mediaStream: mediaStream\n            });\n          }\n        }, {\n          key: \"createMediaStreamTrackSource\",\n          value: function createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, {\n              mediaStreamTrack: mediaStreamTrack\n            });\n          }\n        }, {\n          key: \"resume\",\n          value: function resume() {\n            var _this3 = this;\n            if (this._state === 'suspended') {\n              return new Promise(function (resolve, reject) {\n                var _resolvePromise = function resolvePromise() {\n                  _this3._nativeAudioContext.removeEventListener('statechange', _resolvePromise);\n                  if (_this3._nativeAudioContext.state === 'running') {\n                    resolve();\n                  } else {\n                    _this3.resume().then(resolve, reject);\n                  }\n                };\n                _this3._nativeAudioContext.addEventListener('statechange', _resolvePromise);\n              });\n            }\n            return this._nativeAudioContext.resume()[\"catch\"](function (err) {\n              // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined || err.code === 15) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }, {\n          key: \"suspend\",\n          value: function suspend() {\n            return this._nativeAudioContext.suspend()[\"catch\"](function (err) {\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }]);\n      }(baseAudioContextConstructor);\n    };\n\n    function _callSuper$o(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$o() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$o() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$o = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createAudioDestinationNodeConstructor = function createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function AudioDestinationNode(context, channelCount) {\n          var _this;\n          _classCallCheck(this, AudioDestinationNode);\n          var nativeContext = getNativeContext(context);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n          var audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null;\n          _this = _callSuper$o(this, AudioDestinationNode, [context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer]);\n          _this._isNodeOfNativeOfflineAudioContext = isOffline;\n          _this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n          return _this;\n        }\n        _inherits(AudioDestinationNode, _audioNodeConstructor);\n        return _createClass(AudioDestinationNode, [{\n          key: \"channelCount\",\n          get: function get() {\n            return this._nativeAudioDestinationNode.channelCount;\n          },\n          set: function set(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n              throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n              throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n          }\n        }, {\n          key: \"channelCountMode\",\n          get: function get() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n          },\n          set: function set(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n              throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n          }\n        }, {\n          key: \"maxChannelCount\",\n          get: function get() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createAudioDestinationNodeRenderer = function createAudioDestinationNodeRenderer(renderInputsOfAudioNode) {\n      var renderedNativeAudioDestinationNodes = new WeakMap();\n      var createAudioDestinationNode = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n          var nativeAudioDestinationNode;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n                renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n                _context.next = 4;\n                return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n              case 4:\n                return _context.abrupt(\"return\", nativeAudioDestinationNode);\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n        return function createAudioDestinationNode(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      return {\n        render: function render(proxy, nativeOfflineAudioContext) {\n          var renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n          if (renderedNativeAudioDestinationNode !== undefined) {\n            return Promise.resolve(renderedNativeAudioDestinationNode);\n          }\n          return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n      };\n    };\n\n    var createAudioListenerFactory = function createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors) {\n      return function (context, nativeContext) {\n        var nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        var createFakeAudioParams = function createFakeAudioParams() {\n          var buffer = new Float32Array(1);\n          var channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: 9\n          });\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var isScriptProcessorNodeCreated = false;\n          var lastOrientation = [0, 0, -1, 0, 1, 0];\n          var lastPosition = [0, 0, 0];\n          var createScriptProcessorNode = function createScriptProcessorNode() {\n            if (isScriptProcessorNodeCreated) {\n              return;\n            }\n            isScriptProcessorNodeCreated = true;\n            var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            // tslint:disable-next-line:deprecation\n            scriptProcessorNode.onaudioprocess = function (_ref) {\n              var inputBuffer = _ref.inputBuffer;\n              var orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2), getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];\n              if (orientation.some(function (value, index) {\n                return value !== lastOrientation[index];\n              })) {\n                nativeListener.setOrientation.apply(nativeListener, orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n              }\n              var positon = [getFirstSample(inputBuffer, buffer, 6), getFirstSample(inputBuffer, buffer, 7), getFirstSample(inputBuffer, buffer, 8)];\n              if (positon.some(function (value, index) {\n                return value !== lastPosition[index];\n              })) {\n                nativeListener.setPosition.apply(nativeListener, positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n              }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n          };\n          var createSetOrientation = function createSetOrientation(index) {\n            return function (value) {\n              if (value !== lastOrientation[index]) {\n                lastOrientation[index] = value;\n                nativeListener.setOrientation.apply(nativeListener, _toConsumableArray(lastOrientation)); // tslint:disable-line:deprecation\n              }\n            };\n          };\n          var createSetPosition = function createSetPosition(index) {\n            return function (value) {\n              if (value !== lastPosition[index]) {\n                lastPosition[index] = value;\n                nativeListener.setPosition.apply(nativeListener, _toConsumableArray(lastPosition)); // tslint:disable-line:deprecation\n              }\n            };\n          };\n          var createFakeAudioParam = function createFakeAudioParam(input, initialValue, setValue) {\n            var constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'discrete',\n              offset: initialValue\n            });\n            constantSourceNode.connect(channelMergerNode, 0, input);\n            // @todo This should be stopped when the context is closed.\n            constantSourceNode.start();\n            Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n              get: function get() {\n                return initialValue;\n              }\n            });\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n             * minValue for GainNodes.\n             */\n            var audioParam = createAudioParam({\n              context: context\n            }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            overwriteAccessors(audioParam, 'value', function (get) {\n              return function () {\n                return get.call(audioParam);\n              };\n            }, function (set) {\n              return function (value) {\n                try {\n                  set.call(audioParam, value);\n                } catch (err) {\n                  if (err.code !== 9) {\n                    throw err;\n                  }\n                }\n                createScriptProcessorNode();\n                if (isOffline) {\n                  // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                  setValue(value);\n                }\n              };\n            });\n            audioParam.cancelAndHoldAtTime = function (cancelAndHoldAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                var value = cancelAndHoldAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.cancelAndHoldAtTime);\n            audioParam.cancelScheduledValues = function (cancelScheduledValues) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n                var value = cancelScheduledValues.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.cancelScheduledValues);\n            audioParam.exponentialRampToValueAtTime = function (exponentialRampToValueAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                  args[_key3] = arguments[_key3];\n                }\n                var value = exponentialRampToValueAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.exponentialRampToValueAtTime);\n            audioParam.linearRampToValueAtTime = function (linearRampToValueAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                  args[_key4] = arguments[_key4];\n                }\n                var value = linearRampToValueAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.linearRampToValueAtTime);\n            audioParam.setTargetAtTime = function (setTargetAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n                  args[_key5] = arguments[_key5];\n                }\n                var value = setTargetAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.setTargetAtTime);\n            audioParam.setValueAtTime = function (setValueAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n                  args[_key6] = arguments[_key6];\n                }\n                var value = setValueAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.setValueAtTime);\n            audioParam.setValueCurveAtTime = function (setValueCurveAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n                  args[_key7] = arguments[_key7];\n                }\n                var value = setValueCurveAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.setValueCurveAtTime);\n            return audioParam;\n          };\n          return {\n            forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n            forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n            forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n            positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n            positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n            positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n            upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n            upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n            upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n          };\n        };\n        var _ref2 = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener,\n          forwardX = _ref2.forwardX,\n          forwardY = _ref2.forwardY,\n          forwardZ = _ref2.forwardZ,\n          positionX = _ref2.positionX,\n          positionY = _ref2.positionY,\n          positionZ = _ref2.positionZ,\n          upX = _ref2.upX,\n          upY = _ref2.upY,\n          upZ = _ref2.upZ;\n        return {\n          get forwardX() {\n            return forwardX;\n          },\n          get forwardY() {\n            return forwardY;\n          },\n          get forwardZ() {\n            return forwardZ;\n          },\n          get positionX() {\n            return positionX;\n          },\n          get positionY() {\n            return positionY;\n          },\n          get positionZ() {\n            return positionZ;\n          },\n          get upX() {\n            return upX;\n          },\n          get upY() {\n            return upY;\n          },\n          get upZ() {\n            return upZ;\n          }\n        };\n      };\n    };\n\n    var isAudioNode = function isAudioNode(audioNodeOrAudioParam) {\n      return 'context' in audioNodeOrAudioParam;\n    };\n\n    var isAudioNodeOutputConnection = function isAudioNodeOutputConnection(outputConnection) {\n      return isAudioNode(outputConnection[0]);\n    };\n\n    function _createForOfIteratorHelper$a(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$a(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$a(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$a(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$a(r, a) : void 0; } }\n    function _arrayLikeToArray$a(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var insertElementInSet = function insertElementInSet(set, element, predicate, ignoreDuplicates) {\n      var _iterator = _createForOfIteratorHelper$a(set),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var lmnt = _step.value;\n          if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n              return false;\n            }\n            throw Error('The set contains at least one similar element.');\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      set.add(element);\n      return true;\n    };\n\n    var addActiveInputConnectionToAudioParam = function addActiveInputConnectionToAudioParam(activeInputs, source, _ref, ignoreDuplicates) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        output = _ref2[0],\n        eventListener = _ref2[1];\n      insertElementInSet(activeInputs, [source, output, eventListener], function (activeInputConnection) {\n        return activeInputConnection[0] === source && activeInputConnection[1] === output;\n      }, ignoreDuplicates);\n    };\n\n    var addPassiveInputConnectionToAudioParam = function addPassiveInputConnectionToAudioParam(passiveInputs, _ref, ignoreDuplicates) {\n      var _ref2 = _slicedToArray(_ref, 3),\n        source = _ref2[0],\n        output = _ref2[1],\n        eventListener = _ref2[2];\n      var passiveInputConnections = passiveInputs.get(source);\n      if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n      } else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], function (passiveInputConnection) {\n          return passiveInputConnection[0] === output;\n        }, ignoreDuplicates);\n      }\n    };\n\n    var isNativeAudioNodeFaker = function isNativeAudioNodeFaker(nativeAudioNodeOrNativeAudioNodeFaker) {\n      return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n    };\n\n    var connectNativeAudioNodeToNativeAudioNode = function connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input) {\n      if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        var fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n      }\n      nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n      return [nativeDestinationAudioNode, output, input];\n    };\n\n    function _createForOfIteratorHelper$9(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$9(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$9(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$9(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$9(r, a) : void 0; } }\n    function _arrayLikeToArray$9(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var deleteActiveInputConnection = function deleteActiveInputConnection(activeInputConnections, source, output) {\n      var _iterator = _createForOfIteratorHelper$9(activeInputConnections),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var activeInputConnection = _step.value;\n          if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections[\"delete\"](activeInputConnection);\n            return activeInputConnection;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return null;\n    };\n\n    var deleteActiveInputConnectionToAudioParam = function deleteActiveInputConnectionToAudioParam(activeInputs, source, output) {\n      return pickElementFromSet(activeInputs, function (activeInputConnection) {\n        return activeInputConnection[0] === source && activeInputConnection[1] === output;\n      });\n    };\n\n    var deleteEventListenerOfAudioNode = function deleteEventListenerOfAudioNode(audioNode, eventListener) {\n      var eventListeners = getEventListenersOfAudioNode(audioNode);\n      if (!eventListeners[\"delete\"](eventListener)) {\n        throw new Error('Missing the expected event listener.');\n      }\n    };\n\n    var deletePassiveInputConnectionToAudioParam = function deletePassiveInputConnectionToAudioParam(passiveInputs, source, output) {\n      var passiveInputConnections = getValueForKey(passiveInputs, source);\n      var matchingConnection = pickElementFromSet(passiveInputConnections, function (passiveInputConnection) {\n        return passiveInputConnection[0] === output;\n      });\n      if (passiveInputConnections.size === 0) {\n        passiveInputs[\"delete\"](source);\n      }\n      return matchingConnection;\n    };\n\n    var disconnectNativeAudioNodeFromNativeAudioNode = function disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input) {\n      if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n      } else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n      }\n    };\n\n    var getNativeAudioNode = function getNativeAudioNode(audioNode) {\n      return getValueForKey(AUDIO_NODE_STORE, audioNode);\n    };\n\n    var getNativeAudioParam = function getNativeAudioParam(audioParam) {\n      return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n    };\n\n    var isPartOfACycle = function isPartOfACycle(audioNode) {\n      return CYCLE_COUNTERS.has(audioNode);\n    };\n\n    var isPassiveAudioNode = function isPassiveAudioNode(audioNode) {\n      return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n    };\n\n    var testAudioNodeDisconnectMethodSupport = function testAudioNodeDisconnectMethodSupport(nativeAudioContext, nativeAudioWorkletNodeConstructor) {\n      return new Promise(function (resolve) {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n          resolve(true);\n        } else {\n          var analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n          var dummy = nativeAudioContext.createGain();\n          // Bug #95: Safari does not play one sample buffers.\n          var ones = nativeAudioContext.createBuffer(1, 2, 44100);\n          var channelData = ones.getChannelData(0);\n          channelData[0] = 1;\n          channelData[1] = 1;\n          var source = nativeAudioContext.createBufferSource();\n          source.buffer = ones;\n          source.loop = true;\n          source.connect(analyzer).connect(nativeAudioContext.destination);\n          source.connect(dummy);\n          source.disconnect(dummy);\n          // tslint:disable-next-line:deprecation\n          analyzer.onaudioprocess = function (event) {\n            var chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n            if (Array.prototype.some.call(chnnlDt, function (sample) {\n              return sample === 1;\n            })) {\n              resolve(true);\n            } else {\n              resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n          };\n          source.start();\n        }\n      });\n    };\n\n    function _createForOfIteratorHelper$8(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$8(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$8(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$8(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$8(r, a) : void 0; } }\n    function _arrayLikeToArray$8(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var visitEachAudioNodeOnce = function visitEachAudioNodeOnce(cycles, visitor) {\n      var counts = new Map();\n      var _iterator = _createForOfIteratorHelper$8(cycles),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var cycle = _step.value;\n          var _iterator2 = _createForOfIteratorHelper$8(cycle),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var audioNode = _step2.value;\n              var count = counts.get(audioNode);\n              counts.set(audioNode, count === undefined ? 1 : count + 1);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      counts.forEach(function (count, audioNode) {\n        return visitor(audioNode, count);\n      });\n    };\n\n    var isNativeAudioNode$1 = function isNativeAudioNode(nativeAudioNodeOrAudioParam) {\n      return 'context' in nativeAudioNodeOrAudioParam;\n    };\n\n    function _createForOfIteratorHelper$7(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$7(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$7(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$7(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$7(r, a) : void 0; } }\n    function _arrayLikeToArray$7(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var wrapAudioNodeDisconnectMethod = function wrapAudioNodeDisconnectMethod(nativeAudioNode) {\n      var connections = new Map();\n      nativeAudioNode.connect = function (connect) {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return function (destination) {\n          var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var returnValue = isNativeAudioNode$1(destination) ? connect(destination, output, input) : connect(destination, output);\n          // Save the new connection only if the calls to connect above didn't throw an error.\n          var connectionsToDestination = connections.get(destination);\n          if (connectionsToDestination === undefined) {\n            connections.set(destination, [{\n              input: input,\n              output: output\n            }]);\n          } else {\n            if (connectionsToDestination.every(function (connection) {\n              return connection.input !== input || connection.output !== output;\n            })) {\n              connectionsToDestination.push({\n                input: input,\n                output: output\n              });\n            }\n          }\n          return returnValue;\n        };\n      }(nativeAudioNode.connect.bind(nativeAudioNode));\n      nativeAudioNode.disconnect = function (disconnect) {\n        return function (destinationOrOutput, output, input) {\n          disconnect.apply(nativeAudioNode);\n          if (destinationOrOutput === undefined) {\n            connections.clear();\n          } else if (typeof destinationOrOutput === 'number') {\n            var _iterator = _createForOfIteratorHelper$7(connections),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _step$value = _slicedToArray(_step.value, 2),\n                  destination = _step$value[0],\n                  connectionsToDestination = _step$value[1];\n                var filteredConnections = connectionsToDestination.filter(function (connection) {\n                  return connection.output !== destinationOrOutput;\n                });\n                if (filteredConnections.length === 0) {\n                  connections[\"delete\"](destination);\n                } else {\n                  connections.set(destination, filteredConnections);\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } else if (connections.has(destinationOrOutput)) {\n            if (output === undefined) {\n              connections[\"delete\"](destinationOrOutput);\n            } else {\n              var _connectionsToDestination = connections.get(destinationOrOutput);\n              if (_connectionsToDestination !== undefined) {\n                var _filteredConnections = _connectionsToDestination.filter(function (connection) {\n                  return connection.output !== output && (connection.input !== input || input === undefined);\n                });\n                if (_filteredConnections.length === 0) {\n                  connections[\"delete\"](destinationOrOutput);\n                } else {\n                  connections.set(destinationOrOutput, _filteredConnections);\n                }\n              }\n            }\n          }\n          var _iterator2 = _createForOfIteratorHelper$7(connections),\n            _step2;\n          try {\n            var _loop = function _loop() {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                destination = _step2$value[0],\n                connectionsToDestination = _step2$value[1];\n              connectionsToDestination.forEach(function (connection) {\n                if (isNativeAudioNode$1(destination)) {\n                  nativeAudioNode.connect(destination, connection.output, connection.input);\n                } else {\n                  nativeAudioNode.connect(destination, connection.output);\n                }\n              });\n            };\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        };\n      }(nativeAudioNode.disconnect);\n    };\n\n    function _callSuper$n(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$n() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$n() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$n = function _isNativeReflectConstruct() { return !!t; })(); }\n    function _createForOfIteratorHelper$6(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$6(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$6(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$6(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$6(r, a) : void 0; } }\n    function _arrayLikeToArray$6(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var addConnectionToAudioParamOfAudioContext = function addConnectionToAudioParamOfAudioContext(source, destination, output, isOffline) {\n      var _getAudioParamConnect = getAudioParamConnections(destination),\n        activeInputs = _getAudioParamConnect.activeInputs,\n        passiveInputs = _getAudioParamConnect.passiveInputs;\n      var _getAudioNodeConnecti = getAudioNodeConnections(source),\n        outputs = _getAudioNodeConnecti.outputs;\n      var eventListeners = getEventListenersOfAudioNode(source);\n      var eventListener = function eventListener(isActive) {\n        var nativeAudioNode = getNativeAudioNode(source);\n        var nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n          var partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n          addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n          if (!isOffline && !isPartOfACycle(source)) {\n            nativeAudioNode.connect(nativeAudioParam, output);\n          }\n        } else {\n          var _partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n          addPassiveInputConnectionToAudioParam(passiveInputs, _partialConnection, false);\n          if (!isOffline && !isPartOfACycle(source)) {\n            nativeAudioNode.disconnect(nativeAudioParam, output);\n          }\n        }\n      };\n      if (insertElementInSet(outputs, [destination, output], function (outputConnection) {\n        return outputConnection[0] === destination && outputConnection[1] === output;\n      }, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n          addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n          addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n      }\n      return false;\n    };\n    var deleteInputConnectionOfAudioNode = function deleteInputConnectionOfAudioNode(source, destination, output, input) {\n      var _getAudioNodeConnecti2 = getAudioNodeConnections(destination),\n        activeInputs = _getAudioNodeConnecti2.activeInputs,\n        passiveInputs = _getAudioNodeConnecti2.passiveInputs;\n      var activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n      if (activeInputConnection === null) {\n        var passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n      }\n      return [activeInputConnection[2], true];\n    };\n    var deleteInputConnectionOfAudioParam = function deleteInputConnectionOfAudioParam(source, destination, output) {\n      var _getAudioParamConnect2 = getAudioParamConnections(destination),\n        activeInputs = _getAudioParamConnect2.activeInputs,\n        passiveInputs = _getAudioParamConnect2.passiveInputs;\n      var activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n      if (activeInputConnection === null) {\n        var passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n      }\n      return [activeInputConnection[2], true];\n    };\n    var deleteInputsOfAudioNode = function deleteInputsOfAudioNode(source, isOffline, destination, output, input) {\n      var _deleteInputConnectio = deleteInputConnectionOfAudioNode(source, destination, output, input),\n        _deleteInputConnectio2 = _slicedToArray(_deleteInputConnectio, 2),\n        listener = _deleteInputConnectio2[0],\n        isActive = _deleteInputConnectio2[1];\n      if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n          disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n      }\n      if (isActiveAudioNode(destination)) {\n        var _getAudioNodeConnecti3 = getAudioNodeConnections(destination),\n          activeInputs = _getAudioNodeConnecti3.activeInputs;\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n      }\n    };\n    var deleteInputsOfAudioParam = function deleteInputsOfAudioParam(source, isOffline, destination, output) {\n      var _deleteInputConnectio3 = deleteInputConnectionOfAudioParam(source, destination, output),\n        _deleteInputConnectio4 = _slicedToArray(_deleteInputConnectio3, 2),\n        listener = _deleteInputConnectio4[0],\n        isActive = _deleteInputConnectio4[1];\n      if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n          getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n      }\n    };\n    var deleteAnyConnection = function deleteAnyConnection(source, isOffline) {\n      var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n      var destinations = [];\n      var _iterator = _createForOfIteratorHelper$6(audioNodeConnectionsOfSource.outputs),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var outputConnection = _step.value;\n          if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n          } else {\n            deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n          }\n          destinations.push(outputConnection[0]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      audioNodeConnectionsOfSource.outputs.clear();\n      return destinations;\n    };\n    var deleteConnectionAtOutput = function deleteConnectionAtOutput(source, isOffline, output) {\n      var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n      var destinations = [];\n      var _iterator2 = _createForOfIteratorHelper$6(audioNodeConnectionsOfSource.outputs),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var outputConnection = _step2.value;\n          if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n              deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n            } else {\n              deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs[\"delete\"](outputConnection);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return destinations;\n    };\n    var deleteConnectionToDestination = function deleteConnectionToDestination(source, isOffline, destination, output, input) {\n      var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n      return Array.from(audioNodeConnectionsOfSource.outputs).filter(function (outputConnection) {\n        return outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input);\n      }).map(function (outputConnection) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n          deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        } else {\n          deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        }\n        audioNodeConnectionsOfSource.outputs[\"delete\"](outputConnection);\n        return outputConnection[0];\n      });\n    };\n    var createAudioNodeConstructor = function createAudioNodeConstructor(addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) {\n      return /*#__PURE__*/function (_eventTargetConstruct) {\n        function AudioNode(context, isActive, nativeAudioNode, audioNodeRenderer) {\n          var _this;\n          _classCallCheck(this, AudioNode);\n          _this = _callSuper$n(this, AudioNode, [nativeAudioNode]);\n          _this._context = context;\n          _this._nativeAudioNode = nativeAudioNode;\n          var nativeContext = getNativeContext(context);\n          // Bug #12: Safari does not support to disconnect a specific destination.\n          if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, function () {\n            return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n          })) {\n            wrapAudioNodeDisconnectMethod(nativeAudioNode);\n          }\n          AUDIO_NODE_STORE.set(_this, nativeAudioNode);\n          EVENT_LISTENERS.set(_this, new Set());\n          if (context.state !== 'closed' && isActive) {\n            setInternalStateToActive(_this);\n          }\n          addAudioNodeConnections(_this, audioNodeRenderer, nativeAudioNode);\n          return _this;\n        }\n        _inherits(AudioNode, _eventTargetConstruct);\n        return _createClass(AudioNode, [{\n          key: \"channelCount\",\n          get: function get() {\n            return this._nativeAudioNode.channelCount;\n          },\n          set: function set(value) {\n            this._nativeAudioNode.channelCount = value;\n          }\n        }, {\n          key: \"channelCountMode\",\n          get: function get() {\n            return this._nativeAudioNode.channelCountMode;\n          },\n          set: function set(value) {\n            this._nativeAudioNode.channelCountMode = value;\n          }\n        }, {\n          key: \"channelInterpretation\",\n          get: function get() {\n            return this._nativeAudioNode.channelInterpretation;\n          },\n          set: function set(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n          }\n        }, {\n          key: \"context\",\n          get: function get() {\n            return this._context;\n          }\n        }, {\n          key: \"numberOfInputs\",\n          get: function get() {\n            return this._nativeAudioNode.numberOfInputs;\n          }\n        }, {\n          key: \"numberOfOutputs\",\n          get: function get() {\n            return this._nativeAudioNode.numberOfOutputs;\n          }\n          // tslint:disable-next-line:invalid-void\n        }, {\n          key: \"connect\",\n          value: function connect(destination) {\n            var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n              throw createIndexSizeError();\n            }\n            var nativeContext = getNativeContext(this._context);\n            var isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n              throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n              var nativeDestinationAudioNode = getNativeAudioNode(destination);\n              try {\n                var connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                var isPassive = isPassiveAudioNode(this);\n                if (isOffline || isPassive) {\n                  var _this$_nativeAudioNod;\n                  (_this$_nativeAudioNod = this._nativeAudioNode).disconnect.apply(_this$_nativeAudioNod, _toConsumableArray(connection));\n                }\n                if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                  setInternalStateToActive(destination);\n                }\n              } catch (err) {\n                // Bug #41: Safari does not throw the correct exception so far.\n                if (err.code === 12) {\n                  throw createInvalidAccessError();\n                }\n                throw err;\n              }\n              var isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n              // Bug #164: Only Firefox detects cycles so far.\n              if (isNewConnectionToAudioNode) {\n                var cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n              }\n              return destination;\n            }\n            var nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n              throw createNotSupportedError();\n            }\n            try {\n              this._nativeAudioNode.connect(nativeAudioParam, output);\n              if (isOffline || isPassiveAudioNode(this)) {\n                this._nativeAudioNode.disconnect(nativeAudioParam, output);\n              }\n            } catch (err) {\n              // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n              if (err.code === 12) {\n                throw createInvalidAccessError();\n              }\n              throw err;\n            }\n            var isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n              var _cycles = detectCycles([this], destination);\n              visitEachAudioNodeOnce(_cycles, createIncrementCycleCounter(isOffline));\n            }\n          }\n        }, {\n          key: \"disconnect\",\n          value: function disconnect(destinationOrOutput, output, input) {\n            var destinations;\n            var nativeContext = getNativeContext(this._context);\n            var isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (destinationOrOutput === undefined) {\n              destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n              if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                throw createIndexSizeError();\n              }\n              destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n              if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                throw createIndexSizeError();\n              }\n              if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                throw createIndexSizeError();\n              }\n              destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n              if (destinations.length === 0) {\n                throw createInvalidAccessError();\n              }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            var _iterator3 = _createForOfIteratorHelper$6(destinations),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var destination = _step3.value;\n                var cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }]);\n      }(eventTargetConstructor);\n    };\n\n    var createAudioParamFactory = function createAudioParamFactory(addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) {\n      return function (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam) {\n        var maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var minValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        var defaultValue = nativeAudioParam.value;\n        var automationEventList = new automationEvents.AutomationEventList(defaultValue);\n        var audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        var audioParam = {\n          get defaultValue() {\n            return defaultValue;\n          },\n          get maxValue() {\n            return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n          },\n          get minValue() {\n            return minValue === null ? nativeAudioParam.minValue : minValue;\n          },\n          get value() {\n            return nativeAudioParam.value;\n          },\n          set value(value) {\n            nativeAudioParam.value = value;\n            // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n            audioParam.setValueAtTime(value, audioNode.context.currentTime);\n          },\n          cancelAndHoldAtTime: function cancelAndHoldAtTime(cancelTime) {\n            // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n            if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n              nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n            } else {\n              var previousLastEvent = Array.from(automationEventList).pop();\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n              var currentLastEvent = Array.from(automationEventList).pop();\n              nativeAudioParam.cancelScheduledValues(cancelTime);\n              if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                if (currentLastEvent.type === 'exponentialRampToValue') {\n                  nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                } else if (currentLastEvent.type === 'linearRampToValue') {\n                  nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                } else if (currentLastEvent.type === 'setValue') {\n                  nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                } else if (currentLastEvent.type === 'setValueCurve') {\n                  nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                }\n              }\n            }\n            return audioParam;\n          },\n          cancelScheduledValues: function cancelScheduledValues(cancelTime) {\n            if (audioParamRenderer === null) {\n              automationEventList.flush(audioNode.context.currentTime);\n            }\n            automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n            nativeAudioParam.cancelScheduledValues(cancelTime);\n            return audioParam;\n          },\n          exponentialRampToValueAtTime: function exponentialRampToValueAtTime(value, endTime) {\n            // Bug #45: Safari does not throw an error yet.\n            if (value === 0) {\n              throw new RangeError();\n            }\n            // Bug #187: Safari does not throw an error yet.\n            if (!Number.isFinite(endTime) || endTime < 0) {\n              throw new RangeError();\n            }\n            var currentTime = audioNode.context.currentTime;\n            if (audioParamRenderer === null) {\n              automationEventList.flush(currentTime);\n            }\n            // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n            if (Array.from(automationEventList).length === 0) {\n              automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n              nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n            }\n            automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n            nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n            return audioParam;\n          },\n          linearRampToValueAtTime: function linearRampToValueAtTime(value, endTime) {\n            var currentTime = audioNode.context.currentTime;\n            if (audioParamRenderer === null) {\n              automationEventList.flush(currentTime);\n            }\n            // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n            if (Array.from(automationEventList).length === 0) {\n              automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n              nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n            }\n            automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n            nativeAudioParam.linearRampToValueAtTime(value, endTime);\n            return audioParam;\n          },\n          setTargetAtTime: function setTargetAtTime(target, startTime, timeConstant) {\n            if (audioParamRenderer === null) {\n              automationEventList.flush(audioNode.context.currentTime);\n            }\n            automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n            nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n            return audioParam;\n          },\n          setValueAtTime: function setValueAtTime(value, startTime) {\n            if (audioParamRenderer === null) {\n              automationEventList.flush(audioNode.context.currentTime);\n            }\n            automationEventList.add(createSetValueAutomationEvent(value, startTime));\n            nativeAudioParam.setValueAtTime(value, startTime);\n            return audioParam;\n          },\n          setValueCurveAtTime: function setValueCurveAtTime(values, startTime, duration) {\n            // Bug 183: Safari only accepts a Float32Array.\n            var convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n            /*\n             * Bug #152: Safari does not correctly interpolate the values of the curve.\n             * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n             * existence of the webkitAudioContext is used as a workaround here.\n             */\n            if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n              var endTime = startTime + duration;\n              var sampleRate = audioNode.context.sampleRate;\n              var firstSample = Math.ceil(startTime * sampleRate);\n              var lastSample = Math.floor(endTime * sampleRate);\n              var numberOfInterpolatedValues = lastSample - firstSample;\n              var interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n              for (var i = 0; i < numberOfInterpolatedValues; i += 1) {\n                var theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n                var lowerIndex = Math.floor(theoreticIndex);\n                var upperIndex = Math.ceil(theoreticIndex);\n                interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n              }\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n              nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n              var timeOfLastSample = lastSample / sampleRate;\n              if (timeOfLastSample < endTime) {\n                setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n              }\n              setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n            } else {\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n              nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n            }\n            return audioParam;\n          }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n      };\n    };\n\n    function _createForOfIteratorHelper$5(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$5(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$5(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$5(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0; } }\n    function _arrayLikeToArray$5(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createAudioParamRenderer = function createAudioParamRenderer(automationEventList) {\n      return {\n        replay: function replay(audioParam) {\n          var _iterator = _createForOfIteratorHelper$5(automationEventList),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var automationEvent = _step.value;\n              if (automationEvent.type === 'exponentialRampToValue') {\n                var endTime = automationEvent.endTime,\n                  value = automationEvent.value;\n                audioParam.exponentialRampToValueAtTime(value, endTime);\n              } else if (automationEvent.type === 'linearRampToValue') {\n                var _endTime = automationEvent.endTime,\n                  _value = automationEvent.value;\n                audioParam.linearRampToValueAtTime(_value, _endTime);\n              } else if (automationEvent.type === 'setTarget') {\n                var startTime = automationEvent.startTime,\n                  target = automationEvent.target,\n                  timeConstant = automationEvent.timeConstant;\n                audioParam.setTargetAtTime(target, startTime, timeConstant);\n              } else if (automationEvent.type === 'setValue') {\n                var _startTime = automationEvent.startTime,\n                  _value2 = automationEvent.value;\n                audioParam.setValueAtTime(_value2, _startTime);\n              } else if (automationEvent.type === 'setValueCurve') {\n                var duration = automationEvent.duration,\n                  _startTime2 = automationEvent.startTime,\n                  values = automationEvent.values;\n                audioParam.setValueCurveAtTime(values, _startTime2, duration);\n              } else {\n                throw new Error(\"Can't apply an unknown automation.\");\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      };\n    };\n\n    var ReadOnlyMap = /*#__PURE__*/function () {\n      function ReadOnlyMap(parameters) {\n        _classCallCheck(this, ReadOnlyMap);\n        this._map = new Map(parameters);\n      }\n      return _createClass(ReadOnlyMap, [{\n        key: \"size\",\n        get: function get() {\n          return this._map.size;\n        }\n      }, {\n        key: \"entries\",\n        value: function entries() {\n          return this._map.entries();\n        }\n      }, {\n        key: \"forEach\",\n        value: function forEach(callback) {\n          var _this = this;\n          var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          return this._map.forEach(function (value, key) {\n            return callback.call(thisArg, value, key, _this);\n          });\n        }\n      }, {\n        key: \"get\",\n        value: function get(name) {\n          return this._map.get(name);\n        }\n      }, {\n        key: \"has\",\n        value: function has(name) {\n          return this._map.has(name);\n        }\n      }, {\n        key: \"keys\",\n        value: function keys() {\n          return this._map.keys();\n        }\n      }, {\n        key: \"values\",\n        value: function values() {\n          return this._map.values();\n        }\n      }]);\n    }();\n\n    function ownKeys$t(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$t(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$t(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$t(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$m(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$m() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$m() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$m = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$h = {\n      channelCount: 2,\n      // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: 1,\n      numberOfOutputs: 1,\n      parameterData: {},\n      processorOptions: {}\n    };\n    var createAudioWorkletNodeConstructor = function createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function AudioWorkletNode(context, name, options) {\n          var _this;\n          _classCallCheck(this, AudioWorkletNode);\n          var _a;\n          var nativeContext = getNativeContext(context);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var mergedOptions = sanitizeAudioWorkletNodeOptions(_objectSpread$t(_objectSpread$t({}, DEFAULT_OPTIONS$h), options));\n          // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n          testAudioWorkletNodeOptionsClonability(mergedOptions);\n          var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n          var processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n          // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n          var nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n          var nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n          var audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n          /*\n           * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n           * returns false.\n           */\n          _this = _callSuper$m(this, AudioWorkletNode, [context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer]);\n          var parameters = [];\n          nativeAudioWorkletNode.parameters.forEach(function (nativeAudioParam, nm) {\n            var audioParam = createAudioParam(_this, isOffline, nativeAudioParam);\n            parameters.push([nm, audioParam]);\n          });\n          _this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n          _this._onprocessorerror = null;\n          _this._parameters = new ReadOnlyMap(parameters);\n          /*\n           * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n           * the destination.\n           */\n          if (isOffline) {\n            addUnrenderedAudioWorkletNode(nativeContext, _this);\n          }\n          var _getAudioNodeConnecti = getAudioNodeConnections(_this),\n            activeInputs = _getAudioNodeConnecti.activeInputs;\n          setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n          return _this;\n        }\n        _inherits(AudioWorkletNode, _audioNodeConstructor);\n        return _createClass(AudioWorkletNode, [{\n          key: \"onprocessorerror\",\n          get: function get() {\n            return this._onprocessorerror;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            var nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n          }\n        }, {\n          key: \"parameters\",\n          get: function get() {\n            if (this._parameters === null) {\n              // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n              return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n          }\n        }, {\n          key: \"port\",\n          get: function get() {\n            return this._nativeAudioWorkletNode.port;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function copyFromChannel(audioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent, key, channelNumber, bufferOffset) {\n      if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n          parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n      } else {\n        var channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n          parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n          var slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n          parent[key].set(slicedInput);\n        }\n      }\n    }\n\n    var copyToChannel = function copyToChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {\n      if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n          audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n      } else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n          audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n      }\n    };\n\n    var createNestedArrays = function createNestedArrays(x, y) {\n      var arrays = [];\n      for (var i = 0; i < x; i += 1) {\n        var array = [];\n        var length = typeof y === 'number' ? y : y[i];\n        for (var j = 0; j < length; j += 1) {\n          array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n      }\n      return arrays;\n    };\n\n    var getAudioWorkletProcessor = function getAudioWorkletProcessor(nativeOfflineAudioContext, proxy) {\n      var nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n      var nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n    };\n\n    function _createForOfIteratorHelper$4(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$4(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$4(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$4(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0; } }\n    function _arrayLikeToArray$4(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    function ownKeys$s(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$s(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$s(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$s(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var processBuffer = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n        var length, numberOfInputChannels, numberOfOutputChannels, processedBuffer, audioNodeConnections, audioWorkletProcessor, inputs, outputs, parameters, _loop, _ret, i;\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // Ceil the length to the next full render quantum.\n              // Bug #17: Safari does not yet expose the length.\n              length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n              numberOfInputChannels = options.channelCount * options.numberOfInputs;\n              numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n                return sum + value;\n              }, 0);\n              processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n              if (!(processorConstructor === undefined)) {\n                _context2.next = 6;\n                break;\n              }\n              throw new Error('Missing the processor constructor.');\n            case 6:\n              audioNodeConnections = getAudioNodeConnections(proxy);\n              _context2.next = 9;\n              return getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n            case 9:\n              audioWorkletProcessor = _context2.sent;\n              inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n              outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n              parameters = Array.from(proxy.parameters.keys()).reduce(function (prmtrs, name) {\n                return _objectSpread$s(_objectSpread$s({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n              }, {});\n              _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop(i) {\n                var j, k, _j, _k, potentiallyEmptyInputs, activeSourceFlag, _j2, outputChannelSplitterNodeOutput, _k2;\n                return _regeneratorRuntime.wrap(function _loop$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n                        for (j = 0; j < options.numberOfInputs; j += 1) {\n                          for (k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                          }\n                        }\n                      }\n                      if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n                        processorConstructor.parameterDescriptors.forEach(function (_ref2, index) {\n                          var name = _ref2.name;\n                          copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                      }\n                      for (_j = 0; _j < options.numberOfInputs; _j += 1) {\n                        for (_k = 0; _k < outputChannelCount[_j]; _k += 1) {\n                          // The byteLength will be 0 when the ArrayBuffer was transferred.\n                          if (outputs[_j][_k].byteLength === 0) {\n                            outputs[_j][_k] = new Float32Array(128);\n                          }\n                        }\n                      }\n                      _context.prev = 3;\n                      potentiallyEmptyInputs = inputs.map(function (input, index) {\n                        if (audioNodeConnections.activeInputs[index].size === 0) {\n                          return [];\n                        }\n                        return input;\n                      });\n                      activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, function () {\n                        return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n                      });\n                      if (processedBuffer !== null) {\n                        for (_j2 = 0, outputChannelSplitterNodeOutput = 0; _j2 < options.numberOfOutputs; _j2 += 1) {\n                          for (_k2 = 0; _k2 < outputChannelCount[_j2]; _k2 += 1) {\n                            copyToChannel(processedBuffer, outputs[_j2], _k2, outputChannelSplitterNodeOutput + _k2, i);\n                          }\n                          outputChannelSplitterNodeOutput += outputChannelCount[_j2];\n                        }\n                      }\n                      if (activeSourceFlag) {\n                        _context.next = 9;\n                        break;\n                      }\n                      return _context.abrupt(\"return\", 0);\n                    case 9:\n                      _context.next = 15;\n                      break;\n                    case 11:\n                      _context.prev = 11;\n                      _context.t0 = _context[\"catch\"](3);\n                      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                        colno: _context.t0.colno,\n                        filename: _context.t0.filename,\n                        lineno: _context.t0.lineno,\n                        message: _context.t0.message\n                      }));\n                      return _context.abrupt(\"return\", 0);\n                    case 15:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _loop, null, [[3, 11]]);\n              });\n              i = 0;\n            case 15:\n              if (!(i < length)) {\n                _context2.next = 23;\n                break;\n              }\n              return _context2.delegateYield(_loop(i), \"t0\", 17);\n            case 17:\n              _ret = _context2.t0;\n              if (!(_ret === 0)) {\n                _context2.next = 20;\n                break;\n              }\n              return _context2.abrupt(\"break\", 23);\n            case 20:\n              i += 128;\n              _context2.next = 15;\n              break;\n            case 23:\n              return _context2.abrupt(\"return\", processedBuffer);\n            case 24:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee);\n      }));\n      return function processBuffer(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var createAudioWorkletNodeRendererFactory = function createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n      return function (name, options, processorConstructor) {\n        var renderedNativeAudioNodes = new WeakMap();\n        var processedBufferPromise = null;\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(proxy, nativeOfflineAudioContext) {\n            var nativeAudioWorkletNode, nativeOutputNodes, nativeAudioWorkletNodeIsOwnedByContext, outputChannelCount, numberOfOutputChannels, outputChannelSplitterNode, outputChannelMergerNodes, i, outputGainNode, numberOfInputChannels, numberOfParameters, numberOfChannels, renderBuffer, processedBuffer, audioBufferSourceNode, _nativeOutputNodes, _nativeOutputNodes2, _outputChannelSplitterNode, _outputChannelMergerNodes, _outputGainNode, _i3, outputChannelSplitterNodeOutput, outputChannelMergerNode, j, _iterator2, _step2, _step2$value, nm, audioParam, _iterator3, _step3, _step3$value, _nm, _audioParam;\n            return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n              while (1) switch (_context5.prev = _context5.next) {\n                case 0:\n                  nativeAudioWorkletNode = getNativeAudioNode(proxy);\n                  nativeOutputNodes = null;\n                  nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n                  outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n                  if (nativeAudioWorkletNodeConstructor === null) {\n                    numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n                      return sum + value;\n                    }, 0);\n                    outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                      channelCount: Math.max(1, numberOfOutputChannels),\n                      channelCountMode: 'explicit',\n                      channelInterpretation: 'discrete',\n                      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                    });\n                    outputChannelMergerNodes = [];\n                    for (i = 0; i < proxy.numberOfOutputs; i += 1) {\n                      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                      }));\n                    }\n                    outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                      channelCount: options.channelCount,\n                      channelCountMode: options.channelCountMode,\n                      channelInterpretation: options.channelInterpretation,\n                      gain: 1\n                    });\n                    outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                    outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                    nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n                  } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                    nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n                  if (!(nativeOutputNodes !== null)) {\n                    _context5.next = 41;\n                    break;\n                  }\n                  if (!(processedBufferPromise === null)) {\n                    _context5.next = 32;\n                    break;\n                  }\n                  if (!(processorConstructor === undefined)) {\n                    _context5.next = 10;\n                    break;\n                  }\n                  throw new Error('Missing the processor constructor.');\n                case 10:\n                  if (!(nativeOfflineAudioContextConstructor === null)) {\n                    _context5.next = 12;\n                    break;\n                  }\n                  throw new Error('Missing the native OfflineAudioContext constructor.');\n                case 12:\n                  // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                  numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                  numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                  numberOfChannels = numberOfInputChannels + numberOfParameters;\n                  renderBuffer = /*#__PURE__*/function () {\n                    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                      var partialOfflineAudioContext, gainNodes, inputChannelSplitterNodes, _i, constantSourceNodes, inputChannelMergerNode, _i2, j, _iterator, _step, _step$value, index, constantSourceNode;\n                      return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n                        while (1) switch (_context4.prev = _context4.next) {\n                          case 0:\n                            partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                            gainNodes = [];\n                            inputChannelSplitterNodes = [];\n                            for (_i = 0; _i < options.numberOfInputs; _i += 1) {\n                              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                              }));\n                              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                              }));\n                            }\n                            _context4.next = 6;\n                            return Promise.all(Array.from(proxy.parameters.values()).map(/*#__PURE__*/function () {\n                              var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioParam) {\n                                var constantSourceNode;\n                                return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n                                  while (1) switch (_context3.prev = _context3.next) {\n                                    case 0:\n                                      constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                        channelCount: 1,\n                                        channelCountMode: 'explicit',\n                                        channelInterpretation: 'discrete',\n                                        offset: audioParam.value\n                                      });\n                                      _context3.next = 3;\n                                      return renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                                    case 3:\n                                      return _context3.abrupt(\"return\", constantSourceNode);\n                                    case 4:\n                                    case \"end\":\n                                      return _context3.stop();\n                                  }\n                                }, _callee2);\n                              }));\n                              return function (_x10) {\n                                return _ref5.apply(this, arguments);\n                              };\n                            }()));\n                          case 6:\n                            constantSourceNodes = _context4.sent;\n                            inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                              channelCount: 1,\n                              channelCountMode: 'explicit',\n                              channelInterpretation: 'speakers',\n                              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                            });\n                            for (_i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n                              gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n                              for (j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n                              }\n                            }\n                            _iterator = _createForOfIteratorHelper$4(constantSourceNodes.entries());\n                            try {\n                              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                                _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], constantSourceNode = _step$value[1];\n                                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                                constantSourceNode.start(0);\n                              }\n                            } catch (err) {\n                              _iterator.e(err);\n                            } finally {\n                              _iterator.f();\n                            }\n                            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                            _context4.next = 14;\n                            return Promise.all(gainNodes.map(function (gainNode) {\n                              return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode);\n                            }));\n                          case 14:\n                            return _context4.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n                          case 15:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }, _callee3);\n                    }));\n                    return function renderBuffer() {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }();\n                  _context5.t0 = processBuffer;\n                  _context5.t1 = proxy;\n                  if (!(numberOfChannels === 0)) {\n                    _context5.next = 22;\n                    break;\n                  }\n                  _context5.t2 = null;\n                  _context5.next = 25;\n                  break;\n                case 22:\n                  _context5.next = 24;\n                  return renderBuffer();\n                case 24:\n                  _context5.t2 = _context5.sent;\n                case 25:\n                  _context5.t3 = _context5.t2;\n                  _context5.t4 = nativeOfflineAudioContext;\n                  _context5.t5 = options;\n                  _context5.t6 = outputChannelCount;\n                  _context5.t7 = processorConstructor;\n                  _context5.t8 = exposeCurrentFrameAndCurrentTime;\n                  processedBufferPromise = (0, _context5.t0)(_context5.t1, _context5.t3, _context5.t4, _context5.t5, _context5.t6, _context5.t7, _context5.t8);\n                case 32:\n                  _context5.next = 34;\n                  return processedBufferPromise;\n                case 34:\n                  processedBuffer = _context5.sent;\n                  audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                  });\n                  _nativeOutputNodes = nativeOutputNodes, _nativeOutputNodes2 = _slicedToArray(_nativeOutputNodes, 3), _outputChannelSplitterNode = _nativeOutputNodes2[0], _outputChannelMergerNodes = _nativeOutputNodes2[1], _outputGainNode = _nativeOutputNodes2[2];\n                  if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                  }\n                  audioBufferSourceNode.connect(_outputChannelSplitterNode);\n                  for (_i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < proxy.numberOfOutputs; _i3 += 1) {\n                    outputChannelMergerNode = _outputChannelMergerNodes[_i3];\n                    for (j = 0; j < outputChannelCount[_i3]; j += 1) {\n                      _outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[_i3];\n                  }\n                  return _context5.abrupt(\"return\", _outputGainNode);\n                case 41:\n                  if (nativeAudioWorkletNodeIsOwnedByContext) {\n                    _context5.next = 61;\n                    break;\n                  }\n                  _iterator2 = _createForOfIteratorHelper$4(proxy.parameters.entries());\n                  _context5.prev = 43;\n                  _iterator2.s();\n                case 45:\n                  if ((_step2 = _iterator2.n()).done) {\n                    _context5.next = 51;\n                    break;\n                  }\n                  _step2$value = _slicedToArray(_step2.value, 2), nm = _step2$value[0], audioParam = _step2$value[1];\n                  _context5.next = 49;\n                  return renderAutomation(nativeOfflineAudioContext, audioParam,\n                  // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                  nativeAudioWorkletNode.parameters.get(nm));\n                case 49:\n                  _context5.next = 45;\n                  break;\n                case 51:\n                  _context5.next = 56;\n                  break;\n                case 53:\n                  _context5.prev = 53;\n                  _context5.t9 = _context5[\"catch\"](43);\n                  _iterator2.e(_context5.t9);\n                case 56:\n                  _context5.prev = 56;\n                  _iterator2.f();\n                  return _context5.finish(56);\n                case 59:\n                  _context5.next = 78;\n                  break;\n                case 61:\n                  _iterator3 = _createForOfIteratorHelper$4(proxy.parameters.entries());\n                  _context5.prev = 62;\n                  _iterator3.s();\n                case 64:\n                  if ((_step3 = _iterator3.n()).done) {\n                    _context5.next = 70;\n                    break;\n                  }\n                  _step3$value = _slicedToArray(_step3.value, 2), _nm = _step3$value[0], _audioParam = _step3$value[1];\n                  _context5.next = 68;\n                  return connectAudioParam(nativeOfflineAudioContext, _audioParam,\n                  // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                  nativeAudioWorkletNode.parameters.get(_nm));\n                case 68:\n                  _context5.next = 64;\n                  break;\n                case 70:\n                  _context5.next = 75;\n                  break;\n                case 72:\n                  _context5.prev = 72;\n                  _context5.t10 = _context5[\"catch\"](62);\n                  _iterator3.e(_context5.t10);\n                case 75:\n                  _context5.prev = 75;\n                  _iterator3.f();\n                  return _context5.finish(75);\n                case 78:\n                  _context5.next = 80;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n                case 80:\n                  return _context5.abrupt(\"return\", nativeAudioWorkletNode);\n                case 81:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }, _callee4, null, [[43, 53, 56, 59], [62, 72, 75, 78]]);\n          }));\n          return function createAudioNode(_x8, _x9) {\n            return _ref3.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n            var renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$r(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$r(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$r(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$l(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$l() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$l() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$l = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createBaseAudioContextConstructor = function createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, _decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) {\n      return /*#__PURE__*/function (_minimalBaseAudioCont) {\n        function BaseAudioContext(_nativeContext, numberOfChannels) {\n          var _this;\n          _classCallCheck(this, BaseAudioContext);\n          _this = _callSuper$l(this, BaseAudioContext, [_nativeContext, numberOfChannels]);\n          _this._nativeContext = _nativeContext;\n          _this._audioWorklet = addAudioWorkletModule === undefined ? undefined : {\n            addModule: function addModule(moduleURL, options) {\n              return addAudioWorkletModule(_this, moduleURL, options);\n            }\n          };\n          return _this;\n        }\n        _inherits(BaseAudioContext, _minimalBaseAudioCont);\n        return _createClass(BaseAudioContext, [{\n          key: \"audioWorklet\",\n          get: function get() {\n            return this._audioWorklet;\n          }\n        }, {\n          key: \"createAnalyser\",\n          value: function createAnalyser() {\n            return new analyserNodeConstructor(this);\n          }\n        }, {\n          key: \"createBiquadFilter\",\n          value: function createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n          }\n        }, {\n          key: \"createBuffer\",\n          value: function createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({\n              length: length,\n              numberOfChannels: numberOfChannels,\n              sampleRate: sampleRate\n            });\n          }\n        }, {\n          key: \"createBufferSource\",\n          value: function createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n          }\n        }, {\n          key: \"createChannelMerger\",\n          value: function createChannelMerger() {\n            var numberOfInputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n            return new channelMergerNodeConstructor(this, {\n              numberOfInputs: numberOfInputs\n            });\n          }\n        }, {\n          key: \"createChannelSplitter\",\n          value: function createChannelSplitter() {\n            var numberOfOutputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n            return new channelSplitterNodeConstructor(this, {\n              numberOfOutputs: numberOfOutputs\n            });\n          }\n        }, {\n          key: \"createConstantSource\",\n          value: function createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n          }\n        }, {\n          key: \"createConvolver\",\n          value: function createConvolver() {\n            return new convolverNodeConstructor(this);\n          }\n        }, {\n          key: \"createDelay\",\n          value: function createDelay() {\n            var maxDelayTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n            return new delayNodeConstructor(this, {\n              maxDelayTime: maxDelayTime\n            });\n          }\n        }, {\n          key: \"createDynamicsCompressor\",\n          value: function createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n          }\n        }, {\n          key: \"createGain\",\n          value: function createGain() {\n            return new gainNodeConstructor(this);\n          }\n        }, {\n          key: \"createIIRFilter\",\n          value: function createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, {\n              feedback: feedback,\n              feedforward: feedforward\n            });\n          }\n        }, {\n          key: \"createOscillator\",\n          value: function createOscillator() {\n            return new oscillatorNodeConstructor(this);\n          }\n        }, {\n          key: \"createPanner\",\n          value: function createPanner() {\n            return new pannerNodeConstructor(this);\n          }\n        }, {\n          key: \"createPeriodicWave\",\n          value: function createPeriodicWave(real, imag) {\n            var constraints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n              disableNormalization: false\n            };\n            return new periodicWaveConstructor(this, _objectSpread$r(_objectSpread$r({}, constraints), {}, {\n              imag: imag,\n              real: real\n            }));\n          }\n        }, {\n          key: \"createStereoPanner\",\n          value: function createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n          }\n        }, {\n          key: \"createWaveShaper\",\n          value: function createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n          }\n        }, {\n          key: \"decodeAudioData\",\n          value: function decodeAudioData(audioData, successCallback, errorCallback) {\n            return _decodeAudioData(this._nativeContext, audioData).then(function (audioBuffer) {\n              if (typeof successCallback === 'function') {\n                successCallback(audioBuffer);\n              }\n              return audioBuffer;\n            }, function (err) {\n              if (typeof errorCallback === 'function') {\n                errorCallback(err);\n              }\n              throw err;\n            });\n          }\n        }]);\n      }(minimalBaseAudioContextConstructor);\n    };\n\n    function ownKeys$q(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$q(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$q(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$k(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$k() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$k() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$k = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$g = {\n      Q: 1,\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      detune: 0,\n      frequency: 350,\n      gain: 0,\n      type: 'lowpass'\n    };\n    var createBiquadFilterNodeConstructor = function createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function BiquadFilterNode(context, options) {\n          var _this;\n          _classCallCheck(this, BiquadFilterNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$q(_objectSpread$q({}, DEFAULT_OPTIONS$g), options);\n          var nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer() : null;\n          _this = _callSuper$k(this, BiquadFilterNode, [context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer]);\n          // Bug #80: Safari does not export the correct values for maxValue and minValue.\n          _this._Q = createAudioParam(_this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n          _this._detune = createAudioParam(_this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n          // Bug #77: Firefox & Safari do not export the correct value for minValue.\n          _this._frequency = createAudioParam(_this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n          // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n          _this._gain = createAudioParam(_this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(BiquadFilterNode, _audioNodeConstructor);\n        return _createClass(BiquadFilterNode, [{\n          key: \"detune\",\n          get: function get() {\n            return this._detune;\n          }\n        }, {\n          key: \"frequency\",\n          get: function get() {\n            return this._frequency;\n          }\n        }, {\n          key: \"gain\",\n          get: function get() {\n            return this._gain;\n          }\n        }, {\n          key: \"Q\",\n          get: function get() {\n            return this._Q;\n          }\n        }, {\n          key: \"type\",\n          get: function get() {\n            return this._nativeBiquadFilterNode.type;\n          },\n          set: function set(value) {\n            this._nativeBiquadFilterNode.type = value;\n          }\n        }, {\n          key: \"getFrequencyResponse\",\n          value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n              this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            } catch (err) {\n              if (err.code === 11) {\n                throw createInvalidAccessError();\n              }\n              throw err;\n            }\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n              throw createInvalidAccessError();\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createBiquadFilterNodeRendererFactory = function createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeBiquadFilterNodes = new WeakMap();\n        var createBiquadFilterNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeBiquadFilterNode, nativeBiquadFilterNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeBiquadFilterNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n                  if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                    options = {\n                      Q: nativeBiquadFilterNode.Q.value,\n                      channelCount: nativeBiquadFilterNode.channelCount,\n                      channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                      channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                      detune: nativeBiquadFilterNode.detune.value,\n                      frequency: nativeBiquadFilterNode.frequency.value,\n                      gain: nativeBiquadFilterNode.gain.value,\n                      type: nativeBiquadFilterNode.type\n                    };\n                    nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n                  if (nativeBiquadFilterNodeIsOwnedByContext) {\n                    _context.next = 15;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                case 7:\n                  _context.next = 9;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                case 9:\n                  _context.next = 11;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                case 11:\n                  _context.next = 13;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n                case 13:\n                  _context.next = 23;\n                  break;\n                case 15:\n                  _context.next = 17;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                case 17:\n                  _context.next = 19;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                case 19:\n                  _context.next = 21;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                case 21:\n                  _context.next = 23;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n                case 23:\n                  _context.next = 25;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n                case 25:\n                  return _context.abrupt(\"return\", nativeBiquadFilterNode);\n                case 26:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createBiquadFilterNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeBiquadFilterNode !== undefined) {\n              return Promise.resolve(renderedNativeBiquadFilterNode);\n            }\n            return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createCacheTestResult = function createCacheTestResult(ongoingTests, testResults) {\n      return function (tester, test) {\n        var cachedTestResult = testResults.get(tester);\n        if (cachedTestResult !== undefined) {\n          return cachedTestResult;\n        }\n        var ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n          return ongoingTest;\n        }\n        try {\n          var synchronousTestResult = test();\n          if (synchronousTestResult instanceof Promise) {\n            ongoingTests.set(tester, synchronousTestResult);\n            return synchronousTestResult[\"catch\"](function () {\n              return false;\n            }).then(function (finalTestResult) {\n              ongoingTests[\"delete\"](tester);\n              testResults.set(tester, finalTestResult);\n              return finalTestResult;\n            });\n          }\n          testResults.set(tester, synchronousTestResult);\n          return synchronousTestResult;\n        } catch (_unused) {\n          testResults.set(tester, false);\n          return false;\n        }\n      };\n    };\n\n    function ownKeys$p(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$p(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$p(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$j(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$j() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$j() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$j = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$f = {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: 6\n    };\n    var createChannelMergerNodeConstructor = function createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ChannelMergerNode(context, options) {\n          _classCallCheck(this, ChannelMergerNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$p(_objectSpread$p({}, DEFAULT_OPTIONS$f), options);\n          var nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n          var channelMergerNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null;\n          return _callSuper$j(this, ChannelMergerNode, [context, false, nativeChannelMergerNode, channelMergerNodeRenderer]);\n        }\n        _inherits(ChannelMergerNode, _audioNodeConstructor);\n        return _createClass(ChannelMergerNode);\n      }(audioNodeConstructor);\n    };\n\n    var createChannelMergerNodeRendererFactory = function createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAudioNodes = new WeakMap();\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAudioNode, nativeAudioNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n                  if (!nativeAudioNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeAudioNode.channelCount,\n                      channelCountMode: nativeAudioNode.channelCountMode,\n                      channelInterpretation: nativeAudioNode.channelInterpretation,\n                      numberOfInputs: nativeAudioNode.numberOfInputs\n                    };\n                    nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n                  _context.next = 6;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n                case 6:\n                  return _context.abrupt(\"return\", nativeAudioNode);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$o(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$o(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$o(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$i(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$i() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$i() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$i = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$e = {\n      channelCount: 6,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: 6\n    };\n    var createChannelSplitterNodeConstructor = function createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ChannelSplitterNode(context, options) {\n          _classCallCheck(this, ChannelSplitterNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = sanitizeChannelSplitterOptions(_objectSpread$o(_objectSpread$o({}, DEFAULT_OPTIONS$e), options));\n          var nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n          var channelSplitterNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null;\n          return _callSuper$i(this, ChannelSplitterNode, [context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer]);\n        }\n        _inherits(ChannelSplitterNode, _audioNodeConstructor);\n        return _createClass(ChannelSplitterNode);\n      }(audioNodeConstructor);\n    };\n\n    var createChannelSplitterNodeRendererFactory = function createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAudioNodes = new WeakMap();\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAudioNode, nativeAudioNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n                  if (!nativeAudioNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeAudioNode.channelCount,\n                      channelCountMode: nativeAudioNode.channelCountMode,\n                      channelInterpretation: nativeAudioNode.channelInterpretation,\n                      numberOfOutputs: nativeAudioNode.numberOfOutputs\n                    };\n                    nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n                  _context.next = 6;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n                case 6:\n                  return _context.abrupt(\"return\", nativeAudioNode);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createConnectAudioParam = function createConnectAudioParam(renderInputsOfAudioParam) {\n      return function (nativeOfflineAudioContext, audioParam, nativeAudioParam) {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n      };\n    };\n\n    var createConnectMultipleOutputs = function createConnectMultipleOutputs(createIndexSizeError) {\n      return function (outputAudioNodes, destination) {\n        var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n          throw createIndexSizeError();\n        }\n        if (isNativeAudioNode$1(destination)) {\n          return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n      };\n    };\n\n    var createConnectedNativeAudioBufferSourceNodeFactory = function createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode) {\n      return function (nativeContext, nativeAudioNode) {\n        var nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        var nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n        return function () {\n          nativeAudioBufferSourceNode.stop();\n          nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n      };\n    };\n\n    function ownKeys$n(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$n(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$n(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$h(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$h() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$h() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$h = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$d = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      offset: 1\n    };\n    var createConstantSourceNodeConstructor = function createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ConstantSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, ConstantSourceNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$n(_objectSpread$n({}, DEFAULT_OPTIONS$d), options);\n          var nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory() : null;\n          _this = _callSuper$h(this, ConstantSourceNode, [context, false, nativeConstantSourceNode, constantSourceNodeRenderer]);\n          _this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n          _this._nativeConstantSourceNode = nativeConstantSourceNode;\n          /*\n           * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n           * for GainNodes.\n           */\n          _this._offset = createAudioParam(_this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._onended = null;\n          return _this;\n        }\n        _inherits(ConstantSourceNode, _audioNodeConstructor);\n        return _createClass(ConstantSourceNode, [{\n          key: \"offset\",\n          get: function get() {\n            return this._offset;\n          }\n        }, {\n          key: \"onended\",\n          get: function get() {\n            return this._onended;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            var nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n          }\n        }, {\n          key: \"start\",\n          value: function start() {\n            var _this2 = this;\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n              this._constantSourceNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n              setInternalStateToActive(this);\n              var _resetInternalStateToPassive = function resetInternalStateToPassive() {\n                _this2._nativeConstantSourceNode.removeEventListener('ended', _resetInternalStateToPassive);\n                if (isActiveAudioNode(_this2)) {\n                  setInternalStateToPassive(_this2);\n                }\n              };\n              this._nativeConstantSourceNode.addEventListener('ended', _resetInternalStateToPassive);\n            }\n          }\n        }, {\n          key: \"stop\",\n          value: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n              this._constantSourceNodeRenderer.stop = when;\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createConstantSourceNodeRendererFactory = function createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeConstantSourceNodes = new WeakMap();\n        var start = null;\n        var stop = null;\n        var createConstantSourceNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeConstantSourceNode, nativeConstantSourceNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeConstantSourceNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n                  if (!nativeConstantSourceNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeConstantSourceNode.channelCount,\n                      channelCountMode: nativeConstantSourceNode.channelCountMode,\n                      channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                      offset: nativeConstantSourceNode.offset.value\n                    };\n                    nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                    if (start !== null) {\n                      nativeConstantSourceNode.start(start);\n                    }\n                    if (stop !== null) {\n                      nativeConstantSourceNode.stop(stop);\n                    }\n                  }\n                  renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n                  if (nativeConstantSourceNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeConstantSourceNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createConstantSourceNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          set start(value) {\n            start = value;\n          },\n          set stop(value) {\n            stop = value;\n          },\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeConstantSourceNode !== undefined) {\n              return Promise.resolve(renderedNativeConstantSourceNode);\n            }\n            return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createConvertNumberToUnsignedLong = function createConvertNumberToUnsignedLong(unit32Array) {\n      return function (value) {\n        unit32Array[0] = value;\n        return unit32Array[0];\n      };\n    };\n\n    function ownKeys$m(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$m(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$m(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$g(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$g() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$g() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$g = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$c = {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: 'clamped-max',\n      channelInterpretation: 'speakers',\n      disableNormalization: false\n    };\n    var createConvolverNodeConstructor = function createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ConvolverNode(context, options) {\n          var _this;\n          _classCallCheck(this, ConvolverNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$m(_objectSpread$m({}, DEFAULT_OPTIONS$c), options);\n          var nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var convolverNodeRenderer = isOffline ? createConvolverNodeRenderer() : null;\n          _this = _callSuper$g(this, ConvolverNode, [context, false, nativeConvolverNode, convolverNodeRenderer]);\n          _this._isBufferNullified = false;\n          _this._nativeConvolverNode = nativeConvolverNode;\n          if (mergedOptions.buffer !== null) {\n            setAudioNodeTailTime(_this, mergedOptions.buffer.duration);\n          }\n          return _this;\n        }\n        _inherits(ConvolverNode, _audioNodeConstructor);\n        return _createClass(ConvolverNode, [{\n          key: \"buffer\",\n          get: function get() {\n            if (this._isBufferNullified) {\n              return null;\n            }\n            return this._nativeConvolverNode.buffer;\n          },\n          set: function set(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n              var nativeContext = this._nativeConvolverNode.context;\n              this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n              this._isBufferNullified = true;\n              setAudioNodeTailTime(this, 0);\n            } else {\n              this._isBufferNullified = false;\n              setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n          }\n        }, {\n          key: \"normalize\",\n          get: function get() {\n            return this._nativeConvolverNode.normalize;\n          },\n          set: function set(value) {\n            this._nativeConvolverNode.normalize = value;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createConvolverNodeRendererFactory = function createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeConvolverNodes = new WeakMap();\n        var createConvolverNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeConvolverNode, nativeConvolverNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeConvolverNode = getNativeAudioNode(proxy); // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n                  if (!nativeConvolverNodeIsOwnedByContext) {\n                    options = {\n                      buffer: nativeConvolverNode.buffer,\n                      channelCount: nativeConvolverNode.channelCount,\n                      channelCountMode: nativeConvolverNode.channelCountMode,\n                      channelInterpretation: nativeConvolverNode.channelInterpretation,\n                      disableNormalization: !nativeConvolverNode.normalize\n                    };\n                    nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n                  if (!isNativeAudioNodeFaker(nativeConvolverNode)) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n                case 11:\n                  return _context.abrupt(\"return\", nativeConvolverNode);\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createConvolverNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeConvolverNode !== undefined) {\n              return Promise.resolve(renderedNativeConvolverNode);\n            }\n            return createConvolverNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createCreateNativeOfflineAudioContext = function createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor) {\n      return function (numberOfChannels, length, sampleRate) {\n        if (nativeOfflineAudioContextConstructor === null) {\n          throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n          return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        } catch (err) {\n          // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n          if (err.name === 'SyntaxError') {\n            throw createNotSupportedError();\n          }\n          throw err;\n        }\n      };\n    };\n\n    var createDataCloneError = function createDataCloneError() {\n      return new DOMException('', 'DataCloneError');\n    };\n\n    var detachArrayBuffer = function detachArrayBuffer(arrayBuffer) {\n      var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1,\n        port2 = _MessageChannel.port2;\n      return new Promise(function (resolve) {\n        var closeAndResolve = function closeAndResolve() {\n          port2.onmessage = null;\n          port1.close();\n          port2.close();\n          resolve();\n        };\n        port2.onmessage = function () {\n          return closeAndResolve();\n        };\n        try {\n          port1.postMessage(arrayBuffer, [arrayBuffer]);\n        } catch (_unused) {\n          // Ignore errors.\n        } finally {\n          closeAndResolve();\n        }\n      });\n    };\n\n    var createDecodeAudioData = function createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n      return function (anyContext, audioData) {\n        var nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n          var err = createDataCloneError();\n          return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n          detachedArrayBuffers.add(audioData);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, function () {\n          return testPromiseSupport(nativeContext);\n        })) {\n          return nativeContext.decodeAudioData(audioData).then(function (audioBuffer) {\n            // Bug #133: Safari does neuter the ArrayBuffer.\n            detachArrayBuffer(audioData)[\"catch\"](function () {\n              // Ignore errors.\n            });\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n              return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n            })) {\n              wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            return audioBuffer;\n          });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise(function (resolve, reject) {\n          var complete = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.prev = 0;\n                    _context.next = 3;\n                    return detachArrayBuffer(audioData);\n                  case 3:\n                    _context.next = 7;\n                    break;\n                  case 5:\n                    _context.prev = 5;\n                    _context.t0 = _context[\"catch\"](0);\n                  case 7:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, null, [[0, 5]]);\n            }));\n            return function complete() {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          var fail = function fail(err) {\n            reject(err);\n            complete();\n          };\n          // Bug #26: Safari throws a synchronous error.\n          try {\n            // Bug #1: Safari requires a successCallback.\n            nativeContext.decodeAudioData(audioData, function (audioBuffer) {\n              // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n              // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n              if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n              }\n              audioBufferStore.add(audioBuffer);\n              complete().then(function () {\n                return resolve(audioBuffer);\n              });\n            }, function (err) {\n              // Bug #4: Safari returns null instead of an error.\n              if (err === null) {\n                fail(createEncodingError());\n              } else {\n                fail(err);\n              }\n            });\n          } catch (err) {\n            fail(err);\n          }\n        });\n      };\n    };\n\n    function _createForOfIteratorHelper$3(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$3(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$3(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0; } }\n    function _arrayLikeToArray$3(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createDecrementCycleCounter = function createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) {\n      return function (audioNode, count) {\n        var cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n          throw new Error('Missing the expected cycle count.');\n        }\n        var nativeContext = getNativeContext(audioNode.context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n          cycleCounters[\"delete\"](audioNode);\n          if (!isOffline && isActiveAudioNode(audioNode)) {\n            var nativeSourceAudioNode = getNativeAudioNode(audioNode);\n            var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n              outputs = _getAudioNodeConnecti.outputs;\n            var _iterator = _createForOfIteratorHelper$3(outputs),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var output = _step.value;\n                if (isAudioNodeOutputConnection(output)) {\n                  var nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                  connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                } else {\n                  var nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                  nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n        } else {\n          cycleCounters.set(audioNode, cycleCounter - count);\n        }\n      };\n    };\n\n    function ownKeys$l(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$l(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$l(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$f(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$f() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$f() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$b = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      delayTime: 0,\n      maxDelayTime: 1\n    };\n    var createDelayNodeConstructor = function createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function DelayNode(context, options) {\n          var _this;\n          _classCallCheck(this, DelayNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$l(_objectSpread$l({}, DEFAULT_OPTIONS$b), options);\n          var nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var delayNodeRenderer = isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null;\n          _this = _callSuper$f(this, DelayNode, [context, false, nativeDelayNode, delayNodeRenderer]);\n          _this._delayTime = createAudioParam(_this, isOffline, nativeDelayNode.delayTime);\n          setAudioNodeTailTime(_this, mergedOptions.maxDelayTime);\n          return _this;\n        }\n        _inherits(DelayNode, _audioNodeConstructor);\n        return _createClass(DelayNode, [{\n          key: \"delayTime\",\n          get: function get() {\n            return this._delayTime;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createDelayNodeRendererFactory = function createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function (maxDelayTime) {\n        var renderedNativeDelayNodes = new WeakMap();\n        var createDelayNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeDelayNode, nativeDelayNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeDelayNode = getNativeAudioNode(proxy); // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n                  if (!nativeDelayNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeDelayNode.channelCount,\n                      channelCountMode: nativeDelayNode.channelCountMode,\n                      channelInterpretation: nativeDelayNode.channelInterpretation,\n                      delayTime: nativeDelayNode.delayTime.value,\n                      maxDelayTime: maxDelayTime\n                    };\n                    nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n                  if (nativeDelayNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeDelayNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createDelayNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeDelayNode !== undefined) {\n              return Promise.resolve(renderedNativeDelayNode);\n            }\n            return createDelayNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createDeleteActiveInputConnectionToAudioNode = function createDeleteActiveInputConnectionToAudioNode(pickElementFromSet) {\n      return function (activeInputs, source, output, input) {\n        return pickElementFromSet(activeInputs[input], function (activeInputConnection) {\n          return activeInputConnection[0] === source && activeInputConnection[1] === output;\n        });\n      };\n    };\n\n    var createDeleteUnrenderedAudioWorkletNode = function createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes) {\n      return function (nativeContext, audioWorkletNode) {\n        getUnrenderedAudioWorkletNodes(nativeContext)[\"delete\"](audioWorkletNode);\n      };\n    };\n\n    var isDelayNode = function isDelayNode(audioNode) {\n      return 'delayTime' in audioNode;\n    };\n\n    var createDetectCycles = function createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) {\n      return function detectCycles(chain, nextLink) {\n        var audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n          return [];\n        }\n        if (chain[0] === audioNode) {\n          return [chain];\n        }\n        if (chain.includes(audioNode)) {\n          return [];\n        }\n        var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n          outputs = _getAudioNodeConnecti.outputs;\n        return Array.from(outputs).map(function (outputConnection) {\n          return detectCycles([].concat(_toConsumableArray(chain), [audioNode]), outputConnection[0]);\n        }).reduce(function (mergedCycles, nestedCycles) {\n          return mergedCycles.concat(nestedCycles);\n        }, []);\n      };\n    };\n\n    var getOutputAudioNodeAtIndex = function getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output) {\n      var outputAudioNode = outputAudioNodes[output];\n      if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n      }\n      return outputAudioNode;\n    };\n    var createDisconnectMultipleOutputs = function createDisconnectMultipleOutputs(createIndexSizeError) {\n      return function (outputAudioNodes) {\n        var destinationOrOutput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n        var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        if (destinationOrOutput === undefined) {\n          return outputAudioNodes.forEach(function (outputAudioNode) {\n            return outputAudioNode.disconnect();\n          });\n        }\n        if (typeof destinationOrOutput === 'number') {\n          return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n        if (isNativeAudioNode$1(destinationOrOutput)) {\n          if (output === undefined) {\n            return outputAudioNodes.forEach(function (outputAudioNode) {\n              return outputAudioNode.disconnect(destinationOrOutput);\n            });\n          }\n          if (input === undefined) {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n          }\n          return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n          return outputAudioNodes.forEach(function (outputAudioNode) {\n            return outputAudioNode.disconnect(destinationOrOutput);\n          });\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n      };\n    };\n\n    function ownKeys$k(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$k(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$k(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$e(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$e() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$e() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$a = {\n      attack: 0.003,\n      channelCount: 2,\n      channelCountMode: 'clamped-max',\n      channelInterpretation: 'speakers',\n      knee: 30,\n      ratio: 12,\n      release: 0.25,\n      threshold: -24\n    };\n    var createDynamicsCompressorNodeConstructor = function createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function DynamicsCompressorNode(context, options) {\n          var _this;\n          _classCallCheck(this, DynamicsCompressorNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$k(_objectSpread$k({}, DEFAULT_OPTIONS$a), options);\n          var nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer() : null;\n          _this = _callSuper$e(this, DynamicsCompressorNode, [context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer]);\n          _this._attack = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.attack);\n          _this._knee = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.knee);\n          _this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n          _this._ratio = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.ratio);\n          _this._release = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.release);\n          _this._threshold = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.threshold);\n          setAudioNodeTailTime(_this, 0.006);\n          return _this;\n        }\n        _inherits(DynamicsCompressorNode, _audioNodeConstructor);\n        return _createClass(DynamicsCompressorNode, [{\n          key: \"attack\",\n          get: function get() {\n            return this._attack;\n          }\n          // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        }, {\n          key: \"channelCount\",\n          get: function get() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n          },\n          set: function set(value) {\n            var previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n              this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n              throw createNotSupportedError();\n            }\n          }\n          /*\n           * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n           * overwritten here.\n           */\n        }, {\n          key: \"channelCountMode\",\n          get: function get() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n          },\n          set: function set(value) {\n            var previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n              this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n              throw createNotSupportedError();\n            }\n          }\n        }, {\n          key: \"knee\",\n          get: function get() {\n            return this._knee;\n          }\n        }, {\n          key: \"ratio\",\n          get: function get() {\n            return this._ratio;\n          }\n        }, {\n          key: \"reduction\",\n          get: function get() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n              return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n          }\n        }, {\n          key: \"release\",\n          get: function get() {\n            return this._release;\n          }\n        }, {\n          key: \"threshold\",\n          get: function get() {\n            return this._threshold;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createDynamicsCompressorNodeRendererFactory = function createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeDynamicsCompressorNodes = new WeakMap();\n        var createDynamicsCompressorNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeDynamicsCompressorNode, nativeDynamicsCompressorNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n                   * created again.\n                   */\n                  nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n                  if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                    options = {\n                      attack: nativeDynamicsCompressorNode.attack.value,\n                      channelCount: nativeDynamicsCompressorNode.channelCount,\n                      channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                      channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                      knee: nativeDynamicsCompressorNode.knee.value,\n                      ratio: nativeDynamicsCompressorNode.ratio.value,\n                      release: nativeDynamicsCompressorNode.release.value,\n                      threshold: nativeDynamicsCompressorNode.threshold.value\n                    };\n                    nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n                  if (nativeDynamicsCompressorNodeIsOwnedByContext) {\n                    _context.next = 17;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                case 7:\n                  _context.next = 9;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                case 9:\n                  _context.next = 11;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                case 11:\n                  _context.next = 13;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                case 13:\n                  _context.next = 15;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n                case 15:\n                  _context.next = 27;\n                  break;\n                case 17:\n                  _context.next = 19;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                case 19:\n                  _context.next = 21;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                case 21:\n                  _context.next = 23;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                case 23:\n                  _context.next = 25;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                case 25:\n                  _context.next = 27;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n                case 27:\n                  _context.next = 29;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n                case 29:\n                  return _context.abrupt(\"return\", nativeDynamicsCompressorNode);\n                case 30:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createDynamicsCompressorNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeDynamicsCompressorNode !== undefined) {\n              return Promise.resolve(renderedNativeDynamicsCompressorNode);\n            }\n            return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createEncodingError = function createEncodingError() {\n      return new DOMException('', 'EncodingError');\n    };\n\n    var createEvaluateSource = function createEvaluateSource(window) {\n      return function (source) {\n        return new Promise(function (resolve, reject) {\n          if (window === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n            return;\n          }\n          var head = window.document.head;\n          if (head === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n          } else {\n            var script = window.document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            var blob = new Blob([source], {\n              type: 'application/javascript'\n            });\n            var url = URL.createObjectURL(blob);\n            var originalOnErrorHandler = window.onerror;\n            var removeErrorEventListenerAndRevokeUrl = function removeErrorEventListenerAndRevokeUrl() {\n              window.onerror = originalOnErrorHandler;\n              URL.revokeObjectURL(url);\n            };\n            window.onerror = function (message, src, lineno, colno, error) {\n              // @todo Edge thinks the source is the one of the html document.\n              if (src === url || src === window.location.href && lineno === 1 && colno === 1) {\n                removeErrorEventListenerAndRevokeUrl();\n                reject(error);\n                return false;\n              }\n              if (originalOnErrorHandler !== null) {\n                return originalOnErrorHandler(message, src, lineno, colno, error);\n              }\n            };\n            script.onerror = function () {\n              removeErrorEventListenerAndRevokeUrl();\n              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n              reject(new SyntaxError());\n            };\n            script.onload = function () {\n              removeErrorEventListenerAndRevokeUrl();\n              resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n          }\n        });\n      };\n    };\n\n    var createEventTargetConstructor = function createEventTargetConstructor(wrapEventListener) {\n      return /*#__PURE__*/function () {\n        function EventTarget(_nativeEventTarget) {\n          _classCallCheck(this, EventTarget);\n          this._nativeEventTarget = _nativeEventTarget;\n          this._listeners = new WeakMap();\n        }\n        return _createClass(EventTarget, [{\n          key: \"addEventListener\",\n          value: function addEventListener(type, listener, options) {\n            if (listener !== null) {\n              var wrappedEventListener = this._listeners.get(listener);\n              if (wrappedEventListener === undefined) {\n                wrappedEventListener = wrapEventListener(this, listener);\n                if (typeof listener === 'function') {\n                  this._listeners.set(listener, wrappedEventListener);\n                }\n              }\n              this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n          }\n        }, {\n          key: \"dispatchEvent\",\n          value: function dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n          }\n        }, {\n          key: \"removeEventListener\",\n          value: function removeEventListener(type, listener, options) {\n            var wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n          }\n        }]);\n      }();\n    };\n\n    var createExposeCurrentFrameAndCurrentTime = function createExposeCurrentFrameAndCurrentTime(window) {\n      return function (currentTime, sampleRate, fn) {\n        Object.defineProperties(window, {\n          currentFrame: {\n            configurable: true,\n            get: function get() {\n              return Math.round(currentTime * sampleRate);\n            }\n          },\n          currentTime: {\n            configurable: true,\n            get: function get() {\n              return currentTime;\n            }\n          }\n        });\n        try {\n          return fn();\n        } finally {\n          if (window !== null) {\n            delete window.currentFrame;\n            delete window.currentTime;\n          }\n        }\n      };\n    };\n\n    var createFetchSource = function createFetchSource(createAbortError) {\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n          var response;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return fetch(url);\n              case 3:\n                response = _context.sent;\n                if (!response.ok) {\n                  _context.next = 10;\n                  break;\n                }\n                _context.next = 7;\n                return response.text();\n              case 7:\n                _context.t0 = _context.sent;\n                _context.t1 = response.url;\n                return _context.abrupt(\"return\", [_context.t0, _context.t1]);\n              case 10:\n                _context.next = 14;\n                break;\n              case 12:\n                _context.prev = 12;\n                _context.t2 = _context[\"catch\"](0);\n              case 14:\n                throw createAbortError();\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, null, [[0, 12]]);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    };\n\n    function ownKeys$j(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$j(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$j(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$d(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$d() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$d() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$9 = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      gain: 1\n    };\n    var createGainNodeConstructor = function createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function GainNode(context, options) {\n          var _this;\n          _classCallCheck(this, GainNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$j(_objectSpread$j({}, DEFAULT_OPTIONS$9), options);\n          var nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var gainNodeRenderer = isOffline ? createGainNodeRenderer() : null;\n          _this = _callSuper$d(this, GainNode, [context, false, nativeGainNode, gainNodeRenderer]);\n          // Bug #74: Safari does not export the correct values for maxValue and minValue.\n          _this._gain = createAudioParam(_this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          return _this;\n        }\n        _inherits(GainNode, _audioNodeConstructor);\n        return _createClass(GainNode, [{\n          key: \"gain\",\n          get: function get() {\n            return this._gain;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createGainNodeRendererFactory = function createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeGainNodes = new WeakMap();\n        var createGainNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeGainNode, nativeGainNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeGainNode = getNativeAudioNode(proxy); // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n                  if (!nativeGainNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeGainNode.channelCount,\n                      channelCountMode: nativeGainNode.channelCountMode,\n                      channelInterpretation: nativeGainNode.channelInterpretation,\n                      gain: nativeGainNode.gain.value\n                    };\n                    nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n                  if (nativeGainNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeGainNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createGainNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeGainNode !== undefined) {\n              return Promise.resolve(renderedNativeGainNode);\n            }\n            return createGainNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createGetActiveAudioWorkletNodeInputs = function createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey) {\n      return function (nativeAudioWorkletNode) {\n        return getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n      };\n    };\n\n    var createGetAudioNodeRenderer = function createGetAudioNodeRenderer(getAudioNodeConnections) {\n      return function (audioNode) {\n        var audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n          throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n      };\n    };\n\n    var createGetAudioNodeTailTime = function createGetAudioNodeTailTime(audioNodeTailTimeStore) {\n      return function (audioNode) {\n        var _a;\n        return (_a = audioNodeTailTimeStore.get(audioNode)) !== null && _a !== void 0 ? _a : 0;\n      };\n    };\n\n    var createGetAudioParamRenderer = function createGetAudioParamRenderer(getAudioParamConnections) {\n      return function (audioParam) {\n        var audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n          throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n      };\n    };\n\n    var createGetBackupOfflineAudioContext = function createGetBackupOfflineAudioContext(backupOfflineAudioContextStore) {\n      return function (nativeContext) {\n        return backupOfflineAudioContextStore.get(nativeContext);\n      };\n    };\n\n    var createInvalidStateError = function createInvalidStateError() {\n      return new DOMException('', 'InvalidStateError');\n    };\n\n    var createGetNativeContext = function createGetNativeContext(contextStore) {\n      return function (context) {\n        var nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n          throw createInvalidStateError();\n        }\n        return nativeContext;\n      };\n    };\n\n    var createGetOrCreateBackupOfflineAudioContext = function createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor) {\n      return function (nativeContext) {\n        var backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n        if (backupOfflineAudioContext !== undefined) {\n          return backupOfflineAudioContext;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n          throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n        return backupOfflineAudioContext;\n      };\n    };\n\n    var createGetUnrenderedAudioWorkletNodes = function createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore) {\n      return function (nativeContext) {\n        var unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n        if (unrenderedAudioWorkletNodes === undefined) {\n          throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n        return unrenderedAudioWorkletNodes;\n      };\n    };\n\n    var createInvalidAccessError = function createInvalidAccessError() {\n      return new DOMException('', 'InvalidAccessError');\n    };\n\n    var wrapIIRFilterNodeGetFrequencyResponseMethod = function wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode) {\n      nativeIIRFilterNode.getFrequencyResponse = function (getFrequencyResponse) {\n        return function (frequencyHz, magResponse, phaseResponse) {\n          if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n            throw createInvalidAccessError();\n          }\n          return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n      }(nativeIIRFilterNode.getFrequencyResponse);\n    };\n\n    function ownKeys$i(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$i(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$i(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$c(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$c() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$c() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$8 = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers'\n    };\n    var createIIRFilterNodeConstructor = function createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function IIRFilterNode(context, options) {\n          var _this;\n          _classCallCheck(this, IIRFilterNode);\n          var nativeContext = getNativeContext(context);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var mergedOptions = _objectSpread$i(_objectSpread$i({}, DEFAULT_OPTIONS$8), options);\n          var nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n          var iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null;\n          _this = _callSuper$c(this, IIRFilterNode, [context, false, nativeIIRFilterNode, iirFilterNodeRenderer]);\n          // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n          // @todo Write a test which allows other browsers to remain unpatched.\n          wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n          _this._nativeIIRFilterNode = nativeIIRFilterNode;\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(IIRFilterNode, _audioNodeConstructor);\n        return _createClass(IIRFilterNode, [{\n          key: \"getFrequencyResponse\",\n          value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    // This implementation as shamelessly inspired by source code of\n    // tslint:disable-next-line:max-line-length\n    // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\n    var filterBuffer = function filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) {\n      var inputLength = input.length;\n      var i = bufferIndex;\n      for (var j = 0; j < inputLength; j += 1) {\n        var y = feedforward[0] * input[j];\n        for (var k = 1; k < minLength; k += 1) {\n          var x = i - k & bufferLength - 1; // tslint:disable-line:no-bitwise\n          y += feedforward[k] * xBuffer[x];\n          y -= feedback[k] * yBuffer[x];\n        }\n        for (var _k = minLength; _k < feedforwardLength; _k += 1) {\n          y += feedforward[_k] * xBuffer[i - _k & bufferLength - 1]; // tslint:disable-line:no-bitwise\n        }\n        for (var _k2 = minLength; _k2 < feedbackLength; _k2 += 1) {\n          y -= feedback[_k2] * yBuffer[i - _k2 & bufferLength - 1]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = i + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise\n        output[j] = y;\n      }\n      return i;\n    };\n\n    var filterFullBuffer = function filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) {\n      var convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n      var convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n      var feedbackLength = convertedFeedback.length;\n      var feedforwardLength = convertedFeedforward.length;\n      var minLength = Math.min(feedbackLength, feedforwardLength);\n      if (convertedFeedback[0] !== 1) {\n        for (var i = 0; i < feedbackLength; i += 1) {\n          convertedFeedforward[i] /= convertedFeedback[0];\n        }\n        for (var _i = 1; _i < feedforwardLength; _i += 1) {\n          convertedFeedback[_i] /= convertedFeedback[0];\n        }\n      }\n      var bufferLength = 32;\n      var xBuffer = new Float32Array(bufferLength);\n      var yBuffer = new Float32Array(bufferLength);\n      var filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n      var numberOfChannels = renderedBuffer.numberOfChannels;\n      for (var _i2 = 0; _i2 < numberOfChannels; _i2 += 1) {\n        var input = renderedBuffer.getChannelData(_i2);\n        var output = filteredBuffer.getChannelData(_i2);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n      }\n      return filteredBuffer;\n    };\n    var createIIRFilterNodeRendererFactory = function createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n      return function (feedback, feedforward) {\n        var renderedNativeAudioNodes = new WeakMap();\n        var filteredBufferPromise = null;\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(proxy, nativeOfflineAudioContext) {\n            var nativeAudioBufferSourceNode, nativeIIRFilterNode, nativeIIRFilterNodeIsOwnedByContext, partialOfflineAudioContext, filteredBuffer;\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) switch (_context2.prev = _context2.next) {\n                case 0:\n                  nativeAudioBufferSourceNode = null;\n                  nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.\n                  if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                    nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                      buffer: null,\n                      channelCount: 2,\n                      channelCountMode: 'max',\n                      channelInterpretation: 'speakers',\n                      loop: false,\n                      loopEnd: 0,\n                      loopStart: 0,\n                      playbackRate: 1\n                    });\n                  } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                    // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                    nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n                  if (!(nativeAudioBufferSourceNode !== null)) {\n                    _context2.next = 17;\n                    break;\n                  }\n                  if (!(filteredBufferPromise === null)) {\n                    _context2.next = 11;\n                    break;\n                  }\n                  if (!(nativeOfflineAudioContextConstructor === null)) {\n                    _context2.next = 9;\n                    break;\n                  }\n                  throw new Error('Missing the native OfflineAudioContext constructor.');\n                case 9:\n                  partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                  // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                  proxy.context.destination.channelCount,\n                  // Bug #17: Safari does not yet expose the length.\n                  proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                  filteredBufferPromise = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var renderedBuffer;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n                        case 2:\n                          _context.next = 4;\n                          return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        case 4:\n                          renderedBuffer = _context.sent;\n                          return _context.abrupt(\"return\", filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward));\n                        case 6:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee);\n                  }))();\n                case 11:\n                  _context2.next = 13;\n                  return filteredBufferPromise;\n                case 13:\n                  filteredBuffer = _context2.sent;\n                  nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                  nativeAudioBufferSourceNode.start(0);\n                  return _context2.abrupt(\"return\", nativeAudioBufferSourceNode);\n                case 17:\n                  _context2.next = 19;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n                case 19:\n                  return _context2.abrupt(\"return\", nativeIIRFilterNode);\n                case 20:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }, _callee2);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function _createForOfIteratorHelper$2(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$2(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }\n    function _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createIncrementCycleCounterFactory = function createIncrementCycleCounterFactory(cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) {\n      return function (isOffline) {\n        return function (audioNode, count) {\n          var cycleCounter = cycleCounters.get(audioNode);\n          if (cycleCounter === undefined) {\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n              var nativeSourceAudioNode = getNativeAudioNode(audioNode);\n              var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n                outputs = _getAudioNodeConnecti.outputs;\n              var _iterator = _createForOfIteratorHelper$2(outputs),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var output = _step.value;\n                  if (isAudioNodeOutputConnection(output)) {\n                    var nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                  } else {\n                    var nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                    nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            }\n            cycleCounters.set(audioNode, count);\n          } else {\n            cycleCounters.set(audioNode, cycleCounter + count);\n          }\n        };\n      };\n    };\n\n    var createIsAnyAudioContext = function createIsAnyAudioContext(contextStore, isNativeAudioContext) {\n      return function (anything) {\n        var nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n      };\n    };\n\n    var createIsAnyAudioNode = function createIsAnyAudioNode(audioNodeStore, isNativeAudioNode) {\n      return function (anything) {\n        return audioNodeStore.has(anything) || isNativeAudioNode(anything);\n      };\n    };\n\n    var createIsAnyAudioParam = function createIsAnyAudioParam(audioParamStore, isNativeAudioParam) {\n      return function (anything) {\n        return audioParamStore.has(anything) || isNativeAudioParam(anything);\n      };\n    };\n\n    var createIsAnyOfflineAudioContext = function createIsAnyOfflineAudioContext(contextStore, isNativeOfflineAudioContext) {\n      return function (anything) {\n        var nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n      };\n    };\n\n    var createIsNativeAudioContext = function createIsNativeAudioContext(nativeAudioContextConstructor) {\n      return function (anything) {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n      };\n    };\n\n    var createIsNativeAudioNode = function createIsNativeAudioNode(window) {\n      return function (anything) {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n      };\n    };\n\n    var createIsNativeAudioParam = function createIsNativeAudioParam(window) {\n      return function (anything) {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n      };\n    };\n\n    var createIsNativeContext = function createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext) {\n      return function (anything) {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n      };\n    };\n\n    var createIsNativeOfflineAudioContext = function createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor) {\n      return function (anything) {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n      };\n    };\n\n    var createIsSecureContext = function createIsSecureContext(window) {\n      return window !== null && window.isSecureContext;\n    };\n\n    var createIsSupportedPromise = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(cacheTestResult, testAudioBufferCopyChannelMethodsSubarraySupport, testAudioContextCloseMethodSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextOptionsSupport, testAudioNodeConnectMethodSupport, testAudioWorkletProcessorNoOutputsSupport, testChannelMergerNodeChannelCountSupport, testConstantSourceNodeAccurateSchedulingSupport, testConvolverNodeBufferReassignabilitySupport, testConvolverNodeChannelCountSupport, testDomExceptionContrucorSupport, testIsSecureContextSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testStereoPannerNodeDefaultValueSupport, testTransferablesSupport) {\n        var results;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) && cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) && cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) && cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) && cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) && cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) && cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) && cacheTestResult(testConvolverNodeChannelCountSupport, testConvolverNodeChannelCountSupport) && cacheTestResult(testDomExceptionContrucorSupport, testDomExceptionContrucorSupport) && cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) && cacheTestResult(testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport))) {\n                _context.next = 5;\n                break;\n              }\n              _context.next = 3;\n              return Promise.all([cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport), cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport), cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport), cacheTestResult(testTransferablesSupport, testTransferablesSupport)]);\n            case 3:\n              results = _context.sent;\n              return _context.abrupt(\"return\", results.every(function (result) {\n                return result;\n              }));\n            case 5:\n              return _context.abrupt(\"return\", false);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function createIsSupportedPromise(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14, _x15, _x16) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    function _callSuper$b(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$b() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$b() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMediaElementAudioSourceNodeConstructor = function createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaElementAudioSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, MediaElementAudioSourceNode);\n          var nativeContext = getNativeContext(context);\n          var nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n          // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n          if (isNativeOfflineAudioContext(nativeContext)) {\n            throw TypeError();\n          }\n          _this = _callSuper$b(this, MediaElementAudioSourceNode, [context, true, nativeMediaElementAudioSourceNode, null]);\n          _this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n          return _this;\n        }\n        _inherits(MediaElementAudioSourceNode, _audioNodeConstructor);\n        return _createClass(MediaElementAudioSourceNode, [{\n          key: \"mediaElement\",\n          get: function get() {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function ownKeys$h(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$h(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$h(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$a(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$a() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$a() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$a = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$7 = {\n      channelCount: 2,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers'\n    };\n    var createMediaStreamAudioDestinationNodeConstructor = function createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaStreamAudioDestinationNode(context, options) {\n          var _this;\n          _classCallCheck(this, MediaStreamAudioDestinationNode);\n          var nativeContext = getNativeContext(context);\n          // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n          if (isNativeOfflineAudioContext(nativeContext)) {\n            throw new TypeError();\n          }\n          var mergedOptions = _objectSpread$h(_objectSpread$h({}, DEFAULT_OPTIONS$7), options);\n          var nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n          _this = _callSuper$a(this, MediaStreamAudioDestinationNode, [context, false, nativeMediaStreamAudioDestinationNode, null]);\n          _this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n          return _this;\n        }\n        _inherits(MediaStreamAudioDestinationNode, _audioNodeConstructor);\n        return _createClass(MediaStreamAudioDestinationNode, [{\n          key: \"stream\",\n          get: function get() {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function _callSuper$9(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$9() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$9() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMediaStreamAudioSourceNodeConstructor = function createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaStreamAudioSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, MediaStreamAudioSourceNode);\n          var nativeContext = getNativeContext(context);\n          var nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n          // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n          if (isNativeOfflineAudioContext(nativeContext)) {\n            throw new TypeError();\n          }\n          _this = _callSuper$9(this, MediaStreamAudioSourceNode, [context, true, nativeMediaStreamAudioSourceNode, null]);\n          _this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n          return _this;\n        }\n        _inherits(MediaStreamAudioSourceNode, _audioNodeConstructor);\n        return _createClass(MediaStreamAudioSourceNode, [{\n          key: \"mediaStream\",\n          get: function get() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function _callSuper$8(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$8() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$8() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMediaStreamTrackAudioSourceNodeConstructor = function createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaStreamTrackAudioSourceNode(context, options) {\n          _classCallCheck(this, MediaStreamTrackAudioSourceNode);\n          var nativeContext = getNativeContext(context);\n          var nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n          return _callSuper$8(this, MediaStreamTrackAudioSourceNode, [context, true, nativeMediaStreamTrackAudioSourceNode, null]);\n        }\n        _inherits(MediaStreamTrackAudioSourceNode, _audioNodeConstructor);\n        return _createClass(MediaStreamTrackAudioSourceNode);\n      }(audioNodeConstructor);\n    };\n\n    function _callSuper$7(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$7() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$7() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMinimalAudioContextConstructor = function createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) {\n      return /*#__PURE__*/function (_minimalBaseAudioCont) {\n        function MinimalAudioContext() {\n          var _this;\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          _classCallCheck(this, MinimalAudioContext);\n          if (nativeAudioContextConstructor === null) {\n            throw new Error('Missing the native AudioContext constructor.');\n          }\n          var nativeAudioContext;\n          try {\n            nativeAudioContext = new nativeAudioContextConstructor(options);\n          } catch (err) {\n            // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n            if (err.code === 12 && err.message === 'sampleRate is not in range') {\n              throw createNotSupportedError();\n            }\n            throw err;\n          }\n          // Bug #131 Safari returns null when there are four other AudioContexts running already.\n          if (nativeAudioContext === null) {\n            throw createUnknownError();\n          }\n          // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n          if (!isValidLatencyHint(options.latencyHint)) {\n            throw new TypeError(\"The provided value '\".concat(options.latencyHint, \"' is not a valid enum value of type AudioContextLatencyCategory.\"));\n          }\n          // Bug #150 Safari does not support setting the sampleRate.\n          if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n            throw createNotSupportedError();\n          }\n          _this = _callSuper$7(this, MinimalAudioContext, [nativeAudioContext, 2]);\n          var latencyHint = options.latencyHint;\n          var _nativeAudioContext = nativeAudioContext,\n            sampleRate = _nativeAudioContext.sampleRate;\n          // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n          _this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n          /*\n           * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n           * ScriptProcessorNode.\n           */\n          Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n          _this._nativeAudioContext = nativeAudioContext;\n          // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n          if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            _this._nativeGainNode = nativeAudioContext.createGain();\n            _this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n            _this._nativeGainNode.gain.value = 1e-37;\n            _this._nativeOscillatorNode.connect(_this._nativeGainNode).connect(nativeAudioContext.destination);\n            _this._nativeOscillatorNode.start();\n          } else {\n            _this._nativeGainNode = null;\n            _this._nativeOscillatorNode = null;\n          }\n          _this._state = null;\n          /*\n           * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n           * to 'running'.\n           */\n          if (nativeAudioContext.state === 'running') {\n            _this._state = 'suspended';\n            var _revokeState = function revokeState() {\n              if (_this._state === 'suspended') {\n                _this._state = null;\n              }\n              nativeAudioContext.removeEventListener('statechange', _revokeState);\n            };\n            nativeAudioContext.addEventListener('statechange', _revokeState);\n          }\n          return _this;\n        }\n        _inherits(MinimalAudioContext, _minimalBaseAudioCont);\n        return _createClass(MinimalAudioContext, [{\n          key: \"baseLatency\",\n          get: function get() {\n            return this._baseLatency;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n          }\n        }, {\n          key: \"close\",\n          value: function close() {\n            var _this2 = this;\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n              return this._nativeAudioContext.close().then(function () {\n                throw createInvalidStateError();\n              });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n              this._state = null;\n            }\n            return this._nativeAudioContext.close().then(function () {\n              if (_this2._nativeGainNode !== null && _this2._nativeOscillatorNode !== null) {\n                _this2._nativeOscillatorNode.stop();\n                _this2._nativeGainNode.disconnect();\n                _this2._nativeOscillatorNode.disconnect();\n              }\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"resume\",\n          value: function resume() {\n            var _this3 = this;\n            if (this._state === 'suspended') {\n              return new Promise(function (resolve, reject) {\n                var _resolvePromise = function resolvePromise() {\n                  _this3._nativeAudioContext.removeEventListener('statechange', _resolvePromise);\n                  if (_this3._nativeAudioContext.state === 'running') {\n                    resolve();\n                  } else {\n                    _this3.resume().then(resolve, reject);\n                  }\n                };\n                _this3._nativeAudioContext.addEventListener('statechange', _resolvePromise);\n              });\n            }\n            return this._nativeAudioContext.resume()[\"catch\"](function (err) {\n              // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined || err.code === 15) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }, {\n          key: \"suspend\",\n          value: function suspend() {\n            return this._nativeAudioContext.suspend()[\"catch\"](function (err) {\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }]);\n      }(minimalBaseAudioContextConstructor);\n    };\n\n    function _callSuper$6(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$6() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMinimalBaseAudioContextConstructor = function createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) {\n      return /*#__PURE__*/function (_eventTargetConstruct) {\n        function MinimalBaseAudioContext(_nativeContext, numberOfChannels) {\n          var _this;\n          _classCallCheck(this, MinimalBaseAudioContext);\n          _this = _callSuper$6(this, MinimalBaseAudioContext, [_nativeContext]);\n          _this._nativeContext = _nativeContext;\n          CONTEXT_STORE.set(_this, _nativeContext);\n          if (isNativeOfflineAudioContext(_nativeContext)) {\n            unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n          }\n          _this._destination = new audioDestinationNodeConstructor(_this, numberOfChannels);\n          _this._listener = createAudioListener(_this, _nativeContext);\n          _this._onstatechange = null;\n          return _this;\n        }\n        _inherits(MinimalBaseAudioContext, _eventTargetConstruct);\n        return _createClass(MinimalBaseAudioContext, [{\n          key: \"currentTime\",\n          get: function get() {\n            return this._nativeContext.currentTime;\n          }\n        }, {\n          key: \"destination\",\n          get: function get() {\n            return this._destination;\n          }\n        }, {\n          key: \"listener\",\n          get: function get() {\n            return this._listener;\n          }\n        }, {\n          key: \"onstatechange\",\n          get: function get() {\n            return this._onstatechange;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeContext.onstatechange = wrappedListener;\n            var nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n          }\n        }, {\n          key: \"sampleRate\",\n          get: function get() {\n            return this._nativeContext.sampleRate;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._nativeContext.state;\n          }\n        }]);\n      }(eventTargetConstructor);\n    };\n\n    var testPromiseSupport = function testPromiseSupport(nativeContext) {\n      // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n      var uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n      try {\n        // Bug #1: Safari requires a successCallback.\n        var promise = nativeContext.decodeAudioData(uint32Array.buffer, function () {\n          // Ignore the success callback.\n        });\n        if (promise === undefined) {\n          return false;\n        }\n        promise[\"catch\"](function () {\n          // Ignore rejected errors.\n        });\n        return true;\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      return false;\n    };\n\n    function ownKeys$g(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$g(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$g(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$5(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$5() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$6 = {\n      numberOfChannels: 1\n    };\n    var createMinimalOfflineAudioContextConstructor = function createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, _startRendering) {\n      return /*#__PURE__*/function (_minimalBaseAudioCont) {\n        function MinimalOfflineAudioContext(options) {\n          var _this;\n          _classCallCheck(this, MinimalOfflineAudioContext);\n          var _DEFAULT_OPTIONS$opti = _objectSpread$g(_objectSpread$g({}, DEFAULT_OPTIONS$6), options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n          var nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n          // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n          if (!cacheTestResult(testPromiseSupport, function () {\n            return testPromiseSupport(nativeOfflineAudioContext);\n          })) {\n            nativeOfflineAudioContext.addEventListener('statechange', function () {\n              var i = 0;\n              var _delayStateChangeEvent = function delayStateChangeEvent(event) {\n                if (_this._state === 'running') {\n                  if (i > 0) {\n                    nativeOfflineAudioContext.removeEventListener('statechange', _delayStateChangeEvent);\n                    event.stopImmediatePropagation();\n                    _this._waitForThePromiseToSettle(event);\n                  } else {\n                    i += 1;\n                  }\n                }\n              };\n              return _delayStateChangeEvent;\n            }());\n          }\n          _this = _callSuper$5(this, MinimalOfflineAudioContext, [nativeOfflineAudioContext, numberOfChannels]);\n          _this._length = length;\n          _this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n          _this._state = null;\n          return _this;\n        }\n        _inherits(MinimalOfflineAudioContext, _minimalBaseAudioCont);\n        return _createClass(MinimalOfflineAudioContext, [{\n          key: \"length\",\n          get: function get() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n              return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n          }\n        }, {\n          key: \"startRendering\",\n          value: function startRendering() {\n            var _this2 = this;\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n              return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return _startRendering(this.destination, this._nativeOfflineAudioContext)[\"finally\"](function () {\n              _this2._state = null;\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"_waitForThePromiseToSettle\",\n          value: function _waitForThePromiseToSettle(event) {\n            var _this3 = this;\n            if (this._state === null) {\n              this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n              setTimeout(function () {\n                return _this3._waitForThePromiseToSettle(event);\n              });\n            }\n          }\n        }]);\n      }(minimalBaseAudioContextConstructor);\n    };\n\n    function _createForOfIteratorHelper$1(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$1(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$1(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0; } }\n    function _arrayLikeToArray$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createMonitorConnections = function createMonitorConnections(insertElementInSet, isNativeAudioNode) {\n      return function (nativeAudioNode, whenConnected, whenDisconnected) {\n        var connections = new Set();\n        nativeAudioNode.connect = function (connect) {\n          // tslint:disable-next-line:invalid-void no-inferrable-types\n          return function (destination) {\n            var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var wasDisconnected = connections.size === 0;\n            if (isNativeAudioNode(destination)) {\n              // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n              connect.call(nativeAudioNode, destination, output, input);\n              insertElementInSet(connections, [destination, output, input], function (connection) {\n                return connection[0] === destination && connection[1] === output && connection[2] === input;\n              }, true);\n              if (wasDisconnected) {\n                whenConnected();\n              }\n              return destination;\n            }\n            connect.call(nativeAudioNode, destination, output);\n            insertElementInSet(connections, [destination, output], function (connection) {\n              return connection[0] === destination && connection[1] === output;\n            }, true);\n            if (wasDisconnected) {\n              whenConnected();\n            }\n            return;\n          };\n        }(nativeAudioNode.connect);\n        nativeAudioNode.disconnect = function (disconnect) {\n          return function (destinationOrOutput, output, input) {\n            var wasConnected = connections.size > 0;\n            if (destinationOrOutput === undefined) {\n              disconnect.apply(nativeAudioNode);\n              connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n              // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n              disconnect.call(nativeAudioNode, destinationOrOutput);\n              var _iterator = _createForOfIteratorHelper$1(connections),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var connection = _step.value;\n                  if (connection[1] === destinationOrOutput) {\n                    connections[\"delete\"](connection);\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            } else {\n              if (isNativeAudioNode(destinationOrOutput)) {\n                // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n              } else {\n                // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                disconnect.call(nativeAudioNode, destinationOrOutput, output);\n              }\n              var _iterator2 = _createForOfIteratorHelper$1(connections),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _connection = _step2.value;\n                  if (_connection[0] === destinationOrOutput && (output === undefined || _connection[1] === output) && (input === undefined || _connection[2] === input)) {\n                    connections[\"delete\"](_connection);\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n            var isDisconnected = connections.size === 0;\n            if (wasConnected && isDisconnected) {\n              whenDisconnected();\n            }\n          };\n        }(nativeAudioNode.disconnect);\n        return nativeAudioNode;\n      };\n    };\n\n    var assignNativeAudioNodeOption = function assignNativeAudioNodeOption(nativeAudioNode, options, option) {\n      var value = options[option];\n      if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n      }\n    };\n\n    var assignNativeAudioNodeOptions = function assignNativeAudioNodeOptions(nativeAudioNode, options) {\n      assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n      assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n      assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n    };\n\n    var testAnalyserNodeGetFloatTimeDomainDataMethodSupport = function testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode) {\n      return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n    };\n\n    var wrapAnalyserNodeGetFloatTimeDomainDataMethod = function wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode) {\n      nativeAnalyserNode.getFloatTimeDomainData = function (array) {\n        var byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        var length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (var i = 0; i < length; i += 1) {\n          array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n      };\n    };\n\n    var createNativeAnalyserNodeFactory = function createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError) {\n      return function (nativeContext, options) {\n        var nativeAnalyserNode = nativeContext.createAnalyser();\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n          throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, function () {\n          return testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode);\n        })) {\n          wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n      };\n    };\n\n    var createNativeAudioBufferConstructor = function createNativeAudioBufferConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n      }\n      return null;\n    };\n\n    var assignNativeAudioNodeAudioParamValue = function assignNativeAudioNodeAudioParamValue(nativeAudioNode, options, audioParam) {\n      var value = options[audioParam];\n      if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n      }\n    };\n\n    var wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = function wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode) {\n      nativeAudioBufferSourceNode.start = function (start) {\n        var isScheduled = false;\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var duration = arguments.length > 2 ? arguments[2] : undefined;\n          if (isScheduled) {\n            throw createInvalidStateError();\n          }\n          start.call(nativeAudioBufferSourceNode, when, offset, duration);\n          isScheduled = true;\n        };\n      }(nativeAudioBufferSourceNode.start);\n    };\n\n    var wrapAudioScheduledSourceNodeStartMethodNegativeParameters = function wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioScheduledSourceNode) {\n      nativeAudioScheduledSourceNode.start = function (start) {\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var duration = arguments.length > 2 ? arguments[2] : undefined;\n          if (typeof duration === 'number' && duration < 0 || offset < 0 || when < 0) {\n            throw new RangeError(\"The parameters can't be negative.\");\n          }\n          // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n          start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n      }(nativeAudioScheduledSourceNode.start);\n    };\n\n    var wrapAudioScheduledSourceNodeStopMethodNegativeParameters = function wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioScheduledSourceNode) {\n      nativeAudioScheduledSourceNode.stop = function (stop) {\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          if (when < 0) {\n            throw new RangeError(\"The parameter can't be negative.\");\n          }\n          stop.call(nativeAudioScheduledSourceNode, when);\n        };\n      }(nativeAudioScheduledSourceNode.stop);\n    };\n\n    var createNativeAudioBufferSourceNodeFactory = function createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) {\n      return function (nativeContext, options) {\n        var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, function () {\n          return testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext);\n        })) {\n          wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, function () {\n          return testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext);\n        })) {\n          wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, function () {\n          return testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext);\n        })) {\n          wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n      };\n    };\n\n    var createNativeAudioContextConstructor = function createNativeAudioContextConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n      }\n      return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n    };\n\n    var createNativeAudioDestinationNodeFactory = function createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors) {\n      return function (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) {\n        var nativeAudioDestinationNode = nativeContext.destination;\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n          try {\n            nativeAudioDestinationNode.channelCount = channelCount;\n          } catch (_unused) {\n            // Bug #169: Safari throws an error on each attempt to change the channelCount.\n          }\n        }\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n          nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n          Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n            value: channelCount\n          });\n        }\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        var gainNode = createNativeGainNode(nativeContext, {\n          channelCount: channelCount,\n          channelCountMode: nativeAudioDestinationNode.channelCountMode,\n          channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n          gain: 1\n        });\n        overwriteAccessors(gainNode, 'channelCount', function (get) {\n          return function () {\n            return get.call(gainNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(gainNode, value);\n            try {\n              nativeAudioDestinationNode.channelCount = value;\n            } catch (err) {\n              // Bug #169: Safari throws an error on each attempt to change the channelCount.\n              if (value > nativeAudioDestinationNode.maxChannelCount) {\n                throw err;\n              }\n            }\n          };\n        });\n        overwriteAccessors(gainNode, 'channelCountMode', function (get) {\n          return function () {\n            return get.call(gainNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelCountMode = value;\n          };\n        });\n        overwriteAccessors(gainNode, 'channelInterpretation', function (get) {\n          return function () {\n            return get.call(gainNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelInterpretation = value;\n          };\n        });\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n          get: function get() {\n            return nativeAudioDestinationNode.maxChannelCount;\n          }\n        });\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n        return gainNode;\n      };\n    };\n\n    var createNativeAudioWorkletNodeConstructor = function createNativeAudioWorkletNodeConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n    };\n\n    var testClonabilityOfAudioWorkletNodeOptions = function testClonabilityOfAudioWorkletNodeOptions(audioWorkletNodeOptions) {\n      var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1;\n      try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n      } finally {\n        port1.close();\n      }\n    };\n\n    function ownKeys$f(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$f(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$f(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeAudioWorkletNodeFactory = function createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) {\n      return function (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n          try {\n            var nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeContext, name, options);\n            var patchedEventListeners = new Map();\n            var onprocessorerror = null;\n            Object.defineProperties(nativeAudioWorkletNode, {\n              /*\n               * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n               * browsers have no native implementation to achieve a consistent behavior.\n               */\n              channelCount: {\n                get: function get() {\n                  return options.channelCount;\n                },\n                set: function set() {\n                  throw createInvalidStateError();\n                }\n              },\n              channelCountMode: {\n                get: function get() {\n                  return 'explicit';\n                },\n                set: function set() {\n                  throw createInvalidStateError();\n                }\n              },\n              // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n              onprocessorerror: {\n                get: function get() {\n                  return onprocessorerror;\n                },\n                set: function set(value) {\n                  if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                  }\n                  onprocessorerror = typeof value === 'function' ? value : null;\n                  if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                  }\n                }\n              }\n            });\n            nativeAudioWorkletNode.addEventListener = function (addEventListener) {\n              return function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                if (args[0] === 'processorerror') {\n                  var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : _typeof(args[1]) === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n                  if (unpatchedEventListener !== null) {\n                    var patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                      args[1] = patchedEventListener;\n                    } else {\n                      args[1] = function (event) {\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        if (event.type === 'error') {\n                          Object.defineProperties(event, {\n                            type: {\n                              value: 'processorerror'\n                            }\n                          });\n                          unpatchedEventListener(event);\n                        } else {\n                          unpatchedEventListener(new ErrorEvent(args[0], _objectSpread$f({}, event)));\n                        }\n                      };\n                      patchedEventListeners.set(unpatchedEventListener, args[1]);\n                    }\n                  }\n                }\n                // Bug #178: Chrome and Edge do fire an event of type error.\n                addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                return addEventListener.call.apply(addEventListener, [nativeAudioWorkletNode].concat(args));\n              };\n            }(nativeAudioWorkletNode.addEventListener);\n            nativeAudioWorkletNode.removeEventListener = function (removeEventListener) {\n              return function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n                if (args[0] === 'processorerror') {\n                  var patchedEventListener = patchedEventListeners.get(args[1]);\n                  if (patchedEventListener !== undefined) {\n                    patchedEventListeners[\"delete\"](args[1]);\n                    args[1] = patchedEventListener;\n                  }\n                }\n                // Bug #178: Chrome and Edge do fire an event of type error.\n                removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n              };\n            }(nativeAudioWorkletNode.removeEventListener);\n            /*\n             * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n             * has an output.\n             */\n            if (options.numberOfOutputs !== 0) {\n              var nativeGainNode = createNativeGainNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n              });\n              nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n              var whenConnected = function whenConnected() {\n                return nativeGainNode.disconnect();\n              };\n              var whenDisconnected = function whenDisconnected() {\n                return nativeGainNode.connect(nativeContext.destination);\n              };\n              // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n              return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n            }\n            return nativeAudioWorkletNode;\n          } catch (err) {\n            // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n            if (err.code === 11) {\n              throw createNotSupportedError();\n            }\n            throw err;\n          }\n        }\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n          throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n      };\n    };\n\n    var computeBufferSize = function computeBufferSize(baseLatency, sampleRate) {\n      if (baseLatency === null) {\n        return 512;\n      }\n      return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n    };\n\n    var cloneAudioWorkletNodeOptions = function cloneAudioWorkletNodeOptions(audioWorkletNodeOptions) {\n      return new Promise(function (resolve, reject) {\n        var _MessageChannel = new MessageChannel(),\n          port1 = _MessageChannel.port1,\n          port2 = _MessageChannel.port2;\n        port1.onmessage = function (_ref) {\n          var data = _ref.data;\n          port1.close();\n          port2.close();\n          resolve(data);\n        };\n        port1.onmessageerror = function (_ref2) {\n          var data = _ref2.data;\n          port1.close();\n          port2.close();\n          reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n      });\n    };\n\n    var createAudioWorkletProcessorPromise = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(processorConstructor, audioWorkletNodeOptions) {\n        var clonedAudioWorkletNodeOptions;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n            case 2:\n              clonedAudioWorkletNodeOptions = _context.sent;\n              return _context.abrupt(\"return\", new processorConstructor(clonedAudioWorkletNodeOptions));\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function createAudioWorkletProcessorPromise(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var createAudioWorkletProcessor = function createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) {\n      var nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n      if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n      }\n      var audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n      nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n      return audioWorkletProcessorPromise;\n    };\n\n    function ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\n    function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createNativeAudioWorkletNodeFakerFactory = function createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) {\n      return function (nativeContext, baseLatency, processorConstructor, options) {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n          throw createNotSupportedError();\n        }\n        var outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some(function (channelCount) {\n          return channelCount < 1;\n        })) {\n          throw createNotSupportedError();\n        }\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n          throw createNotSupportedError();\n        }\n        var numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        var numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n          return sum + value;\n        }, 0);\n        var numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n          throw createNotSupportedError();\n        }\n        var messageChannel = new MessageChannel();\n        var gainNodes = [];\n        var inputChannelSplitterNodes = [];\n        for (var i = 0; i < options.numberOfInputs; i += 1) {\n          gainNodes.push(createNativeGainNode(nativeContext, {\n            channelCount: options.channelCount,\n            channelCountMode: options.channelCountMode,\n            channelInterpretation: options.channelInterpretation,\n            gain: 1\n          }));\n          inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n            channelCount: options.channelCount,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: options.channelCount\n          }));\n        }\n        var constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n          var _iterator = _createForOfIteratorHelper(processorConstructor.parameterDescriptors),\n            _step;\n          try {\n            var _loop = function _loop() {\n              var _step$value = _step.value,\n                defaultValue = _step$value.defaultValue,\n                maxValue = _step$value.maxValue,\n                minValue = _step$value.minValue,\n                name = _step$value.name;\n              var constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n              });\n              Object.defineProperties(constantSourceNode.offset, {\n                defaultValue: {\n                  get: function get() {\n                    return defaultValue === undefined ? 0 : defaultValue;\n                  }\n                },\n                maxValue: {\n                  get: function get() {\n                    return maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue;\n                  }\n                },\n                minValue: {\n                  get: function get() {\n                    return minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue;\n                  }\n                }\n              });\n              constantSourceNodes.push(constantSourceNode);\n            };\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        var inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'speakers',\n          numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters,\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        var outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        var outputChannelMergerNodes = [];\n        for (var _i = 0; _i < options.numberOfOutputs; _i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: outputChannelCount[_i]\n          }));\n        }\n        for (var _i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n          gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n          for (var j = 0; j < options.channelCount; j += 1) {\n            inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n          }\n        }\n        var parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(function (_ref, index) {\n          var name = _ref.name;\n          var constantSourceNode = constantSourceNodes[index];\n          constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n          constantSourceNode.start(0);\n          return [name, constantSourceNode.offset];\n        }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        var channelInterpretation = options.channelInterpretation;\n        var onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        var outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        var nativeAudioWorkletNodeFaker = {\n          get bufferSize() {\n            return bufferSize;\n          },\n          get channelCount() {\n            return options.channelCount;\n          },\n          set channelCount(_) {\n            // Bug #61: This is not part of the standard but required for the faker to work.\n            throw createInvalidStateError();\n          },\n          get channelCountMode() {\n            return options.channelCountMode;\n          },\n          set channelCountMode(_) {\n            // Bug #61: This is not part of the standard but required for the faker to work.\n            throw createInvalidStateError();\n          },\n          get channelInterpretation() {\n            return channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            for (var _i3 = 0, _gainNodes = gainNodes; _i3 < _gainNodes.length; _i3++) {\n              var gainNode = _gainNodes[_i3];\n              gainNode.channelInterpretation = value;\n            }\n            channelInterpretation = value;\n          },\n          get context() {\n            return scriptProcessorNode.context;\n          },\n          get inputs() {\n            return gainNodes;\n          },\n          get numberOfInputs() {\n            return options.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return options.numberOfOutputs;\n          },\n          get onprocessorerror() {\n            return onprocessorerror;\n          },\n          set onprocessorerror(value) {\n            if (typeof onprocessorerror === 'function') {\n              nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n            }\n            onprocessorerror = typeof value === 'function' ? value : null;\n            if (typeof onprocessorerror === 'function') {\n              nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n            }\n          },\n          get parameters() {\n            return parameterMap;\n          },\n          get port() {\n            return messageChannel.port2;\n          },\n          addEventListener: function addEventListener() {\n            return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n          disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n          dispatchEvent: function dispatchEvent() {\n            return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        var patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = function (addEventListener) {\n          return function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            if (args[0] === 'message') {\n              var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : _typeof(args[1]) === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n              if (unpatchedEventListener !== null) {\n                var patchedEventListener = patchedEventListeners.get(args[1]);\n                if (patchedEventListener !== undefined) {\n                  args[1] = patchedEventListener;\n                } else {\n                  args[1] = function (event) {\n                    exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, function () {\n                      return unpatchedEventListener(event);\n                    });\n                  };\n                  patchedEventListeners.set(unpatchedEventListener, args[1]);\n                }\n              }\n            }\n            return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n          };\n        }(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = function (removeEventListener) {\n          return function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n            if (args[0] === 'message') {\n              var patchedEventListener = patchedEventListeners.get(args[1]);\n              if (patchedEventListener !== undefined) {\n                patchedEventListeners[\"delete\"](args[1]);\n                args[1] = patchedEventListener;\n              }\n            }\n            return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n          };\n        }(messageChannel.port1.removeEventListener);\n        var onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n          get: function get() {\n            return onmessage;\n          },\n          set: function set(value) {\n            if (typeof onmessage === 'function') {\n              messageChannel.port1.removeEventListener('message', onmessage);\n            }\n            onmessage = typeof value === 'function' ? value : null;\n            if (typeof onmessage === 'function') {\n              messageChannel.port1.addEventListener('message', onmessage);\n              messageChannel.port1.start();\n            }\n          }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        var audioWorkletProcessor = null;\n        var audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then(function (dWrkltPrcssr) {\n          return audioWorkletProcessor = dWrkltPrcssr;\n        });\n        var inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        var outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        var parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce(function (prmtrs, _ref2) {\n          var name = _ref2.name;\n          return _objectSpread$e(_objectSpread$e({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n        }, {});\n        var isActive = true;\n        var disconnectOutputsGraph = function disconnectOutputsGraph() {\n          if (options.numberOfOutputs > 0) {\n            scriptProcessorNode.disconnect(outputChannelSplitterNode);\n          }\n          for (var _i4 = 0, outputChannelSplitterNodeOutput = 0; _i4 < options.numberOfOutputs; _i4 += 1) {\n            var outputChannelMergerNode = outputChannelMergerNodes[_i4];\n            for (var _j = 0; _j < outputChannelCount[_i4]; _j += 1) {\n              outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j, _j);\n            }\n            outputChannelSplitterNodeOutput += outputChannelCount[_i4];\n          }\n        };\n        var activeInputIndexes = new Map();\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = function (_ref3) {\n          var inputBuffer = _ref3.inputBuffer,\n            outputBuffer = _ref3.outputBuffer;\n          if (audioWorkletProcessor !== null) {\n            var activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n            var _loop2 = function _loop2(_i5) {\n              for (var _j2 = 0; _j2 < options.numberOfInputs; _j2 += 1) {\n                for (var k = 0; k < options.channelCount; k += 1) {\n                  copyFromChannel(inputBuffer, inputs[_j2], k, k, _i5);\n                }\n              }\n              if (processorConstructor.parameterDescriptors !== undefined) {\n                processorConstructor.parameterDescriptors.forEach(function (_ref4, index) {\n                  var name = _ref4.name;\n                  copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, _i5);\n                });\n              }\n              for (var _j3 = 0; _j3 < options.numberOfInputs; _j3 += 1) {\n                for (var _k = 0; _k < outputChannelCount[_j3]; _k += 1) {\n                  // The byteLength will be 0 when the ArrayBuffer was transferred.\n                  if (outputs[_j3][_k].byteLength === 0) {\n                    outputs[_j3][_k] = new Float32Array(128);\n                  }\n                }\n              }\n              try {\n                var potentiallyEmptyInputs = inputs.map(function (input, index) {\n                  var activeInput = activeInputs[index];\n                  if (activeInput.size > 0) {\n                    activeInputIndexes.set(index, bufferSize / 128);\n                    return input;\n                  }\n                  var count = activeInputIndexes.get(index);\n                  if (count === undefined) {\n                    return [];\n                  }\n                  if (input.every(function (channelData) {\n                    return channelData.every(function (sample) {\n                      return sample === 0;\n                    });\n                  })) {\n                    if (count === 1) {\n                      activeInputIndexes[\"delete\"](index);\n                    } else {\n                      activeInputIndexes.set(index, count - 1);\n                    }\n                  }\n                  return input;\n                });\n                var activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + _i5 / nativeContext.sampleRate, nativeContext.sampleRate, function () {\n                  return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n                });\n                isActive = activeSourceFlag;\n                for (var _j4 = 0, outputChannelSplitterNodeOutput = 0; _j4 < options.numberOfOutputs; _j4 += 1) {\n                  for (var _k2 = 0; _k2 < outputChannelCount[_j4]; _k2 += 1) {\n                    copyToChannel(outputBuffer, outputs[_j4], _k2, outputChannelSplitterNodeOutput + _k2, _i5);\n                  }\n                  outputChannelSplitterNodeOutput += outputChannelCount[_j4];\n                }\n              } catch (error) {\n                isActive = false;\n                nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                  colno: error.colno,\n                  filename: error.filename,\n                  lineno: error.lineno,\n                  message: error.message\n                }));\n              }\n              if (!isActive) {\n                for (var _j5 = 0; _j5 < options.numberOfInputs; _j5 += 1) {\n                  gainNodes[_j5].disconnect(inputChannelSplitterNodes[_j5]);\n                  for (var _k3 = 0; _k3 < options.channelCount; _k3 += 1) {\n                    inputChannelSplitterNodes[_i5].disconnect(inputChannelMergerNode, _k3, _j5 * options.channelCount + _k3);\n                  }\n                }\n                if (processorConstructor.parameterDescriptors !== undefined) {\n                  var length = processorConstructor.parameterDescriptors.length;\n                  for (var _j6 = 0; _j6 < length; _j6 += 1) {\n                    var constantSourceNode = constantSourceNodes[_j6];\n                    constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + _j6);\n                    constantSourceNode.stop();\n                  }\n                }\n                inputChannelMergerNode.disconnect(scriptProcessorNode);\n                scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                if (isConnected) {\n                  disconnectOutputsGraph();\n                } else {\n                  disconnectFakeGraph();\n                }\n                return 1; // break\n              }\n            };\n            for (var _i5 = 0; _i5 < bufferSize; _i5 += 128) {\n              if (_loop2(_i5)) break;\n            }\n          }\n        };\n        var isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        var nativeGainNode = createNativeGainNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: 0\n        });\n        var connectFakeGraph = function connectFakeGraph() {\n          return scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        };\n        var disconnectFakeGraph = function disconnectFakeGraph() {\n          scriptProcessorNode.disconnect(nativeGainNode);\n          nativeGainNode.disconnect();\n        };\n        var whenConnected = function whenConnected() {\n          if (isActive) {\n            disconnectFakeGraph();\n            if (options.numberOfOutputs > 0) {\n              scriptProcessorNode.connect(outputChannelSplitterNode);\n            }\n            for (var _i6 = 0, outputChannelSplitterNodeOutput = 0; _i6 < options.numberOfOutputs; _i6 += 1) {\n              var outputChannelMergerNode = outputChannelMergerNodes[_i6];\n              for (var _j7 = 0; _j7 < outputChannelCount[_i6]; _j7 += 1) {\n                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j7, _j7);\n              }\n              outputChannelSplitterNodeOutput += outputChannelCount[_i6];\n            }\n          }\n          isConnected = true;\n        };\n        var whenDisconnected = function whenDisconnected() {\n          if (isActive) {\n            connectFakeGraph();\n            disconnectOutputsGraph();\n          }\n          isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativeBiquadFilterNode = function createNativeBiquadFilterNode(nativeContext, options) {\n      var nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n      assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n      assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n      return nativeBiquadFilterNode;\n    };\n\n    var createNativeChannelMergerNodeFactory = function createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode) {\n      return function (nativeContext, options) {\n        var nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        return nativeChannelMergerNode;\n      };\n    };\n\n    var wrapChannelSplitterNode = function wrapChannelSplitterNode(channelSplitterNode) {\n      var channelCount = channelSplitterNode.numberOfOutputs;\n      // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n      Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: function get() {\n          return channelCount;\n        },\n        set: function set(value) {\n          if (value !== channelCount) {\n            throw createInvalidStateError();\n          }\n        }\n      });\n      // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n      Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: function get() {\n          return 'explicit';\n        },\n        set: function set(value) {\n          if (value !== 'explicit') {\n            throw createInvalidStateError();\n          }\n        }\n      });\n      // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n      Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: function get() {\n          return 'discrete';\n        },\n        set: function set(value) {\n          if (value !== 'discrete') {\n            throw createInvalidStateError();\n          }\n        }\n      });\n    };\n\n    var createNativeChannelSplitterNode = function createNativeChannelSplitterNode(nativeContext, options) {\n      var nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n      // Bug #96: Safari does not have the correct channelCount.\n      // Bug #29: Safari does not have the correct channelCountMode.\n      // Bug #31: Safari does not have the correct channelInterpretation.\n      assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n      // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n      wrapChannelSplitterNode(nativeChannelSplitterNode);\n      return nativeChannelSplitterNode;\n    };\n\n    var createNativeConstantSourceNodeFactory = function createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) {\n      return function (nativeContext, options) {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n          return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        var nativeConstantSourceNode = nativeContext.createConstantSource();\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n        return nativeConstantSourceNode;\n      };\n    };\n\n    var interceptConnections = function interceptConnections(original, interceptor) {\n      original.connect = interceptor.connect.bind(interceptor);\n      original.disconnect = interceptor.disconnect.bind(interceptor);\n      return original;\n    };\n\n    var _excluded$3 = [\"offset\"];\n    function ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeConstantSourceNodeFakerFactory = function createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) {\n      return function (nativeContext, _ref) {\n        var offset = _ref.offset,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded$3);\n        var audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        var audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        var gainNode = createNativeGainNode(nativeContext, _objectSpread$d(_objectSpread$d({}, audioNodeOptions), {}, {\n          gain: offset\n        }));\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        var channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        var nativeConstantSourceNodeFaker = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return gainNode.channelCount;\n          },\n          set channelCount(value) {\n            gainNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return gainNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            gainNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return gainNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            gainNode.channelInterpretation = value;\n          },\n          get context() {\n            return gainNode.context;\n          },\n          get inputs() {\n            return [];\n          },\n          get numberOfInputs() {\n            return audioBufferSourceNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return gainNode.numberOfOutputs;\n          },\n          get offset() {\n            return gainNode.gain;\n          },\n          get onended() {\n            return audioBufferSourceNode.onended;\n          },\n          set onended(value) {\n            audioBufferSourceNode.onended = value;\n          },\n          addEventListener: function addEventListener() {\n            return audioBufferSourceNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return audioBufferSourceNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return audioBufferSourceNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          start: function start() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n          },\n          stop: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n          }\n        };\n        var whenConnected = function whenConnected() {\n          return audioBufferSourceNode.connect(gainNode);\n        };\n        var whenDisconnected = function whenDisconnected() {\n          return audioBufferSourceNode.disconnect(gainNode);\n        };\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativeConvolverNodeFactory = function createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors) {\n      return function (nativeContext, options) {\n        var nativeConvolverNode = nativeContext.createConvolver();\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n          nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n          throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCount', function (get) {\n          return function () {\n            return get.call(nativeConvolverNode);\n          };\n        }, function (set) {\n          return function (value) {\n            if (value > 2) {\n              throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n          };\n        });\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCountMode', function (get) {\n          return function () {\n            return get.call(nativeConvolverNode);\n          };\n        }, function (set) {\n          return function (value) {\n            if (value === 'max') {\n              throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n          };\n        });\n        return nativeConvolverNode;\n      };\n    };\n\n    var createNativeDelayNode = function createNativeDelayNode(nativeContext, options) {\n      var nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n      assignNativeAudioNodeOptions(nativeDelayNode, options);\n      assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n      return nativeDelayNode;\n    };\n\n    var createNativeDynamicsCompressorNodeFactory = function createNativeDynamicsCompressorNodeFactory(createNotSupportedError) {\n      return function (nativeContext, options) {\n        var nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n          throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n      };\n    };\n\n    var createNativeGainNode = function createNativeGainNode(nativeContext, options) {\n      var nativeGainNode = nativeContext.createGain();\n      assignNativeAudioNodeOptions(nativeGainNode, options);\n      assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n      return nativeGainNode;\n    };\n\n    var createNativeIIRFilterNodeFactory = function createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker) {\n      return function (nativeContext, baseLatency, options) {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n          return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        var nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n      };\n    };\n\n    function divide(a, b) {\n      var denominator = b[0] * b[0] + b[1] * b[1];\n      return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n    }\n    function multiply(a, b) {\n      return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n    }\n    function evaluatePolynomial(coefficient, z) {\n      var result = [0, 0];\n      for (var i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n      }\n      return result;\n    }\n    var createNativeIIRFilterNodeFakerFactory = function createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) {\n      return function (nativeContext, baseLatency, _ref) {\n        var channelCount = _ref.channelCount,\n          channelCountMode = _ref.channelCountMode,\n          channelInterpretation = _ref.channelInterpretation,\n          feedback = _ref.feedback,\n          feedforward = _ref.feedforward;\n        var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        var convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        var convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        var feedbackLength = convertedFeedback.length;\n        var feedforwardLength = convertedFeedforward.length;\n        var minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedbackLength === 0 || feedbackLength > 20) {\n          throw createNotSupportedError();\n        }\n        if (convertedFeedback[0] === 0) {\n          throw createInvalidStateError();\n        }\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n          throw createNotSupportedError();\n        }\n        if (convertedFeedforward[0] === 0) {\n          throw createInvalidStateError();\n        }\n        if (convertedFeedback[0] !== 1) {\n          for (var i = 0; i < feedforwardLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n          }\n          for (var _i = 1; _i < feedbackLength; _i += 1) {\n            convertedFeedback[_i] /= convertedFeedback[0];\n          }\n        }\n        var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        var bufferLength = 32;\n        var bufferIndexes = [];\n        var xBuffers = [];\n        var yBuffers = [];\n        for (var _i2 = 0; _i2 < channelCount; _i2 += 1) {\n          bufferIndexes.push(0);\n          var xBuffer = new Float32Array(bufferLength);\n          var yBuffer = new Float32Array(bufferLength);\n          xBuffer.fill(0);\n          yBuffer.fill(0);\n          xBuffers.push(xBuffer);\n          yBuffers.push(yBuffer);\n        }\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = function (event) {\n          var inputBuffer = event.inputBuffer;\n          var outputBuffer = event.outputBuffer;\n          var numberOfChannels = inputBuffer.numberOfChannels;\n          for (var _i3 = 0; _i3 < numberOfChannels; _i3 += 1) {\n            var input = inputBuffer.getChannelData(_i3);\n            var output = outputBuffer.getChannelData(_i3);\n            bufferIndexes[_i3] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[_i3], yBuffers[_i3], bufferIndexes[_i3], bufferLength, input, output);\n          }\n        };\n        var nyquist = nativeContext.sampleRate / 2;\n        var nativeIIRFilterNodeFaker = {\n          get bufferSize() {\n            return bufferSize;\n          },\n          get channelCount() {\n            return scriptProcessorNode.channelCount;\n          },\n          set channelCount(value) {\n            scriptProcessorNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return scriptProcessorNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            scriptProcessorNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return scriptProcessorNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            scriptProcessorNode.channelInterpretation = value;\n          },\n          get context() {\n            return scriptProcessorNode.context;\n          },\n          get inputs() {\n            return [scriptProcessorNode];\n          },\n          get numberOfInputs() {\n            return scriptProcessorNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return scriptProcessorNode.numberOfOutputs;\n          },\n          addEventListener: function addEventListener() {\n            // @todo Dissallow adding an audioprocess listener.\n            return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          getFrequencyResponse: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n              throw createInvalidAccessError();\n            }\n            var length = frequencyHz.length;\n            for (var _i4 = 0; _i4 < length; _i4 += 1) {\n              var omega = -Math.PI * (frequencyHz[_i4] / nyquist);\n              var z = [Math.cos(omega), Math.sin(omega)];\n              var numerator = evaluatePolynomial(convertedFeedforward, z);\n              var denominator = evaluatePolynomial(convertedFeedback, z);\n              var response = divide(numerator, denominator);\n              magResponse[_i4] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n              phaseResponse[_i4] = Math.atan2(response[1], response[0]);\n            }\n          },\n          removeEventListener: function removeEventListener() {\n            return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n      };\n    };\n\n    var createNativeMediaElementAudioSourceNode = function createNativeMediaElementAudioSourceNode(nativeAudioContext, options) {\n      return nativeAudioContext.createMediaElementSource(options.mediaElement);\n    };\n\n    var createNativeMediaStreamAudioDestinationNode = function createNativeMediaStreamAudioDestinationNode(nativeAudioContext, options) {\n      var nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n      assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n      // Bug #174: Safari does expose a wrong numberOfOutputs.\n      if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', {\n          get: function get() {\n            return 0;\n          }\n        });\n      }\n      return nativeMediaStreamAudioDestinationNode;\n    };\n\n    var createNativeMediaStreamAudioSourceNode = function createNativeMediaStreamAudioSourceNode(nativeAudioContext, _ref) {\n      var mediaStream = _ref.mediaStream;\n      var audioStreamTracks = mediaStream.getAudioTracks();\n      /*\n       * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n       * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n       */\n      audioStreamTracks.sort(function (a, b) {\n        return a.id < b.id ? -1 : a.id > b.id ? 1 : 0;\n      });\n      var filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n      var nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n      /*\n       * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n       * to be overwritten as it would otherwise expose the reconstructed version.\n       */\n      Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', {\n        value: mediaStream\n      });\n      return nativeMediaStreamAudioSourceNode;\n    };\n\n    var createNativeMediaStreamTrackAudioSourceNodeFactory = function createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext) {\n      return function (nativeAudioContext, _ref) {\n        var mediaStreamTrack = _ref.mediaStreamTrack;\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n          return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n        var mediaStream = new MediaStream([mediaStreamTrack]);\n        var nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n          throw createInvalidStateError();\n        }\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n          throw new TypeError();\n        }\n        return nativeMediaStreamAudioSourceNode;\n      };\n    };\n\n    var createNativeOfflineAudioContextConstructor = function createNativeOfflineAudioContextConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n      }\n      return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n    };\n\n    var createNativeOscillatorNodeFactory = function createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) {\n      return function (nativeContext, options) {\n        var nativeOscillatorNode = nativeContext.createOscillator();\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n          nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        } else {\n          assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n        return nativeOscillatorNode;\n      };\n    };\n\n    var createNativePannerNodeFactory = function createNativePannerNodeFactory(createNativePannerNodeFaker) {\n      return function (nativeContext, options) {\n        var nativePannerNode = nativeContext.createPanner();\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n          return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n      };\n    };\n\n    var _excluded$2 = [\"coneInnerAngle\", \"coneOuterAngle\", \"coneOuterGain\", \"distanceModel\", \"maxDistance\", \"orientationX\", \"orientationY\", \"orientationZ\", \"panningModel\", \"positionX\", \"positionY\", \"positionZ\", \"refDistance\", \"rolloffFactor\"];\n    function ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativePannerNodeFakerFactory = function createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections) {\n      return function (nativeContext, _ref) {\n        var coneInnerAngle = _ref.coneInnerAngle,\n          coneOuterAngle = _ref.coneOuterAngle,\n          coneOuterGain = _ref.coneOuterGain,\n          distanceModel = _ref.distanceModel,\n          maxDistance = _ref.maxDistance,\n          orientationX = _ref.orientationX,\n          orientationY = _ref.orientationY,\n          orientationZ = _ref.orientationZ,\n          panningModel = _ref.panningModel,\n          positionX = _ref.positionX,\n          positionY = _ref.positionY,\n          positionZ = _ref.positionZ,\n          refDistance = _ref.refDistance,\n          rolloffFactor = _ref.rolloffFactor,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded$2);\n        var pannerNode = nativeContext.createPanner();\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n          throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        var SINGLE_CHANNEL_OPTIONS = {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete'\n        };\n        var channelMergerNode = createNativeChannelMergerNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          channelInterpretation: 'speakers',\n          numberOfInputs: 6\n        }));\n        var inputGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, audioNodeOptions), {}, {\n          gain: 1\n        }));\n        var orientationXGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 1\n        }));\n        var orientationYGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var orientationZGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var positionXGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var positionYGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var positionZGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        var waveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          curve: new Float32Array([1, 1]),\n          oversample: 'none'\n        }));\n        var lastOrientation = [orientationX, orientationY, orientationZ];\n        var lastPosition = [positionX, positionY, positionZ];\n        var buffer = new Float32Array(1);\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = function (_ref2) {\n          var inputBuffer = _ref2.inputBuffer;\n          var orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2)];\n          if (orientation.some(function (value, index) {\n            return value !== lastOrientation[index];\n          })) {\n            pannerNode.setOrientation.apply(pannerNode, orientation); // tslint:disable-line:deprecation\n            lastOrientation = orientation;\n          }\n          var positon = [getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];\n          if (positon.some(function (value, index) {\n            return value !== lastPosition[index];\n          })) {\n            pannerNode.setPosition.apply(pannerNode, positon); // tslint:disable-line:deprecation\n            lastPosition = positon;\n          }\n        };\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        var nativePannerNodeFaker = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return pannerNode.channelCount;\n          },\n          set channelCount(value) {\n            // Bug #125: Safari does not throw an error yet.\n            if (value > 2) {\n              throw createNotSupportedError();\n            }\n            inputGainNode.channelCount = value;\n            pannerNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return pannerNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            // Bug #126: Safari does not throw an error yet.\n            if (value === 'max') {\n              throw createNotSupportedError();\n            }\n            inputGainNode.channelCountMode = value;\n            pannerNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return pannerNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            inputGainNode.channelInterpretation = value;\n            pannerNode.channelInterpretation = value;\n          },\n          get coneInnerAngle() {\n            return pannerNode.coneInnerAngle;\n          },\n          set coneInnerAngle(value) {\n            pannerNode.coneInnerAngle = value;\n          },\n          get coneOuterAngle() {\n            return pannerNode.coneOuterAngle;\n          },\n          set coneOuterAngle(value) {\n            pannerNode.coneOuterAngle = value;\n          },\n          get coneOuterGain() {\n            return pannerNode.coneOuterGain;\n          },\n          set coneOuterGain(value) {\n            // Bug #127: Safari does not throw an InvalidStateError yet.\n            if (value < 0 || value > 1) {\n              throw createInvalidStateError();\n            }\n            pannerNode.coneOuterGain = value;\n          },\n          get context() {\n            return pannerNode.context;\n          },\n          get distanceModel() {\n            return pannerNode.distanceModel;\n          },\n          set distanceModel(value) {\n            pannerNode.distanceModel = value;\n          },\n          get inputs() {\n            return [inputGainNode];\n          },\n          get maxDistance() {\n            return pannerNode.maxDistance;\n          },\n          set maxDistance(value) {\n            // Bug #128: Safari does not throw an error yet.\n            if (value < 0) {\n              throw new RangeError();\n            }\n            pannerNode.maxDistance = value;\n          },\n          get numberOfInputs() {\n            return pannerNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return pannerNode.numberOfOutputs;\n          },\n          get orientationX() {\n            return orientationXGainNode.gain;\n          },\n          get orientationY() {\n            return orientationYGainNode.gain;\n          },\n          get orientationZ() {\n            return orientationZGainNode.gain;\n          },\n          get panningModel() {\n            return pannerNode.panningModel;\n          },\n          set panningModel(value) {\n            pannerNode.panningModel = value;\n          },\n          get positionX() {\n            return positionXGainNode.gain;\n          },\n          get positionY() {\n            return positionYGainNode.gain;\n          },\n          get positionZ() {\n            return positionZGainNode.gain;\n          },\n          get refDistance() {\n            return pannerNode.refDistance;\n          },\n          set refDistance(value) {\n            // Bug #129: Safari does not throw an error yet.\n            if (value < 0) {\n              throw new RangeError();\n            }\n            pannerNode.refDistance = value;\n          },\n          get rolloffFactor() {\n            return pannerNode.rolloffFactor;\n          },\n          set rolloffFactor(value) {\n            // Bug #130: Safari does not throw an error yet.\n            if (value < 0) {\n              throw new RangeError();\n            }\n            pannerNode.rolloffFactor = value;\n          },\n          addEventListener: function addEventListener() {\n            return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n          nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n          nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n          nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n          nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n          nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n          nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n          nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n          nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n          nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n          nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n          nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n          nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n          nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n          nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n          pannerNode.setOrientation.apply(pannerNode, _toConsumableArray(lastOrientation)); // tslint:disable-line:deprecation\n        }\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n          pannerNode.setPosition.apply(pannerNode, _toConsumableArray(lastPosition)); // tslint:disable-line:deprecation\n        }\n        var whenConnected = function whenConnected() {\n          inputGainNode.connect(pannerNode);\n          // Bug #119: Safari does not fully support the WaveShaperNode.\n          connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n          waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n          waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n          waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n          waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n          waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n          waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n          channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        var whenDisconnected = function whenDisconnected() {\n          inputGainNode.disconnect(pannerNode);\n          // Bug #119: Safari does not fully support the WaveShaperNode.\n          disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n          waveShaperNode.disconnect(orientationXGainNode);\n          orientationXGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(orientationYGainNode);\n          orientationYGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(orientationZGainNode);\n          orientationZGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(positionXGainNode);\n          positionXGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(positionYGainNode);\n          positionYGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(positionZGainNode);\n          positionZGainNode.disconnect(channelMergerNode);\n          channelMergerNode.disconnect(scriptProcessorNode);\n          scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativePeriodicWaveFactory = function createNativePeriodicWaveFactory(createIndexSizeError) {\n      return function (nativeContext, _ref) {\n        var disableNormalization = _ref.disableNormalization,\n          imag = _ref.imag,\n          real = _ref.real;\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        var convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        var convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n        var nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, {\n          disableNormalization: disableNormalization\n        });\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n          throw createIndexSizeError();\n        }\n        return nativePeriodicWave;\n      };\n    };\n\n    var createNativeScriptProcessorNode = function createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) {\n      return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n    };\n\n    var createNativeStereoPannerNodeFactory = function createNativeStereoPannerNodeFactory(createNativeStereoPannerNodeFaker, createNotSupportedError) {\n      return function (nativeContext, options) {\n        var channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n          throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n          return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        var nativeStereoPannerNode = nativeContext.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n          get: function get() {\n            return channelCountMode;\n          },\n          set: function set(value) {\n            if (value !== channelCountMode) {\n              throw createNotSupportedError();\n            }\n          }\n        });\n        return nativeStereoPannerNode;\n      };\n    };\n\n    var _excluded$1 = [\"channelCount\", \"channelCountMode\", \"pan\"];\n    function ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeStereoPannerNodeFakerFactory = function createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) {\n      // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n      var CURVE_SIZE = 16385;\n      var DC_CURVE = new Float32Array([1, 1]);\n      var HALF_PI = Math.PI / 2;\n      var SINGLE_CHANNEL_OPTIONS = {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete'\n      };\n      var SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n        oversample: 'none'\n      });\n      var buildInternalGraphForMono = function buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode) {\n        var leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (var i = 0; i < CURVE_SIZE; i += 1) {\n          var x = i / (CURVE_SIZE - 1) * HALF_PI;\n          leftWaveShaperCurve[i] = Math.cos(x);\n          rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        var leftGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: leftWaveShaperCurve\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var panWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: DC_CURVE\n        }));\n        var rightGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: rightWaveShaperCurve\n        }));\n        return {\n          connectGraph: function connectGraph() {\n            inputGainNode.connect(leftGainNode);\n            inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            inputGainNode.connect(rightGainNode);\n            panWaveShaperNode.connect(panGainNode);\n            panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n            panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n            leftWaveShaperNode.connect(leftGainNode.gain);\n            rightWaveShaperNode.connect(rightGainNode.gain);\n            leftGainNode.connect(channelMergerNode, 0, 0);\n            rightGainNode.connect(channelMergerNode, 0, 1);\n          },\n          disconnectGraph: function disconnectGraph() {\n            inputGainNode.disconnect(leftGainNode);\n            inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            inputGainNode.disconnect(rightGainNode);\n            panWaveShaperNode.disconnect(panGainNode);\n            panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n            leftWaveShaperNode.disconnect(leftGainNode.gain);\n            rightWaveShaperNode.disconnect(rightGainNode.gain);\n            leftGainNode.disconnect(channelMergerNode, 0, 0);\n            rightGainNode.disconnect(channelMergerNode, 0, 1);\n          }\n        };\n      };\n      var buildInternalGraphForStereo = function buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode) {\n        var leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (var i = 0; i < CURVE_SIZE; i += 1) {\n          if (i > centerIndex) {\n            var x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n            leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n            leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            rightInputForLeftOutputWaveShaperCurve[i] = 0;\n            rightInputForRightOutputWaveShaperCurve[i] = 1;\n          } else {\n            var _x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n            leftInputForLeftOutputWaveShaperCurve[i] = 1;\n            leftInputForRightOutputWaveShaperCurve[i] = 0;\n            rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(_x);\n            rightInputForRightOutputWaveShaperCurve[i] = Math.sin(_x);\n          }\n        }\n        var channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n          channelCount: 2,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: 2\n        });\n        var leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: leftInputForLeftOutputWaveShaperCurve\n        }));\n        var leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: leftInputForRightOutputWaveShaperCurve\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var panWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: DC_CURVE\n        }));\n        var rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: rightInputForLeftOutputWaveShaperCurve\n        }));\n        var rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: rightInputForRightOutputWaveShaperCurve\n        }));\n        return {\n          connectGraph: function connectGraph() {\n            inputGainNode.connect(channelSplitterNode);\n            inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n            channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n            channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n            channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n            panWaveShaperNode.connect(panGainNode);\n            panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n            panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n            leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n            leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n            rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n            rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n            leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n            rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n            leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n          },\n          disconnectGraph: function disconnectGraph() {\n            inputGainNode.disconnect(channelSplitterNode);\n            inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n            channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n            channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n            channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n            panWaveShaperNode.disconnect(panGainNode);\n            panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n            leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n            leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n            rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n            rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n            leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n            rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n            leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n          }\n        };\n      };\n      var buildInternalGraph = function buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) {\n        if (channelCount === 1) {\n          return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n          return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n      };\n      return function (nativeContext, _ref) {\n        var channelCount = _ref.channelCount,\n          channelCountMode = _ref.channelCountMode,\n          pan = _ref.pan,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded$1);\n        if (channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        var channelMergerNode = createNativeChannelMergerNode(nativeContext, _objectSpread$b(_objectSpread$b({}, audioNodeOptions), {}, {\n          channelCount: 1,\n          channelCountMode: channelCountMode,\n          numberOfInputs: 2\n        }));\n        var inputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, audioNodeOptions), {}, {\n          channelCount: channelCount,\n          channelCountMode: channelCountMode,\n          gain: 1\n        }));\n        var panGainNode = createNativeGainNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: pan\n        });\n        var _buildInternalGraph = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode),\n          connectGraph = _buildInternalGraph.connectGraph,\n          disconnectGraph = _buildInternalGraph.disconnectGraph;\n        Object.defineProperty(panGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(panGainNode.gain, 'maxValue', {\n          get: function get() {\n            return 1;\n          }\n        });\n        Object.defineProperty(panGainNode.gain, 'minValue', {\n          get: function get() {\n            return -1;\n          }\n        });\n        var nativeStereoPannerNodeFakerFactory = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return inputGainNode.channelCount;\n          },\n          set channelCount(value) {\n            if (inputGainNode.channelCount !== value) {\n              if (isConnected) {\n                disconnectGraph();\n              }\n              var _buildInternalGraph2 = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode);\n              connectGraph = _buildInternalGraph2.connectGraph;\n              disconnectGraph = _buildInternalGraph2.disconnectGraph;\n              if (isConnected) {\n                connectGraph();\n              }\n            }\n            inputGainNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return inputGainNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            if (value === 'clamped-max' || value === 'max') {\n              throw createNotSupportedError();\n            }\n            inputGainNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return inputGainNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            inputGainNode.channelInterpretation = value;\n          },\n          get context() {\n            return inputGainNode.context;\n          },\n          get inputs() {\n            return [inputGainNode];\n          },\n          get numberOfInputs() {\n            return inputGainNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return inputGainNode.numberOfOutputs;\n          },\n          get pan() {\n            return panGainNode.gain;\n          },\n          addEventListener: function addEventListener() {\n            return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        var isConnected = false;\n        var whenConnected = function whenConnected() {\n          connectGraph();\n          isConnected = true;\n        };\n        var whenDisconnected = function whenDisconnected() {\n          disconnectGraph();\n          isConnected = false;\n        };\n        return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativeWaveShaperNodeFactory = function createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) {\n      return function (nativeContext, options) {\n        var nativeWaveShaperNode = nativeContext.createWaveShaper();\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext' && nativeContext.createGain().gain.automationRate === undefined) {\n          return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        var curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n          throw createInvalidStateError();\n        }\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, {\n          curve: curve\n        }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        var disconnectNativeAudioBufferSourceNode = null;\n        var isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', function (get) {\n          return function () {\n            return get.call(nativeWaveShaperNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n              if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n              } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n              }\n            }\n            return value;\n          };\n        });\n        var whenConnected = function whenConnected() {\n          isConnected = true;\n          if (isDCCurve(nativeWaveShaperNode.curve)) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n          }\n        };\n        var whenDisconnected = function whenDisconnected() {\n          isConnected = false;\n          if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n      };\n    };\n\n    var _excluded = [\"curve\", \"oversample\"];\n    function ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeWaveShaperNodeFakerFactory = function createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) {\n      return function (nativeContext, _ref) {\n        var curve = _ref.curve,\n          oversample = _ref.oversample,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded);\n        var negativeWaveShaperNode = nativeContext.createWaveShaper();\n        var positiveWaveShaperNode = nativeContext.createWaveShaper();\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        var inputGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: 1\n        }));\n        var invertGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: -1\n        }));\n        var outputGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: 1\n        }));\n        var revertGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: -1\n        }));\n        var disconnectNativeAudioBufferSourceNode = null;\n        var isConnected = false;\n        var unmodifiedCurve = null;\n        var nativeWaveShaperNodeFaker = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return negativeWaveShaperNode.channelCount;\n          },\n          set channelCount(value) {\n            inputGainNode.channelCount = value;\n            invertGainNode.channelCount = value;\n            negativeWaveShaperNode.channelCount = value;\n            outputGainNode.channelCount = value;\n            positiveWaveShaperNode.channelCount = value;\n            revertGainNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return negativeWaveShaperNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            inputGainNode.channelCountMode = value;\n            invertGainNode.channelCountMode = value;\n            negativeWaveShaperNode.channelCountMode = value;\n            outputGainNode.channelCountMode = value;\n            positiveWaveShaperNode.channelCountMode = value;\n            revertGainNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return negativeWaveShaperNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            inputGainNode.channelInterpretation = value;\n            invertGainNode.channelInterpretation = value;\n            negativeWaveShaperNode.channelInterpretation = value;\n            outputGainNode.channelInterpretation = value;\n            positiveWaveShaperNode.channelInterpretation = value;\n            revertGainNode.channelInterpretation = value;\n          },\n          get context() {\n            return negativeWaveShaperNode.context;\n          },\n          get curve() {\n            return unmodifiedCurve;\n          },\n          set curve(value) {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            if (value !== null && value.length < 2) {\n              throw createInvalidStateError();\n            }\n            if (value === null) {\n              negativeWaveShaperNode.curve = value;\n              positiveWaveShaperNode.curve = value;\n            } else {\n              var curveLength = value.length;\n              var negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n              var positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n              negativeCurve[0] = value[0];\n              positiveCurve[0] = -value[curveLength - 1];\n              var length = Math.ceil((curveLength + 1) / 2);\n              var centerIndex = (curveLength + 1) / 2 - 1;\n              for (var i = 1; i < length; i += 1) {\n                var theoreticIndex = i / length * centerIndex;\n                var lowerIndex = Math.floor(theoreticIndex);\n                var upperIndex = Math.ceil(theoreticIndex);\n                negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n              }\n              negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n              negativeWaveShaperNode.curve = negativeCurve;\n              positiveWaveShaperNode.curve = positiveCurve;\n            }\n            unmodifiedCurve = value;\n            if (isConnected) {\n              if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n              } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n              }\n            }\n          },\n          get inputs() {\n            return [inputGainNode];\n          },\n          get numberOfInputs() {\n            return negativeWaveShaperNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return negativeWaveShaperNode.numberOfOutputs;\n          },\n          get oversample() {\n            return negativeWaveShaperNode.oversample;\n          },\n          set oversample(value) {\n            negativeWaveShaperNode.oversample = value;\n            positiveWaveShaperNode.oversample = value;\n          },\n          addEventListener: function addEventListener() {\n            return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        if (curve !== null) {\n          // Only values of type Float32Array can be assigned to the curve property.\n          nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n          nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        var whenConnected = function whenConnected() {\n          inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n          inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n          isConnected = true;\n          if (isDCCurve(unmodifiedCurve)) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          }\n        };\n        var whenDisconnected = function whenDisconnected() {\n          inputGainNode.disconnect(negativeWaveShaperNode);\n          negativeWaveShaperNode.disconnect(outputGainNode);\n          inputGainNode.disconnect(invertGainNode);\n          invertGainNode.disconnect(positiveWaveShaperNode);\n          positiveWaveShaperNode.disconnect(revertGainNode);\n          revertGainNode.disconnect(outputGainNode);\n          isConnected = false;\n          if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNotSupportedError = function createNotSupportedError() {\n      return new DOMException('', 'NotSupportedError');\n    };\n\n    function ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$4(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$4() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$5 = {\n      numberOfChannels: 1\n    };\n    var createOfflineAudioContextConstructor = function createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, _startRendering) {\n      return /*#__PURE__*/function (_baseAudioContextCons) {\n        function OfflineAudioContext(a, b, c) {\n          var _this;\n          _classCallCheck(this, OfflineAudioContext);\n          var options;\n          if (typeof a === 'number' && b !== undefined && c !== undefined) {\n            options = {\n              length: b,\n              numberOfChannels: a,\n              sampleRate: c\n            };\n          } else if (_typeof(a) === 'object') {\n            options = a;\n          } else {\n            throw new Error('The given parameters are not valid.');\n          }\n          var _DEFAULT_OPTIONS$opti = _objectSpread$9(_objectSpread$9({}, DEFAULT_OPTIONS$5), options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n          var nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n          // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n          if (!cacheTestResult(testPromiseSupport, function () {\n            return testPromiseSupport(nativeOfflineAudioContext);\n          })) {\n            nativeOfflineAudioContext.addEventListener('statechange', function () {\n              var i = 0;\n              var _delayStateChangeEvent = function delayStateChangeEvent(event) {\n                if (_this._state === 'running') {\n                  if (i > 0) {\n                    nativeOfflineAudioContext.removeEventListener('statechange', _delayStateChangeEvent);\n                    event.stopImmediatePropagation();\n                    _this._waitForThePromiseToSettle(event);\n                  } else {\n                    i += 1;\n                  }\n                }\n              };\n              return _delayStateChangeEvent;\n            }());\n          }\n          _this = _callSuper$4(this, OfflineAudioContext, [nativeOfflineAudioContext, numberOfChannels]);\n          _this._length = length;\n          _this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n          _this._state = null;\n          return _this;\n        }\n        _inherits(OfflineAudioContext, _baseAudioContextCons);\n        return _createClass(OfflineAudioContext, [{\n          key: \"length\",\n          get: function get() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n              return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n          }\n        }, {\n          key: \"startRendering\",\n          value: function startRendering() {\n            var _this2 = this;\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n              return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return _startRendering(this.destination, this._nativeOfflineAudioContext)[\"finally\"](function () {\n              _this2._state = null;\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"_waitForThePromiseToSettle\",\n          value: function _waitForThePromiseToSettle(event) {\n            var _this3 = this;\n            if (this._state === null) {\n              this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n              setTimeout(function () {\n                return _this3._waitForThePromiseToSettle(event);\n              });\n            }\n          }\n        }]);\n      }(baseAudioContextConstructor);\n    };\n\n    function ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$3(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$3() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$4 = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      // This attribute has no effect for nodes with no inputs.\n      channelInterpretation: 'speakers',\n      // This attribute has no effect for nodes with no inputs.\n      detune: 0,\n      frequency: 440,\n      periodicWave: undefined,\n      type: 'sine'\n    };\n    var createOscillatorNodeConstructor = function createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function OscillatorNode(context, options) {\n          var _this;\n          _classCallCheck(this, OscillatorNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$8(_objectSpread$8({}, DEFAULT_OPTIONS$4), options);\n          var nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer() : null;\n          var nyquist = context.sampleRate / 2;\n          _this = _callSuper$3(this, OscillatorNode, [context, false, nativeOscillatorNode, oscillatorNodeRenderer]);\n          // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n          _this._detune = createAudioParam(_this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n          // Bug #76: Safari does not export the correct values for maxValue and minValue.\n          _this._frequency = createAudioParam(_this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n          _this._nativeOscillatorNode = nativeOscillatorNode;\n          _this._onended = null;\n          _this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n          if (_this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n            _this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;\n          }\n          return _this;\n        }\n        _inherits(OscillatorNode, _audioNodeConstructor);\n        return _createClass(OscillatorNode, [{\n          key: \"detune\",\n          get: function get() {\n            return this._detune;\n          }\n        }, {\n          key: \"frequency\",\n          get: function get() {\n            return this._frequency;\n          }\n        }, {\n          key: \"onended\",\n          get: function get() {\n            return this._onended;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeOscillatorNode.onended = wrappedListener;\n            var nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n          }\n        }, {\n          key: \"type\",\n          get: function get() {\n            return this._nativeOscillatorNode.type;\n          },\n          set: function set(value) {\n            this._nativeOscillatorNode.type = value;\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.periodicWave = null;\n            }\n          }\n        }, {\n          key: \"setPeriodicWave\",\n          value: function setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n          }\n        }, {\n          key: \"start\",\n          value: function start() {\n            var _this2 = this;\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n              setInternalStateToActive(this);\n              var _resetInternalStateToPassive = function resetInternalStateToPassive() {\n                _this2._nativeOscillatorNode.removeEventListener('ended', _resetInternalStateToPassive);\n                if (isActiveAudioNode(_this2)) {\n                  setInternalStateToPassive(_this2);\n                }\n              };\n              this._nativeOscillatorNode.addEventListener('ended', _resetInternalStateToPassive);\n            }\n          }\n        }, {\n          key: \"stop\",\n          value: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.stop = when;\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createOscillatorNodeRendererFactory = function createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeOscillatorNodes = new WeakMap();\n        var periodicWave = null;\n        var start = null;\n        var stop = null;\n        var createOscillatorNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeOscillatorNode, nativeOscillatorNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeOscillatorNode = getNativeAudioNode(proxy); // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n                  if (!nativeOscillatorNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeOscillatorNode.channelCount,\n                      channelCountMode: nativeOscillatorNode.channelCountMode,\n                      channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                      detune: nativeOscillatorNode.detune.value,\n                      frequency: nativeOscillatorNode.frequency.value,\n                      periodicWave: periodicWave === null ? undefined : periodicWave,\n                      type: nativeOscillatorNode.type\n                    };\n                    nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                    if (start !== null) {\n                      nativeOscillatorNode.start(start);\n                    }\n                    if (stop !== null) {\n                      nativeOscillatorNode.stop(stop);\n                    }\n                  }\n                  renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n                  if (nativeOscillatorNodeIsOwnedByContext) {\n                    _context.next = 11;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                case 7:\n                  _context.next = 9;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n                case 9:\n                  _context.next = 15;\n                  break;\n                case 11:\n                  _context.next = 13;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                case 13:\n                  _context.next = 15;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n                case 15:\n                  _context.next = 17;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n                case 17:\n                  return _context.abrupt(\"return\", nativeOscillatorNode);\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createOscillatorNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          set periodicWave(value) {\n            periodicWave = value;\n          },\n          set start(value) {\n            start = value;\n          },\n          set stop(value) {\n            stop = value;\n          },\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeOscillatorNode !== undefined) {\n              return Promise.resolve(renderedNativeOscillatorNode);\n            }\n            return createOscillatorNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$3 = {\n      channelCount: 2,\n      channelCountMode: 'clamped-max',\n      channelInterpretation: 'speakers',\n      coneInnerAngle: 360,\n      coneOuterAngle: 360,\n      coneOuterGain: 0,\n      distanceModel: 'inverse',\n      maxDistance: 10000,\n      orientationX: 1,\n      orientationY: 0,\n      orientationZ: 0,\n      panningModel: 'equalpower',\n      positionX: 0,\n      positionY: 0,\n      positionZ: 0,\n      refDistance: 1,\n      rolloffFactor: 1\n    };\n    var createPannerNodeConstructor = function createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function PannerNode(context, options) {\n          var _this;\n          _classCallCheck(this, PannerNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$7(_objectSpread$7({}, DEFAULT_OPTIONS$3), options);\n          var nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var pannerNodeRenderer = isOffline ? createPannerNodeRenderer() : null;\n          _this = _callSuper$2(this, PannerNode, [context, false, nativePannerNode, pannerNodeRenderer]);\n          _this._nativePannerNode = nativePannerNode;\n          // Bug #74: Safari does not export the correct values for maxValue and minValue.\n          _this._orientationX = createAudioParam(_this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._orientationY = createAudioParam(_this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._orientationZ = createAudioParam(_this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._positionX = createAudioParam(_this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._positionY = createAudioParam(_this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._positionZ = createAudioParam(_this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(PannerNode, _audioNodeConstructor);\n        return _createClass(PannerNode, [{\n          key: \"coneInnerAngle\",\n          get: function get() {\n            return this._nativePannerNode.coneInnerAngle;\n          },\n          set: function set(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n          }\n        }, {\n          key: \"coneOuterAngle\",\n          get: function get() {\n            return this._nativePannerNode.coneOuterAngle;\n          },\n          set: function set(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n          }\n        }, {\n          key: \"coneOuterGain\",\n          get: function get() {\n            return this._nativePannerNode.coneOuterGain;\n          },\n          set: function set(value) {\n            this._nativePannerNode.coneOuterGain = value;\n          }\n        }, {\n          key: \"distanceModel\",\n          get: function get() {\n            return this._nativePannerNode.distanceModel;\n          },\n          set: function set(value) {\n            this._nativePannerNode.distanceModel = value;\n          }\n        }, {\n          key: \"maxDistance\",\n          get: function get() {\n            return this._nativePannerNode.maxDistance;\n          },\n          set: function set(value) {\n            this._nativePannerNode.maxDistance = value;\n          }\n        }, {\n          key: \"orientationX\",\n          get: function get() {\n            return this._orientationX;\n          }\n        }, {\n          key: \"orientationY\",\n          get: function get() {\n            return this._orientationY;\n          }\n        }, {\n          key: \"orientationZ\",\n          get: function get() {\n            return this._orientationZ;\n          }\n        }, {\n          key: \"panningModel\",\n          get: function get() {\n            return this._nativePannerNode.panningModel;\n          },\n          set: function set(value) {\n            this._nativePannerNode.panningModel = value;\n          }\n        }, {\n          key: \"positionX\",\n          get: function get() {\n            return this._positionX;\n          }\n        }, {\n          key: \"positionY\",\n          get: function get() {\n            return this._positionY;\n          }\n        }, {\n          key: \"positionZ\",\n          get: function get() {\n            return this._positionZ;\n          }\n        }, {\n          key: \"refDistance\",\n          get: function get() {\n            return this._nativePannerNode.refDistance;\n          },\n          set: function set(value) {\n            this._nativePannerNode.refDistance = value;\n          }\n        }, {\n          key: \"rolloffFactor\",\n          get: function get() {\n            return this._nativePannerNode.rolloffFactor;\n          },\n          set: function set(value) {\n            this._nativePannerNode.rolloffFactor = value;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createPannerNodeRendererFactory = function createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n      return function () {\n        var renderedNativeAudioNodes = new WeakMap();\n        var renderedBufferPromise = null;\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(proxy, nativeOfflineAudioContext) {\n            var nativeGainNode, nativePannerNode, commonAudioNodeOptions, commonNativePannerNodeOptions, nativePannerNodeIsOwnedByContext, options, partialOfflineAudioContext, nativeChannelMergerNode, renderedBuffer, inputGainNode, channelDatas, i, lastOrientation, lastPosition, gateGainNode, partialPannerNode, _i, orientation, positon, currentTime;\n            return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  nativeGainNode = null;\n                  nativePannerNode = getNativeAudioNode(proxy);\n                  commonAudioNodeOptions = {\n                    channelCount: nativePannerNode.channelCount,\n                    channelCountMode: nativePannerNode.channelCountMode,\n                    channelInterpretation: nativePannerNode.channelInterpretation\n                  };\n                  commonNativePannerNodeOptions = _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                    coneInnerAngle: nativePannerNode.coneInnerAngle,\n                    coneOuterAngle: nativePannerNode.coneOuterAngle,\n                    coneOuterGain: nativePannerNode.coneOuterGain,\n                    distanceModel: nativePannerNode.distanceModel,\n                    maxDistance: nativePannerNode.maxDistance,\n                    panningModel: nativePannerNode.panningModel,\n                    refDistance: nativePannerNode.refDistance,\n                    rolloffFactor: nativePannerNode.rolloffFactor\n                  }); // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext); // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n                  if ('bufferSize' in nativePannerNode) {\n                    nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                      gain: 1\n                    }));\n                  } else if (!nativePannerNodeIsOwnedByContext) {\n                    options = _objectSpread$6(_objectSpread$6({}, commonNativePannerNodeOptions), {}, {\n                      orientationX: nativePannerNode.orientationX.value,\n                      orientationY: nativePannerNode.orientationY.value,\n                      orientationZ: nativePannerNode.orientationZ.value,\n                      positionX: nativePannerNode.positionX.value,\n                      positionY: nativePannerNode.positionY.value,\n                      positionZ: nativePannerNode.positionZ.value\n                    });\n                    nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n                  if (!(nativeGainNode !== null)) {\n                    _context3.next = 31;\n                    break;\n                  }\n                  if (!(renderedBufferPromise === null)) {\n                    _context3.next = 15;\n                    break;\n                  }\n                  if (!(nativeOfflineAudioContextConstructor === null)) {\n                    _context3.next = 11;\n                    break;\n                  }\n                  throw new Error('Missing the native OfflineAudioContext constructor.');\n                case 11:\n                  partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6,\n                  // Bug #17: Safari does not yet expose the length.\n                  proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                  nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: 6\n                  });\n                  nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                  renderedBufferPromise = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                    var nativeConstantSourceNodes, i;\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.next = 2;\n                          return Promise.all([proxy.orientationX, proxy.orientationY, proxy.orientationZ, proxy.positionX, proxy.positionY, proxy.positionZ].map(/*#__PURE__*/function () {\n                            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(audioParam, index) {\n                              var nativeConstantSourceNode;\n                              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                                while (1) switch (_context.prev = _context.next) {\n                                  case 0:\n                                    nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                      channelCount: 1,\n                                      channelCountMode: 'explicit',\n                                      channelInterpretation: 'discrete',\n                                      offset: index === 0 ? 1 : 0\n                                    });\n                                    _context.next = 3;\n                                    return renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n                                  case 3:\n                                    return _context.abrupt(\"return\", nativeConstantSourceNode);\n                                  case 4:\n                                  case \"end\":\n                                    return _context.stop();\n                                }\n                              }, _callee);\n                            }));\n                            return function (_x3, _x4) {\n                              return _ref3.apply(this, arguments);\n                            };\n                          }()));\n                        case 2:\n                          nativeConstantSourceNodes = _context2.sent;\n                          for (i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                          }\n                          return _context2.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n                        case 5:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }, _callee2);\n                  }))();\n                case 15:\n                  _context3.next = 17;\n                  return renderedBufferPromise;\n                case 17:\n                  renderedBuffer = _context3.sent;\n                  inputGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                    gain: 1\n                  }));\n                  _context3.next = 21;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n                case 21:\n                  channelDatas = [];\n                  for (i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                  }\n                  lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                  lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                  gateGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                    gain: 1\n                  }));\n                  partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonNativePannerNodeOptions), {}, {\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                  }));\n                  inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                  partialPannerNode.connect(nativeGainNode);\n                  for (_i = 128; _i < renderedBuffer.length; _i += 128) {\n                    orientation = [channelDatas[0][_i], channelDatas[1][_i], channelDatas[2][_i]];\n                    positon = [channelDatas[3][_i], channelDatas[4][_i], channelDatas[5][_i]];\n                    if (orientation.some(function (value, index) {\n                      return value !== lastOrientation[index];\n                    }) || positon.some(function (value, index) {\n                      return value !== lastPosition[index];\n                    })) {\n                      lastOrientation = orientation;\n                      lastPosition = positon;\n                      currentTime = _i / nativeOfflineAudioContext.sampleRate;\n                      gateGainNode.gain.setValueAtTime(0, currentTime);\n                      gateGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                        gain: 0\n                      }));\n                      partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonNativePannerNodeOptions), {}, {\n                        orientationX: lastOrientation[0],\n                        orientationY: lastOrientation[1],\n                        orientationZ: lastOrientation[2],\n                        positionX: lastPosition[0],\n                        positionY: lastPosition[1],\n                        positionZ: lastPosition[2]\n                      }));\n                      gateGainNode.gain.setValueAtTime(1, currentTime);\n                      inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                      partialPannerNode.connect(nativeGainNode);\n                    }\n                  }\n                  return _context3.abrupt(\"return\", nativeGainNode);\n                case 31:\n                  if (nativePannerNodeIsOwnedByContext) {\n                    _context3.next = 46;\n                    break;\n                  }\n                  _context3.next = 34;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                case 34:\n                  _context3.next = 36;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                case 36:\n                  _context3.next = 38;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                case 38:\n                  _context3.next = 40;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                case 40:\n                  _context3.next = 42;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                case 42:\n                  _context3.next = 44;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n                case 44:\n                  _context3.next = 58;\n                  break;\n                case 46:\n                  _context3.next = 48;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                case 48:\n                  _context3.next = 50;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                case 50:\n                  _context3.next = 52;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                case 52:\n                  _context3.next = 54;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                case 54:\n                  _context3.next = 56;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                case 56:\n                  _context3.next = 58;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n                case 58:\n                  if (!isNativeAudioNodeFaker(nativePannerNode)) {\n                    _context3.next = 63;\n                    break;\n                  }\n                  _context3.next = 61;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n                case 61:\n                  _context3.next = 65;\n                  break;\n                case 63:\n                  _context3.next = 65;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n                case 65:\n                  return _context3.abrupt(\"return\", nativePannerNode);\n                case 66:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, _callee3);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n              return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var DEFAULT_OPTIONS$2 = {\n      disableNormalization: false\n    };\n    var createPeriodicWaveConstructor = function createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, periodicWaveStore, sanitizePeriodicWaveOptions) {\n      return /*#__PURE__*/function () {\n        function PeriodicWave(context, options) {\n          _classCallCheck(this, PeriodicWave);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = sanitizePeriodicWaveOptions(_objectSpread$5(_objectSpread$5({}, DEFAULT_OPTIONS$2), options));\n          var periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n          periodicWaveStore.add(periodicWave);\n          // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n          return periodicWave;\n        }\n        return _createClass(PeriodicWave, null, [{\n          key: Symbol.hasInstance,\n          value: function value(instance) {\n            return instance !== null && _typeof(instance) === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);\n          }\n        }]);\n      }();\n    };\n\n    var createRenderAutomation = function createRenderAutomation(getAudioParamRenderer, renderInputsOfAudioParam) {\n      return function (nativeOfflineAudioContext, audioParam, nativeAudioParam) {\n        var audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n      };\n    };\n\n    var createRenderInputsOfAudioNode = function createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) {\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioNode, nativeOfflineAudioContext, nativeAudioNode) {\n          var audioNodeConnections;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                audioNodeConnections = getAudioNodeConnections(audioNode);\n                _context2.next = 3;\n                return Promise.all(audioNodeConnections.activeInputs.map(function (connections, input) {\n                  return Array.from(connections).map(/*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n                      var _ref4, source, output, audioNodeRenderer, renderedNativeAudioNode, destination;\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) switch (_context.prev = _context.next) {\n                          case 0:\n                            _ref4 = _slicedToArray(_ref2, 2), source = _ref4[0], output = _ref4[1];\n                            audioNodeRenderer = getAudioNodeRenderer(source);\n                            _context.next = 4;\n                            return audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                          case 4:\n                            renderedNativeAudioNode = _context.sent;\n                            destination = audioNode.context.destination;\n                            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                              renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                            }\n                          case 7:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }, _callee);\n                    }));\n                    return function (_x4) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }());\n                }).reduce(function (allRenderingPromises, renderingPromises) {\n                  return [].concat(_toConsumableArray(allRenderingPromises), _toConsumableArray(renderingPromises));\n                }, []));\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n        return function (_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    };\n\n    var createRenderInputsOfAudioParam = function createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) {\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioParam, nativeOfflineAudioContext, nativeAudioParam) {\n          var audioParamConnections;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                audioParamConnections = getAudioParamConnections(audioParam);\n                _context2.next = 3;\n                return Promise.all(Array.from(audioParamConnections.activeInputs).map(/*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n                    var _ref4, source, output, audioNodeRenderer, renderedNativeAudioNode;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          _ref4 = _slicedToArray(_ref2, 2), source = _ref4[0], output = _ref4[1];\n                          audioNodeRenderer = getAudioNodeRenderer(source);\n                          _context.next = 4;\n                          return audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        case 4:\n                          renderedNativeAudioNode = _context.sent;\n                          if (!isPartOfACycle(source)) {\n                            renderedNativeAudioNode.connect(nativeAudioParam, output);\n                          }\n                        case 6:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee);\n                  }));\n                  return function (_x4) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n        return function (_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    };\n\n    var createRenderNativeOfflineAudioContext = function createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) {\n      return function (nativeOfflineAudioContext) {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, function () {\n          return testPromiseSupport(nativeOfflineAudioContext);\n        })) {\n          // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n          return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then(function (isOfflineAudioContextCurrentTimeSupported) {\n            if (!isOfflineAudioContextCurrentTimeSupported) {\n              var scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n              nativeOfflineAudioContext.oncomplete = function () {\n                scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                scriptProcessorNode.disconnect();\n              };\n              scriptProcessorNode.onaudioprocess = function () {\n                return nativeOfflineAudioContext.currentTime;\n              }; // tslint:disable-line:deprecation\n              scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n            }\n            return nativeOfflineAudioContext.startRendering();\n          });\n        }\n        return new Promise(function (resolve) {\n          // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n          var gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n          });\n          nativeOfflineAudioContext.oncomplete = function (event) {\n            gainNode.disconnect();\n            resolve(event.renderedBuffer);\n          };\n          gainNode.connect(nativeOfflineAudioContext.destination);\n          nativeOfflineAudioContext.startRendering();\n        });\n      };\n    };\n\n    var createSetActiveAudioWorkletNodeInputs = function createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore) {\n      return function (nativeAudioWorkletNode, activeInputs) {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n      };\n    };\n\n    var createSetAudioNodeTailTime = function createSetAudioNodeTailTime(audioNodeTailTimeStore) {\n      return function (audioNode, tailTime) {\n        return audioNodeTailTimeStore.set(audioNode, tailTime);\n      };\n    };\n\n    var createStartRendering = function createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n      return function (destination, nativeOfflineAudioContext) {\n        return getAudioNodeRenderer(destination).render(destination, nativeOfflineAudioContext)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */.then(function () {\n          return Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(function (audioWorkletNode) {\n            return getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext);\n          }));\n        }).then(function () {\n          return renderNativeOfflineAudioContext(nativeOfflineAudioContext);\n        }).then(function (audioBuffer) {\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n          } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n            return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n          })) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n          }\n          audioBufferStore.add(audioBuffer);\n          return audioBuffer;\n        });\n      };\n    };\n\n    function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$1 = {\n      channelCount: 2,\n      /*\n       * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n       * behavior.\n       */\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      pan: 0\n    };\n    var createStereoPannerNodeConstructor = function createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function StereoPannerNode(context, options) {\n          var _this;\n          _classCallCheck(this, StereoPannerNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$4(_objectSpread$4({}, DEFAULT_OPTIONS$1), options);\n          var nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer() : null;\n          _this = _callSuper$1(this, StereoPannerNode, [context, false, nativeStereoPannerNode, stereoPannerNodeRenderer]);\n          _this._pan = createAudioParam(_this, isOffline, nativeStereoPannerNode.pan);\n          return _this;\n        }\n        _inherits(StereoPannerNode, _audioNodeConstructor);\n        return _createClass(StereoPannerNode, [{\n          key: \"pan\",\n          get: function get() {\n            return this._pan;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createStereoPannerNodeRendererFactory = function createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeStereoPannerNodes = new WeakMap();\n        var createStereoPannerNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeStereoPannerNode, nativeStereoPannerNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeStereoPannerNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n                  if (!nativeStereoPannerNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeStereoPannerNode.channelCount,\n                      channelCountMode: nativeStereoPannerNode.channelCountMode,\n                      channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                      pan: nativeStereoPannerNode.pan.value\n                    };\n                    nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n                  if (nativeStereoPannerNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n                case 11:\n                  if (!isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                    _context.next = 16;\n                    break;\n                  }\n                  _context.next = 14;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n                case 14:\n                  _context.next = 18;\n                  break;\n                case 16:\n                  _context.next = 18;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n                case 18:\n                  return _context.abrupt(\"return\", nativeStereoPannerNode);\n                case 19:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createStereoPannerNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeStereoPannerNode !== undefined) {\n              return Promise.resolve(renderedNativeStereoPannerNode);\n            }\n            return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    // Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\n    var createTestAudioBufferConstructorSupport = function createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor) {\n      return function () {\n        if (nativeAudioBufferConstructor === null) {\n          return false;\n        }\n        try {\n          new nativeAudioBufferConstructor({\n            length: 1,\n            sampleRate: 44100\n          }); // tslint:disable-line:no-unused-expression\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    /*\n     * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n     * is enough to know if the other one is supported as well.\n     */\n    var createTestAudioBufferCopyChannelMethodsSubarraySupport = function createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100);\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        if (nativeAudioBuffer.copyToChannel === undefined) {\n          return true;\n        }\n        var source = new Float32Array(2);\n        try {\n          nativeAudioBuffer.copyFromChannel(source, 0, 0);\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    var createTestAudioContextCloseMethodSupport = function createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor) {\n      return function () {\n        if (nativeAudioContextConstructor === null) {\n          return false;\n        }\n        // Try to check the prototype before constructing the AudioContext.\n        if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {\n          return true;\n        }\n        var audioContext = new nativeAudioContextConstructor();\n        var isAudioContextClosable = audioContext.close !== undefined;\n        try {\n          audioContext.close();\n        } catch (_unused) {\n          // Ignore errors.\n        }\n        return isAudioContextClosable;\n      };\n    };\n\n    /**\n     * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n     * did not refuse to decode invalid parameters with a TypeError.\n     */\n    var createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = function createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return Promise.resolve(false);\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise(function (resolve) {\n          var isPending = true;\n          var resolvePromise = function resolvePromise(err) {\n            if (isPending) {\n              isPending = false;\n              offlineAudioContext.startRendering();\n              resolve(err instanceof TypeError);\n            }\n          };\n          var promise;\n          // Bug #26: Safari throws a synchronous error.\n          try {\n            promise = offlineAudioContext\n            // Bug #1: Safari requires a successCallback.\n            .decodeAudioData(null, function () {\n              // Ignore the success callback.\n            }, resolvePromise);\n          } catch (err) {\n            resolvePromise(err);\n          }\n          // Bug #21: Safari does not support promises yet.\n          if (promise !== undefined) {\n            // Bug #6: Chrome, Edge and Firefox do not call the errorCallback.\n            promise[\"catch\"](resolvePromise);\n          }\n        });\n      };\n    };\n\n    var createTestAudioContextOptionsSupport = function createTestAudioContextOptionsSupport(nativeAudioContextConstructor) {\n      return function () {\n        if (nativeAudioContextConstructor === null) {\n          return false;\n        }\n        var audioContext;\n        try {\n          audioContext = new nativeAudioContextConstructor({\n            latencyHint: 'balanced'\n          });\n        } catch (_unused) {\n          return false;\n        }\n        audioContext.close();\n        return true;\n      };\n    };\n\n    // Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\n    var createTestAudioNodeConnectMethodSupport = function createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeGainNode = nativeOfflineAudioContext.createGain();\n        var isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;\n        nativeGainNode.disconnect(nativeGainNode);\n        return isSupported;\n      };\n    };\n\n    /**\n     * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n     * enabled by default in version 66.\n     */\n    var createTestAudioWorkletProcessorNoOutputsSupport = function createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) {\n      return /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var blob, messageChannel, offlineAudioContext, url, isCallingProcess, audioWorkletNode, oscillator;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(nativeAudioWorkletNodeConstructor === null)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", true);\n            case 2:\n              if (!(nativeOfflineAudioContextConstructor === null)) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", false);\n            case 4:\n              blob = new Blob(['let c,p;class A extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=(e)=>{p=e.data;p.onmessage=()=>{p.postMessage(c);p.close()};this.port.postMessage(0)}}process(){c=1}}registerProcessor(\"a\",A)'], {\n                type: 'application/javascript; charset=utf-8'\n              });\n              messageChannel = new MessageChannel(); // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n              offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n              url = URL.createObjectURL(blob);\n              isCallingProcess = false;\n              _context.prev = 9;\n              _context.next = 12;\n              return offlineAudioContext.audioWorklet.addModule(url);\n            case 12:\n              audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {\n                numberOfOutputs: 0\n              });\n              oscillator = offlineAudioContext.createOscillator();\n              _context.next = 16;\n              return new Promise(function (resolve) {\n                audioWorkletNode.port.onmessage = function () {\n                  return resolve();\n                };\n                audioWorkletNode.port.postMessage(messageChannel.port2, [messageChannel.port2]);\n              });\n            case 16:\n              audioWorkletNode.port.onmessage = function () {\n                return isCallingProcess = true;\n              };\n              oscillator.connect(audioWorkletNode);\n              oscillator.start(0);\n              _context.next = 21;\n              return offlineAudioContext.startRendering();\n            case 21:\n              _context.next = 23;\n              return new Promise(function (resolve) {\n                messageChannel.port1.onmessage = function (_ref2) {\n                  var data = _ref2.data;\n                  return resolve(data === 1);\n                };\n                messageChannel.port1.postMessage(0);\n              });\n            case 23:\n              isCallingProcess = _context.sent;\n              _context.next = 28;\n              break;\n            case 26:\n              _context.prev = 26;\n              _context.t0 = _context[\"catch\"](9);\n            case 28:\n              _context.prev = 28;\n              messageChannel.port1.close();\n              URL.revokeObjectURL(url);\n              return _context.finish(28);\n            case 32:\n              return _context.abrupt(\"return\", isCallingProcess);\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[9, 26, 28, 32]]);\n      }));\n    };\n\n    // Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n    var createTestAudioWorkletProcessorPostMessageSupport = function createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) {\n      return /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var blob, offlineAudioContext, url, isEmittingMessageEvents, isEmittingProcessorErrorEvents, audioWorkletNode, oscillator;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(nativeAudioWorkletNodeConstructor === null)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", true);\n            case 2:\n              if (!(nativeOfflineAudioContextConstructor === null)) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", false);\n            case 4:\n              blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'], {\n                type: 'application/javascript; charset=utf-8'\n              }); // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n              offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n              url = URL.createObjectURL(blob);\n              isEmittingMessageEvents = false;\n              isEmittingProcessorErrorEvents = false;\n              _context.prev = 9;\n              _context.next = 12;\n              return offlineAudioContext.audioWorklet.addModule(url);\n            case 12:\n              audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {\n                numberOfOutputs: 0\n              });\n              oscillator = offlineAudioContext.createOscillator();\n              audioWorkletNode.port.onmessage = function () {\n                return isEmittingMessageEvents = true;\n              };\n              audioWorkletNode.onprocessorerror = function () {\n                return isEmittingProcessorErrorEvents = true;\n              };\n              oscillator.connect(audioWorkletNode);\n              oscillator.start(0);\n              _context.next = 20;\n              return offlineAudioContext.startRendering();\n            case 20:\n              _context.next = 22;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve);\n              });\n            case 22:\n              _context.next = 26;\n              break;\n            case 24:\n              _context.prev = 24;\n              _context.t0 = _context[\"catch\"](9);\n            case 26:\n              _context.prev = 26;\n              URL.revokeObjectURL(url);\n              return _context.finish(26);\n            case 29:\n              return _context.abrupt(\"return\", isEmittingMessageEvents && !isEmittingProcessorErrorEvents);\n            case 30:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[9, 24, 26, 29]]);\n      }));\n    };\n\n    /**\n     * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n     */\n    var createTestChannelMergerNodeChannelCountSupport = function createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeChannelMergerNode = offlineAudioContext.createChannelMerger();\n        /**\n         * Bug #15: Safari does not return the default properties. It still needs to be patched. This test is supposed to test the support\n         * in other browsers.\n         */\n        if (nativeChannelMergerNode.channelCountMode === 'max') {\n          return true;\n        }\n        try {\n          nativeChannelMergerNode.channelCount = 2;\n        } catch (_unused) {\n          return true;\n        }\n        return false;\n      };\n    };\n\n    var createTestConstantSourceNodeAccurateSchedulingSupport = function createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n          return true;\n        }\n        var nativeConstantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        /*\n         * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n         * the implementation of Firefox right now, but it could probably be done in a better way.\n         */\n        return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;\n      };\n    };\n\n    // Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\n    var createTestConvolverNodeBufferReassignabilitySupport = function createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeConvolverNode = offlineAudioContext.createConvolver();\n        nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        try {\n          nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    // Chrome up to version v80, Edge up to version v80 and Opera up to version v67 did not allow to set the channelCount property of a ConvolverNode to 1. They also did not allow to set the channelCountMode to 'explicit'.\n    var createTestConvolverNodeChannelCountSupport = function createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeConvolverNode = offlineAudioContext.createConvolver();\n        try {\n          nativeConvolverNode.channelCount = 1;\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    var createTestIsSecureContextSupport = function createTestIsSecureContextSupport(window) {\n      return function () {\n        return window !== null && window.hasOwnProperty('isSecureContext');\n      };\n    };\n\n    // Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\n    var createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = function createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor) {\n      return function () {\n        if (nativeAudioContextConstructor === null) {\n          return false;\n        }\n        var audioContext = new nativeAudioContextConstructor();\n        try {\n          audioContext.createMediaStreamSource(new MediaStream());\n          return false;\n        } catch (err) {\n          return true;\n        } finally {\n          audioContext.close();\n        }\n      };\n    };\n\n    var createTestOfflineAudioContextCurrentTimeSupport = function createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return Promise.resolve(false);\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        var gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise(function (resolve) {\n          nativeOfflineAudioContext.oncomplete = function () {\n            gainNode.disconnect();\n            resolve(nativeOfflineAudioContext.currentTime !== 0);\n          };\n          nativeOfflineAudioContext.startRendering();\n        });\n      };\n    };\n\n    /**\n     * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n     */\n    var createTestStereoPannerNodeDefaultValueSupport = function createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return Promise.resolve(false);\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        /*\n         * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n         * support the tested behaviour.\n         */\n        if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n          return Promise.resolve(true);\n        }\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n          return Promise.resolve(true);\n        }\n        var constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        var stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n        constantSourceNode.channelCount = 1;\n        constantSourceNode.offset.value = 1;\n        stereoPanner.channelCount = 1;\n        constantSourceNode.start();\n        constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);\n        return nativeOfflineAudioContext.startRendering().then(function (buffer) {\n          return buffer.getChannelData(0)[0] !== 1;\n        });\n      };\n    };\n\n    var createUnknownError = function createUnknownError() {\n      return new DOMException('', 'UnknownError');\n    };\n\n    function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      curve: null,\n      oversample: 'none'\n    };\n    var createWaveShaperNodeConstructor = function createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function WaveShaperNode(context, options) {\n          var _this;\n          _classCallCheck(this, WaveShaperNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$3(_objectSpread$3({}, DEFAULT_OPTIONS), options);\n          var nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer() : null;\n          // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n          _this = _callSuper(this, WaveShaperNode, [context, true, nativeWaveShaperNode, waveShaperNodeRenderer]);\n          _this._isCurveNullified = false;\n          _this._nativeWaveShaperNode = nativeWaveShaperNode;\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(WaveShaperNode, _audioNodeConstructor);\n        return _createClass(WaveShaperNode, [{\n          key: \"curve\",\n          get: function get() {\n            if (this._isCurveNullified) {\n              return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n          },\n          set: function set(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n              this._isCurveNullified = true;\n              this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n              // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n              // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n              if (value.length < 2) {\n                throw createInvalidStateError();\n              }\n              this._isCurveNullified = false;\n              this._nativeWaveShaperNode.curve = value;\n            }\n          }\n        }, {\n          key: \"oversample\",\n          get: function get() {\n            return this._nativeWaveShaperNode.oversample;\n          },\n          set: function set(value) {\n            this._nativeWaveShaperNode.oversample = value;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createWaveShaperNodeRendererFactory = function createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeWaveShaperNodes = new WeakMap();\n        var createWaveShaperNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeWaveShaperNode, nativeWaveShaperNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeWaveShaperNode = getNativeAudioNode(proxy); // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n                  if (!nativeWaveShaperNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeWaveShaperNode.channelCount,\n                      channelCountMode: nativeWaveShaperNode.channelCountMode,\n                      channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                      curve: nativeWaveShaperNode.curve,\n                      oversample: nativeWaveShaperNode.oversample\n                    };\n                    nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n                  if (!isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n                case 11:\n                  return _context.abrupt(\"return\", nativeWaveShaperNode);\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createWaveShaperNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeWaveShaperNode !== undefined) {\n              return Promise.resolve(renderedNativeWaveShaperNode);\n            }\n            return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createWindow = function createWindow() {\n      return typeof window === 'undefined' ? null : window;\n    };\n\n    var createWrapAudioBufferCopyChannelMethods = function createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError) {\n      return function (audioBuffer) {\n        audioBuffer.copyFromChannel = function (destination, channelNumberAsNumber) {\n          var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n          var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n          if (channelNumber >= audioBuffer.numberOfChannels) {\n            throw createIndexSizeError();\n          }\n          var audioBufferLength = audioBuffer.length;\n          var channelData = audioBuffer.getChannelData(channelNumber);\n          var destinationLength = destination.length;\n          for (var i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n            destination[i] = channelData[i + bufferOffset];\n          }\n        };\n        audioBuffer.copyToChannel = function (source, channelNumberAsNumber) {\n          var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n          var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n          if (channelNumber >= audioBuffer.numberOfChannels) {\n            throw createIndexSizeError();\n          }\n          var audioBufferLength = audioBuffer.length;\n          var channelData = audioBuffer.getChannelData(channelNumber);\n          var sourceLength = source.length;\n          for (var i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n            channelData[i + bufferOffset] = source[i];\n          }\n        };\n      };\n    };\n\n    var createWrapAudioBufferCopyChannelMethodsOutOfBounds = function createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong) {\n      return function (audioBuffer) {\n        audioBuffer.copyFromChannel = function (copyFromChannel) {\n          return function (destination, channelNumberAsNumber) {\n            var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (bufferOffset < audioBuffer.length) {\n              return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n            }\n          };\n        }(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = function (copyToChannel) {\n          return function (source, channelNumberAsNumber) {\n            var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (bufferOffset < audioBuffer.length) {\n              return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n            }\n          };\n        }(audioBuffer.copyToChannel);\n      };\n    };\n\n    var createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = function createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors) {\n      return function (nativeAudioBufferSourceNode, nativeContext) {\n        var nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n        if (nativeAudioBufferSourceNode.buffer === null) {\n          nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n        overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', function (get) {\n          return function () {\n            var value = get.call(nativeAudioBufferSourceNode);\n            return value === nullifiedBuffer ? null : value;\n          };\n        }, function (set) {\n          return function (value) {\n            return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n          };\n        });\n      };\n    };\n\n    var createWrapChannelMergerNode = function createWrapChannelMergerNode(createInvalidStateError, monitorConnections) {\n      return function (nativeContext, channelMergerNode) {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n          get: function get() {\n            return 1;\n          },\n          set: function set() {\n            throw createInvalidStateError();\n          }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n          get: function get() {\n            return 'explicit';\n          },\n          set: function set() {\n            throw createInvalidStateError();\n          }\n        });\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        var audioBufferSourceNode = nativeContext.createBufferSource();\n        var whenConnected = function whenConnected() {\n          var length = channelMergerNode.numberOfInputs;\n          for (var i = 0; i < length; i += 1) {\n            audioBufferSourceNode.connect(channelMergerNode, 0, i);\n          }\n        };\n        var whenDisconnected = function whenDisconnected() {\n          return audioBufferSourceNode.disconnect(channelMergerNode);\n        };\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n      };\n    };\n\n    var getFirstSample = function getFirstSample(audioBuffer, buffer, channelNumber) {\n      // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n      }\n      audioBuffer.copyFromChannel(buffer, channelNumber);\n      return buffer[0];\n    };\n\n    var isDCCurve = function isDCCurve(curve) {\n      if (curve === null) {\n        return false;\n      }\n      var length = curve.length;\n      if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n      }\n      return curve[length / 2 - 1] + curve[length / 2] !== 0;\n    };\n\n    var overwriteAccessors = function overwriteAccessors(object, property, createGetter, createSetter) {\n      var prototype = object;\n      while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n      }\n      var _Object$getOwnPropert = Object.getOwnPropertyDescriptor(prototype, property),\n        get = _Object$getOwnPropert.get,\n        set = _Object$getOwnPropert.set;\n      Object.defineProperty(object, property, {\n        get: createGetter(get),\n        set: createSetter(set)\n      });\n    };\n\n    function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var sanitizeAudioWorkletNodeOptions = function sanitizeAudioWorkletNodeOptions(options) {\n      return _objectSpread$2(_objectSpread$2({}, options), {}, {\n        outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n        /*\n         * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n         * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n         * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n         */\n        [options.channelCount] : Array.from({\n          length: options.numberOfOutputs\n        }, function () {\n          return 1;\n        })\n      });\n    };\n\n    function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var sanitizeChannelSplitterOptions = function sanitizeChannelSplitterOptions(options) {\n      return _objectSpread$1(_objectSpread$1({}, options), {}, {\n        channelCount: options.numberOfOutputs\n      });\n    };\n\n    function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var sanitizePeriodicWaveOptions = function sanitizePeriodicWaveOptions(options) {\n      var imag = options.imag,\n        real = options.real;\n      if (imag === undefined) {\n        if (real === undefined) {\n          return _objectSpread(_objectSpread({}, options), {}, {\n            imag: [0, 0],\n            real: [0, 0]\n          });\n        }\n        return _objectSpread(_objectSpread({}, options), {}, {\n          imag: Array.from(real, function () {\n            return 0;\n          }),\n          real: real\n        });\n      }\n      if (real === undefined) {\n        return _objectSpread(_objectSpread({}, options), {}, {\n          imag: imag,\n          real: Array.from(imag, function () {\n            return 0;\n          })\n        });\n      }\n      return _objectSpread(_objectSpread({}, options), {}, {\n        imag: imag,\n        real: real\n      });\n    };\n\n    var _setValueAtTimeUntilPossible = function setValueAtTimeUntilPossible(audioParam, value, startTime) {\n      try {\n        audioParam.setValueAtTime(value, startTime);\n      } catch (err) {\n        if (err.code !== 9) {\n          throw err;\n        }\n        _setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n      }\n    };\n\n    var testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = function testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      nativeAudioBufferSourceNode.start();\n      try {\n        nativeAudioBufferSourceNode.start();\n      } catch (_unused) {\n        return true;\n      }\n      return false;\n    };\n\n    var testAudioBufferSourceNodeStartMethodOffsetClampingSupport = function testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      var nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n      try {\n        nativeAudioBufferSourceNode.start(0, 1);\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    var testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = function testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      nativeAudioBufferSourceNode.start();\n      try {\n        nativeAudioBufferSourceNode.stop();\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    var testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = function testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createOscillator();\n      try {\n        nativeAudioBufferSourceNode.start(-1);\n      } catch (err) {\n        return err instanceof RangeError;\n      }\n      return false;\n    };\n\n    var testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = function testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext) {\n      var nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n      nativeAudioBufferSourceNode.start();\n      nativeAudioBufferSourceNode.stop();\n      try {\n        nativeAudioBufferSourceNode.stop();\n        return true;\n      } catch (_unused) {\n        return false;\n      }\n    };\n\n    var testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = function testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createOscillator();\n      try {\n        nativeAudioBufferSourceNode.stop(-1);\n      } catch (err) {\n        return err instanceof RangeError;\n      }\n      return false;\n    };\n\n    var testAudioWorkletNodeOptionsClonability = function testAudioWorkletNodeOptionsClonability(audioWorkletNodeOptions) {\n      var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1,\n        port2 = _MessageChannel.port2;\n      try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n      } finally {\n        port1.close();\n        port2.close();\n      }\n    };\n\n    /*\n     * Bug #122: Edge up to version v18 did not allow to construct a DOMException'. It also had a couple more bugs but since this is easy to\n     * test it's used here as a placeholder.\n     *\n     * Bug #27: Edge up to version v18 did reject an invalid arrayBuffer passed to decodeAudioData() with a DOMException.\n     *\n     * Bug #50: Edge up to version v18 did not allow to create AudioNodes on a closed context.\n     *\n     * Bug #57: Edge up to version v18 did not throw an error when assigning the type of an OscillatorNode to 'custom'.\n     *\n     * Bug #63: Edge up to version v18 did not expose the mediaElement property of a MediaElementAudioSourceNode.\n     *\n     * Bug #64: Edge up to version v18 did not support the MediaStreamAudioDestinationNode.\n     *\n     * Bug #71: Edge up to version v18 did not allow to set the buffer of an AudioBufferSourceNode to null.\n     *\n     * Bug #93: Edge up to version v18 did set the sampleRate of an AudioContext to zero when it was closed.\n     *\n     * Bug #101: Edge up to version v18 refused to execute decodeAudioData() on a closed context.\n     *\n     * Bug #106: Edge up to version v18 did not expose the maxValue and minValue properties of the pan AudioParam of a StereoPannerNode.\n     *\n     * Bug #110: Edge up to version v18 did not expose the maxValue and minValue properties of the attack, knee, ratio, release and threshold AudioParams of a DynamicsCompressorNode.\n     *\n     * Bug #123: Edge up to version v18 did not support HRTF as the panningModel for a PannerNode.\n     *\n     * Bug #145: Edge up to version v18 did throw an IndexSizeError when an OfflineAudioContext was created with a sampleRate of zero.\n     *\n     * Bug #161: Edge up to version v18 did not expose the maxValue and minValue properties of the delayTime AudioParam of a DelayNode.\n     */\n    var testDomExceptionConstructorSupport = function testDomExceptionConstructorSupport() {\n      try {\n        new DOMException(); // tslint:disable-line:no-unused-expression\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    // Safari at version 11 did not support transferables.\n    var testTransferablesSupport = function testTransferablesSupport() {\n      return new Promise(function (resolve) {\n        var arrayBuffer = new ArrayBuffer(0);\n        var _MessageChannel = new MessageChannel(),\n          port1 = _MessageChannel.port1,\n          port2 = _MessageChannel.port2;\n        port1.onmessage = function (_ref) {\n          var data = _ref.data;\n          return resolve(data !== null);\n        };\n        port2.postMessage(arrayBuffer, [arrayBuffer]);\n      });\n    };\n\n    var wrapAudioBufferSourceNodeStartMethodOffsetClamping = function wrapAudioBufferSourceNodeStartMethodOffsetClamping(nativeAudioBufferSourceNode) {\n      nativeAudioBufferSourceNode.start = function (start) {\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var duration = arguments.length > 2 ? arguments[2] : undefined;\n          var buffer = nativeAudioBufferSourceNode.buffer;\n          // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n          var clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n          // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n          if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n            start.call(nativeAudioBufferSourceNode, when, 0, 0);\n          } else {\n            start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n          }\n        };\n      }(nativeAudioBufferSourceNode.start);\n    };\n\n    var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioScheduledSourceNode, nativeContext) {\n      var nativeGainNode = nativeContext.createGain();\n      nativeAudioScheduledSourceNode.connect(nativeGainNode);\n      var disconnectGainNode = function (disconnect) {\n        return function () {\n          // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n          disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n          nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n      }(nativeAudioScheduledSourceNode.disconnect);\n      nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n      interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n      nativeAudioScheduledSourceNode.stop = function (stop) {\n        var isStopped = false;\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          if (isStopped) {\n            try {\n              stop.call(nativeAudioScheduledSourceNode, when);\n            } catch (_unused) {\n              nativeGainNode.gain.setValueAtTime(0, when);\n            }\n          } else {\n            stop.call(nativeAudioScheduledSourceNode, when);\n            isStopped = true;\n          }\n        };\n      }(nativeAudioScheduledSourceNode.stop);\n    };\n\n    var wrapEventListener = function wrapEventListener(target, eventListener) {\n      return function (event) {\n        var descriptor = {\n          value: target\n        };\n        Object.defineProperties(event, {\n          currentTarget: descriptor,\n          target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n          return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n      };\n    };\n\n    var addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\n    var addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\n    var deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\n    var audioNodeTailTimeStore = new WeakMap();\n    var getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\n    var cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\n    var window$1 = createWindow();\n    var createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\n    var getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\n    var renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\n    var createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var getNativeContext = createGetNativeContext(CONTEXT_STORE);\n    var nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window$1);\n    var isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\n    var audioParamAudioNodeStore = new WeakMap();\n    var eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\n    var nativeAudioContextConstructor = createNativeAudioContextConstructor(window$1);\n    var isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\n    var isNativeAudioNode = createIsNativeAudioNode(window$1);\n    var isNativeAudioParam = createIsNativeAudioParam(window$1);\n    var nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window$1);\n    var audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);\n    var analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\n    var audioBufferStore = new WeakSet();\n    var nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window$1);\n    var convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\n    var wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\n    var wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\n    var audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\n    var addSilentConnection = createAddSilentConnection(createNativeGainNode);\n    var renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\n    var connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\n    var createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\n    var renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\n    var createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, automationEvents.createCancelAndHoldAutomationEvent, automationEvents.createCancelScheduledValuesAutomationEvent, automationEvents.createExponentialRampToValueAutomationEvent, automationEvents.createLinearRampToValueAutomationEvent, automationEvents.createSetTargetAutomationEvent, automationEvents.createSetValueAutomationEvent, automationEvents.createSetValueCurveAutomationEvent, nativeAudioContextConstructor, _setValueAtTimeUntilPossible);\n    var audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\n    var audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\n    var createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\n    var biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\n    var wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\n    var createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\n    var createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\n    var createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);\n    var createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\n    var createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\n    var createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\n    var createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\n    var createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\n    var createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\n    var createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\n    var renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\n    var createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n    var createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\n    var iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);\n    var unrenderedAudioWorkletNodeStore = new WeakMap();\n    var minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\n    var createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\n    var createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\n    var createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\n    var createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);\n    var createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);\n    var createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);\n    var createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\n    var createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n    var pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\n    var periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet(), sanitizePeriodicWaveOptions);\n    var nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\n    var createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\n    var createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\n    var createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var isSecureContext = createIsSecureContext(window$1);\n    var exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window$1);\n    var backupOfflineAudioContextStore = new WeakMap();\n    var getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);\n    // The addAudioWorkletModule() function is only available in a SecureContext.\n    var addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window$1), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, new WeakMap(), new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n    // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n    window$1) : undefined;\n    var isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\n    var decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\n    var baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\n    var mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\n    var mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\n    var mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\n    var createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);\n    var mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\n    var audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\n    var getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\n    var addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\n    var connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\n    var deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\n    var disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\n    var activeAudioWorkletNodeInputsStore = new WeakMap();\n    var getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\n    var createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);\n    var createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\n    var createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n    var getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\n    var setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n    // The AudioWorkletNode constructor is only available in a SecureContext.\n    var audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) : undefined;\n    var minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\n    var createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\n    var startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\n    var minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\n    var offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\n    var isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\n    var isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\n    var isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\n    var isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\n    var isSupported = function isSupported() {\n      return createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor), testDomExceptionConstructorSupport, createTestIsSecureContextSupport(window$1), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n    };\n\n    exports.AnalyserNode = analyserNodeConstructor;\n    exports.AudioBuffer = audioBufferConstructor;\n    exports.AudioBufferSourceNode = audioBufferSourceNodeConstructor;\n    exports.AudioContext = audioContextConstructor;\n    exports.AudioWorkletNode = audioWorkletNodeConstructor;\n    exports.BiquadFilterNode = biquadFilterNodeConstructor;\n    exports.ChannelMergerNode = channelMergerNodeConstructor;\n    exports.ChannelSplitterNode = channelSplitterNodeConstructor;\n    exports.ConstantSourceNode = constantSourceNodeConstructor;\n    exports.ConvolverNode = convolverNodeConstructor;\n    exports.DelayNode = delayNodeConstructor;\n    exports.DynamicsCompressorNode = dynamicsCompressorNodeConstructor;\n    exports.GainNode = gainNodeConstructor;\n    exports.IIRFilterNode = iIRFilterNodeConstructor;\n    exports.MediaElementAudioSourceNode = mediaElementAudioSourceNodeConstructor;\n    exports.MediaStreamAudioDestinationNode = mediaStreamAudioDestinationNodeConstructor;\n    exports.MediaStreamAudioSourceNode = mediaStreamAudioSourceNodeConstructor;\n    exports.MediaStreamTrackAudioSourceNode = mediaStreamTrackAudioSourceNodeConstructor;\n    exports.MinimalAudioContext = minimalAudioContextConstructor;\n    exports.MinimalOfflineAudioContext = minimalOfflineAudioContextConstructor;\n    exports.OfflineAudioContext = offlineAudioContextConstructor;\n    exports.OscillatorNode = oscillatorNodeConstructor;\n    exports.PannerNode = pannerNodeConstructor;\n    exports.PeriodicWave = periodicWaveConstructor;\n    exports.StereoPannerNode = stereoPannerNodeConstructor;\n    exports.WaveShaperNode = waveShaperNodeConstructor;\n    exports.addAudioWorkletModule = addAudioWorkletModule;\n    exports.decodeAudioData = decodeAudioData;\n    exports.isAnyAudioContext = isAnyAudioContext;\n    exports.isAnyAudioNode = isAnyAudioNode;\n    exports.isAnyAudioParam = isAnyAudioParam;\n    exports.isAnyOfflineAudioContext = isAnyOfflineAudioContext;\n    exports.isSupported = isSupported;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhbmRhcmRpemVkLWF1ZGlvLWNvbnRleHQvYnVpbGQvZXM1L2J1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMsc0ZBQW1CLEdBQUcsbUJBQU8sQ0FBQywwR0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUFvQyxHQUFHLG1CQUFPLENBQUMsNEdBQXVDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBK0IsR0FBRyxtQkFBTyxDQUFDLDRHQUF1QyxHQUFHLG1CQUFPLENBQUMsa0lBQWtELEdBQUcsbUJBQU8sQ0FBQyw0R0FBdUMsR0FBRyxtQkFBTyxDQUFDLGdHQUFpQyxHQUFHLG1CQUFPLENBQUMsZ0hBQXlDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBNEIsR0FBRyxtQkFBTyxDQUFDLGtIQUEwQyxHQUFHLG1CQUFPLENBQUMsOEhBQWdEO0FBQ25zQixJQUFJLENBQzZiO0FBQ2pjLENBQUMsdVFBQXVROztBQUV4UTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0EsK0JBQStC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLCtCQUErQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUMxUCxrQ0FBa0MsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUN0YjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiLHFDQUFxQztBQUNyQyw2Q0FBNkMsTUFBTSxxRkFBcUYsTUFBTSxhQUFhLDZFQUE2RSxhQUFhO0FBQ3JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGFBQWE7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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aEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDMVAsa0NBQWtDLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsd0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDdGI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyw2QkFBNkI7QUFDNUk7QUFDQTtBQUNBLFNBQVM7QUFDVCxrR0FBa0csdUJBQXVCO0FBQ3pIO0FBQ0EsU0FBUztBQUNULHlHQUF5Ryw2QkFBNkI7QUFDdEk7QUFDQSxTQUFTO0FBQ1QseUdBQXlHLDZCQUE2QjtBQUN0STtBQUNBLFNBQVM7QUFDVCx5R0FBeUcsNkJBQTZCO0FBQ3RJO0FBQ0EsU0FBUztBQUNULHNHQUFzRyw2QkFBNkI7QUFDbkk7QUFDQSxTQUFTO0FBQ1Qsc0dBQXNHLDZCQUE2QjtBQUNuSTtBQUNBLFNBQVM7QUFDVCxzR0FBc0csNkJBQTZCO0FBQ25JO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUdBQXlHLDZCQUE2QjtBQUN0STtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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QUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNDQUFzQyxjQUFjLFFBQVEsMEJBQTBCLFNBQVMsaUJBQWlCLGlCQUFpQixXQUFXLDBCQUEwQixVQUFVLEtBQUs7QUFDN04sK0NBQStDO0FBQy9DLGVBQWU7QUFDZixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsV0FBVywyQ0FBMkM7QUFDNUgsK0NBQStDO0FBQy9DLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDMVAsa0NBQWtDLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsd0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDdGIsbUNBQW1DO0FBQ25DLDJDQUEyQyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsMkVBQTJFLGFBQWE7QUFDalA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwrREFBK0Q7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMERBQTBEO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsNkJBQTZCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3hQLGdDQUFnQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQ2hiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaXRjb2luLW11c2ljLy4vbm9kZV9tb2R1bGVzL3N0YW5kYXJkaXplZC1hdWRpby1jb250ZXh0L2J1aWxkL2VzNS9idW5kbGUuanM/M2U4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnYXV0b21hdGlvbi1ldmVudHMnKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5JyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZicpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXknKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdhdXRvbWF0aW9uLWV2ZW50cycsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXknLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YnLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cycsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InLCAnQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3InLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheScsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5zdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQgPSB7fSwgZ2xvYmFsLmF1dG9tYXRpb25FdmVudHMsIGdsb2JhbC5fc2xpY2VkVG9BcnJheSwgZ2xvYmFsLl9jcmVhdGVDbGFzcywgZ2xvYmFsLl9jbGFzc0NhbGxDaGVjaywgZ2xvYmFsLl90eXBlb2YsIGdsb2JhbC5fZGVmaW5lUHJvcGVydHksIGdsb2JhbC5fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZ2xvYmFsLl9nZXRQcm90b3R5cGVPZiwgZ2xvYmFsLl9pbmhlcml0cywgZ2xvYmFsLl9hc3luY1RvR2VuZXJhdG9yLCBnbG9iYWwuX3JlZ2VuZXJhdG9yUnVudGltZSwgZ2xvYmFsLl90b0NvbnN1bWFibGVBcnJheSwgZ2xvYmFsLl9vYmplY3RXaXRob3V0UHJvcGVydGllcykpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBhdXRvbWF0aW9uRXZlbnRzLCBfc2xpY2VkVG9BcnJheSwgX2NyZWF0ZUNsYXNzLCBfY2xhc3NDYWxsQ2hlY2ssIF90eXBlb2YsIF9kZWZpbmVQcm9wZXJ0eSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIF9nZXRQcm90b3R5cGVPZiwgX2luaGVyaXRzLCBfYXN5bmNUb0dlbmVyYXRvciwgX3JlZ2VuZXJhdG9yUnVudGltZSwgX3RvQ29uc3VtYWJsZUFycmF5LCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGNyZWF0ZUFib3J0RXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVBYm9ydEVycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdBYm9ydEVycm9yJyk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBZGRBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZUFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKGluc2VydEVsZW1lbnRJblNldCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3RpdmVJbnB1dHMsIHNvdXJjZSwgX3JlZiwgaWdub3JlRHVwbGljYXRlcykge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAzKSxcbiAgICAgICAgICBvdXRwdXQgPSBfcmVmMlswXSxcbiAgICAgICAgICBpbnB1dCA9IF9yZWYyWzFdLFxuICAgICAgICAgIGV2ZW50TGlzdGVuZXIgPSBfcmVmMlsyXTtcbiAgICAgICAgaW5zZXJ0RWxlbWVudEluU2V0KGFjdGl2ZUlucHV0c1tpbnB1dF0sIFtzb3VyY2UsIG91dHB1dCwgZXZlbnRMaXN0ZW5lcl0sIGZ1bmN0aW9uIChhY3RpdmVJbnB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlSW5wdXRDb25uZWN0aW9uWzBdID09PSBzb3VyY2UgJiYgYWN0aXZlSW5wdXRDb25uZWN0aW9uWzFdID09PSBvdXRwdXQ7XG4gICAgICAgIH0sIGlnbm9yZUR1cGxpY2F0ZXMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFkZEF1ZGlvTm9kZUNvbm5lY3Rpb25zID0gZnVuY3Rpb24gY3JlYXRlQWRkQXVkaW9Ob2RlQ29ubmVjdGlvbnMoYXVkaW9Ob2RlQ29ubmVjdGlvbnNTdG9yZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdWRpb05vZGUsIGF1ZGlvTm9kZVJlbmRlcmVyLCBuYXRpdmVBdWRpb05vZGUpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUlucHV0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdGl2ZUF1ZGlvTm9kZS5udW1iZXJPZklucHV0czsgaSArPSAxKSB7XG4gICAgICAgICAgYWN0aXZlSW5wdXRzLnB1c2gobmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICBhdWRpb05vZGVDb25uZWN0aW9uc1N0b3JlLnNldChhdWRpb05vZGUsIHtcbiAgICAgICAgICBhY3RpdmVJbnB1dHM6IGFjdGl2ZUlucHV0cyxcbiAgICAgICAgICBvdXRwdXRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgcGFzc2l2ZUlucHV0czogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICByZW5kZXJlcjogYXVkaW9Ob2RlUmVuZGVyZXJcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQWRkQXVkaW9QYXJhbUNvbm5lY3Rpb25zID0gZnVuY3Rpb24gY3JlYXRlQWRkQXVkaW9QYXJhbUNvbm5lY3Rpb25zKGF1ZGlvUGFyYW1Db25uZWN0aW9uc1N0b3JlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvUGFyYW0sIGF1ZGlvUGFyYW1SZW5kZXJlcikge1xuICAgICAgICBhdWRpb1BhcmFtQ29ubmVjdGlvbnNTdG9yZS5zZXQoYXVkaW9QYXJhbSwge1xuICAgICAgICAgIGFjdGl2ZUlucHV0czogbmV3IFNldCgpLFxuICAgICAgICAgIHBhc3NpdmVJbnB1dHM6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgICAgcmVuZGVyZXI6IGF1ZGlvUGFyYW1SZW5kZXJlclxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBBQ1RJVkVfQVVESU9fTk9ERV9TVE9SRSA9IG5ldyBXZWFrU2V0KCk7XG4gICAgdmFyIEFVRElPX05PREVfQ09OTkVDVElPTlNfU1RPUkUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBBVURJT19OT0RFX1NUT1JFID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgQVVESU9fUEFSQU1fQ09OTkVDVElPTlNfU1RPUkUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBBVURJT19QQVJBTV9TVE9SRSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIENPTlRFWFRfU1RPUkUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBFVkVOVF9MSVNURU5FUlMgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBDWUNMRV9DT1VOVEVSUyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLy8gVGhpcyBjbHVua3kgbmFtZSBpcyBib3Jyb3dlZCBmcm9tIHRoZSBzcGVjLiA6LSlcbiAgICB2YXIgTk9ERV9OQU1FX1RPX1BST0NFU1NPUl9DT05TVFJVQ1RPUl9NQVBTID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgTk9ERV9UT19QUk9DRVNTT1JfTUFQUyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpc0NvbnN0cnVjdGlibGUgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdGlibGUoY29uc3RydWN0aWJsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByb3h5ID0gbmV3IFByb3h5KGNvbnN0cnVjdGlibGUsIGhhbmRsZXIpO1xuICAgICAgICBuZXcgcHJveHkoKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGlzIG1hc3NpdmUgcmVnZXggdHJpZXMgdG8gY292ZXIgYWxsIHRoZSBmb2xsb3dpbmcgY2FzZXMuXG4gICAgICpcbiAgICAgKiBpbXBvcnQgJy4vcGF0aCc7XG4gICAgICogaW1wb3J0IGRlZmF1bHRJbXBvcnQgZnJvbSAnLi9wYXRoJztcbiAgICAgKiBpbXBvcnQgeyBuYW1lZEltcG9ydCB9IGZyb20gJy4vcGF0aCc7XG4gICAgICogaW1wb3J0IHsgbmFtZWRJbXBvcnQgYXMgcmVuYW1lbmRJbXBvcnQgfSBmcm9tICcuL3BhdGgnO1xuICAgICAqIGltcG9ydCAqIGFzIG5hbWVzcGFjZUltcG9ydCBmcm9tICcuL3BhdGgnO1xuICAgICAqIGltcG9ydCBkZWZhdWx0SW1wb3J0LCB7IG5hbWVkSW1wb3J0IH0gZnJvbSAnLi9wYXRoJztcbiAgICAgKiBpbXBvcnQgZGVmYXVsdEltcG9ydCwgeyBuYW1lZEltcG9ydCBhcyByZW5hbWVuZEltcG9ydCB9IGZyb20gJy4vcGF0aCc7XG4gICAgICogaW1wb3J0IGRlZmF1bHRJbXBvcnQsICogYXMgbmFtZXNwYWNlSW1wb3J0IGZyb20gJy4vcGF0aCc7XG4gICAgICovXG4gICAgdmFyIElNUE9SVF9TVEFURU1FTlRfUkVHRVggPSAvXmltcG9ydCg/Oig/OltcXHNdK1tcXHddK3woPzpbXFxzXStbXFx3XStbXFxzXSosKT9bXFxzXSpcXHtbXFxzXSpbXFx3XSsoPzpbXFxzXSthc1tcXHNdK1tcXHddKyk/KD86W1xcc10qLFtcXHNdKltcXHddKyg/OltcXHNdK2FzW1xcc10rW1xcd10rKT8pKltcXHNdKn18KD86W1xcc10rW1xcd10rW1xcc10qLCk/W1xcc10qXFwqW1xcc10rYXNbXFxzXStbXFx3XSspW1xcc10rZnJvbSk/KD86W1xcc10qKShcIihbXlwiXFxcXF18XFxcXC4pK1wifCcoW14nXFxcXF18XFxcXC4pKycpKD86W1xcc10qKTs/LzsgLy8gdHNsaW50OmRpc2FibGUtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICB2YXIgc3BsaXRJbXBvcnRTdGF0ZW1lbnRzID0gZnVuY3Rpb24gc3BsaXRJbXBvcnRTdGF0ZW1lbnRzKHNvdXJjZSwgdXJsKSB7XG4gICAgICB2YXIgaW1wb3J0U3RhdGVtZW50cyA9IFtdO1xuICAgICAgdmFyIHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzID0gc291cmNlLnJlcGxhY2UoL15bXFxzXSsvLCAnJyk7XG4gICAgICB2YXIgcmVzdWx0ID0gc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMubWF0Y2goSU1QT1JUX1NUQVRFTUVOVF9SRUdFWCk7XG4gICAgICB3aGlsZSAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB1bnJlc29sdmVkVXJsID0gcmVzdWx0WzFdLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgdmFyIGltcG9ydFN0YXRlbWVudFdpdGhSZXNvbHZlZFVybCA9IHJlc3VsdFswXS5yZXBsYWNlKC8oW1xcc10rKT87PyQvLCAnJykucmVwbGFjZSh1bnJlc29sdmVkVXJsLCBuZXcgVVJMKHVucmVzb2x2ZWRVcmwsIHVybCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGltcG9ydFN0YXRlbWVudHMucHVzaChpbXBvcnRTdGF0ZW1lbnRXaXRoUmVzb2x2ZWRVcmwpO1xuICAgICAgICBzb3VyY2VXaXRob3V0SW1wb3J0U3RhdGVtZW50cyA9IHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzLnNsaWNlKHJlc3VsdFswXS5sZW5ndGgpLnJlcGxhY2UoL15bXFxzXSsvLCAnJyk7XG4gICAgICAgIHJlc3VsdCA9IHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzLm1hdGNoKElNUE9SVF9TVEFURU1FTlRfUkVHRVgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtpbXBvcnRTdGF0ZW1lbnRzLmpvaW4oJzsnKSwgc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHNdO1xuICAgIH07XG5cbiAgICB2YXIgdmVyaWZ5UGFyYW1ldGVyRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiB2ZXJpZnlQYXJhbWV0ZXJEZXNjcmlwdG9ycyhwYXJhbWV0ZXJEZXNjcmlwdG9ycykge1xuICAgICAgaWYgKHBhcmFtZXRlckRlc2NyaXB0b3JzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyRGVzY3JpcHRvcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwYXJhbWV0ZXJEZXNjcmlwdG9ycyBwcm9wZXJ0eSBvZiBnaXZlbiB2YWx1ZSBmb3IgcHJvY2Vzc29yQ3RvciBpcyBub3QgYW4gYXJyYXkuJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdmVyaWZ5UHJvY2Vzc29yQ3RvciA9IGZ1bmN0aW9uIHZlcmlmeVByb2Nlc3NvckN0b3IocHJvY2Vzc29yQ3Rvcikge1xuICAgICAgaWYgKCFpc0NvbnN0cnVjdGlibGUocHJvY2Vzc29yQ3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGdpdmVuIHZhbHVlIGZvciBwcm9jZXNzb3JDdG9yIHNob3VsZCBiZSBhIGNvbnN0cnVjdG9yLicpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3NvckN0b3IucHJvdG90eXBlID09PSBudWxsIHx8IF90eXBlb2YocHJvY2Vzc29yQ3Rvci5wcm90b3R5cGUpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZ2l2ZW4gdmFsdWUgZm9yIHByb2Nlc3NvckN0b3Igc2hvdWxkIGhhdmUgYSBwcm90b3R5cGUuJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQWRkQXVkaW9Xb3JrbGV0TW9kdWxlID0gZnVuY3Rpb24gY3JlYXRlQWRkQXVkaW9Xb3JrbGV0TW9kdWxlKGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGV2YWx1YXRlU291cmNlLCBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZSwgZmV0Y2hTb3VyY2UsIGdldE5hdGl2ZUNvbnRleHQsIGdldE9yQ3JlYXRlQmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG9uZ29pbmdSZXF1ZXN0cywgcmVzb2x2ZWRSZXF1ZXN0cywgdGVzdEF1ZGlvV29ya2xldFByb2Nlc3NvclBvc3RNZXNzYWdlU3VwcG9ydCwgd2luZG93KSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBtb2R1bGVVUkwpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgICAgICBjcmVkZW50aWFsczogJ29taXQnXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNvbHZlZFJlcXVlc3RzT2ZDb250ZXh0ID0gcmVzb2x2ZWRSZXF1ZXN0cy5nZXQoY29udGV4dCk7XG4gICAgICAgIGlmIChyZXNvbHZlZFJlcXVlc3RzT2ZDb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgcmVzb2x2ZWRSZXF1ZXN0c09mQ29udGV4dC5oYXMobW9kdWxlVVJMKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb25nb2luZ1JlcXVlc3RzT2ZDb250ZXh0ID0gb25nb2luZ1JlcXVlc3RzLmdldChjb250ZXh0KTtcbiAgICAgICAgaWYgKG9uZ29pbmdSZXF1ZXN0c09mQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHByb21pc2VPZk9uZ29pbmdSZXF1ZXN0ID0gb25nb2luZ1JlcXVlc3RzT2ZDb250ZXh0LmdldChtb2R1bGVVUkwpO1xuICAgICAgICAgIGlmIChwcm9taXNlT2ZPbmdvaW5nUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZU9mT25nb2luZ1JlcXVlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgLy8gQnVnICM1OTogU2FmYXJpIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYXVkaW9Xb3JrbGV0IHByb3BlcnR5LlxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5hdGl2ZUNvbnRleHQuYXVkaW9Xb3JrbGV0ID09PSB1bmRlZmluZWQgPyBmZXRjaFNvdXJjZShtb2R1bGVVUkwpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIHNvdXJjZSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgYWJzb2x1dGVVcmwgPSBfcmVmMlsxXTtcbiAgICAgICAgICB2YXIgX3NwbGl0SW1wb3J0U3RhdGVtZW50ID0gc3BsaXRJbXBvcnRTdGF0ZW1lbnRzKHNvdXJjZSwgYWJzb2x1dGVVcmwpLFxuICAgICAgICAgICAgX3NwbGl0SW1wb3J0U3RhdGVtZW50MiA9IF9zbGljZWRUb0FycmF5KF9zcGxpdEltcG9ydFN0YXRlbWVudCwgMiksXG4gICAgICAgICAgICBpbXBvcnRTdGF0ZW1lbnRzID0gX3NwbGl0SW1wb3J0U3RhdGVtZW50MlswXSxcbiAgICAgICAgICAgIHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzID0gX3NwbGl0SW1wb3J0U3RhdGVtZW50MlsxXTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIFRoaXMgaXMgdGhlIHVubWluaWZpZWQgdmVyc2lvbiBvZiB0aGUgY29kZSB1c2VkIGJlbG93OlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogYGBganNcbiAgICAgICAgICAgKiAkeyBpbXBvcnRTdGF0ZW1lbnRzIH07XG4gICAgICAgICAgICogKChhLCBiKSA9PiB7XG4gICAgICAgICAgICogICAgIChhW2JdID0gYVtiXSB8fCBbIF0pLnB1c2goXG4gICAgICAgICAgICogICAgICAgICAoQXVkaW9Xb3JrbGV0UHJvY2Vzc29yLCBnbG9iYWwsIHJlZ2lzdGVyUHJvY2Vzc29yLCBzYW1wbGVSYXRlLCBzZWxmLCB3aW5kb3cpID0+IHtcbiAgICAgICAgICAgKiAgICAgICAgICAgICAkeyBzb3VyY2VXaXRob3V0SW1wb3J0U3RhdGVtZW50cyB9XG4gICAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAgICogICAgICk7XG4gICAgICAgICAgICogfSkod2luZG93LCAnX0FXR1MnKTtcbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgICAgdmFyIHdyYXBwZWRTb3VyY2UgPSBcIlwiLmNvbmNhdChpbXBvcnRTdGF0ZW1lbnRzLCBcIjsoKGEsYik9PnsoYVtiXT1hW2JdfHxbXSkucHVzaCgoQXVkaW9Xb3JrbGV0UHJvY2Vzc29yLGdsb2JhbCxyZWdpc3RlclByb2Nlc3NvcixzYW1wbGVSYXRlLHNlbGYsd2luZG93KT0+e1wiKS5jb25jYXQoc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMsIFwiXFxufSl9KSh3aW5kb3csJ19BV0dTJylcIik7XG4gICAgICAgICAgLy8gQHRvZG8gRXZhbHVhdGluZyB0aGUgZ2l2ZW4gc291cmNlIGNvZGUgaXMgYSBwb3NzaWJsZSBzZWN1cml0eSBwcm9ibGVtLlxuICAgICAgICAgIHJldHVybiBldmFsdWF0ZVNvdXJjZSh3cmFwcGVkU291cmNlKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGV2YWx1YXRlQXVkaW9Xb3JrbGV0R2xvYmFsU2NvcGUgPSB3aW5kb3cuX0FXR1MucG9wKCk7XG4gICAgICAgICAgaWYgKGV2YWx1YXRlQXVkaW9Xb3JrbGV0R2xvYmFsU2NvcGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQnVnICMxODIgQ2hyb21lIGFuZCBFZGdlIGRvIHRocm93IGFuIGluc3RhbmNlIG9mIGEgU3ludGF4RXJyb3IgaW5zdGVhZCBvZiBhIERPTUV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZShuYXRpdmVDb250ZXh0LmN1cnJlbnRUaW1lLCBuYXRpdmVDb250ZXh0LnNhbXBsZVJhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUF1ZGlvV29ya2xldEdsb2JhbFNjb3BlKC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gQXVkaW9Xb3JrbGV0UHJvY2Vzc29yKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yKTtcbiAgICAgICAgICAgIH0pLCB1bmRlZmluZWQsIGZ1bmN0aW9uIChuYW1lLCBwcm9jZXNzb3JDdG9yKSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBub2RlTmFtZVRvUHJvY2Vzc29yQ29uc3RydWN0b3JNYXAgPSBOT0RFX05BTUVfVE9fUFJPQ0VTU09SX0NPTlNUUlVDVE9SX01BUFMuZ2V0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgICAgICBpZiAobm9kZU5hbWVUb1Byb2Nlc3NvckNvbnN0cnVjdG9yTWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWVUb1Byb2Nlc3NvckNvbnN0cnVjdG9yTWFwLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmVyaWZ5UHJvY2Vzc29yQ3Rvcihwcm9jZXNzb3JDdG9yKTtcbiAgICAgICAgICAgICAgICB2ZXJpZnlQYXJhbWV0ZXJEZXNjcmlwdG9ycyhwcm9jZXNzb3JDdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzKTtcbiAgICAgICAgICAgICAgICBub2RlTmFtZVRvUHJvY2Vzc29yQ29uc3RydWN0b3JNYXAuc2V0KG5hbWUsIHByb2Nlc3NvckN0b3IpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcmlmeVByb2Nlc3NvckN0b3IocHJvY2Vzc29yQ3Rvcik7XG4gICAgICAgICAgICAgICAgdmVyaWZ5UGFyYW1ldGVyRGVzY3JpcHRvcnMocHJvY2Vzc29yQ3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyk7XG4gICAgICAgICAgICAgICAgTk9ERV9OQU1FX1RPX1BST0NFU1NPUl9DT05TVFJVQ1RPUl9NQVBTLnNldChuYXRpdmVDb250ZXh0LCBuZXcgTWFwKFtbbmFtZSwgcHJvY2Vzc29yQ3Rvcl1dKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG5hdGl2ZUNvbnRleHQuc2FtcGxlUmF0ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSA6IFByb21pc2UuYWxsKFtmZXRjaFNvdXJjZShtb2R1bGVVUkwpLCBQcm9taXNlLnJlc29sdmUoY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JQb3N0TWVzc2FnZVN1cHBvcnQsIHRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JQb3N0TWVzc2FnZVN1cHBvcnQpKV0pLnRoZW4oZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgX3JlZjQkID0gX3NsaWNlZFRvQXJyYXkoX3JlZjRbMF0sIDIpLFxuICAgICAgICAgICAgc291cmNlID0gX3JlZjQkWzBdLFxuICAgICAgICAgICAgYWJzb2x1dGVVcmwgPSBfcmVmNCRbMV0sXG4gICAgICAgICAgICBpc1N1cHBvcnRpbmdQb3N0TWVzc2FnZSA9IF9yZWY0WzFdO1xuICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgaW5kZXggPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgdmFyIF9zcGxpdEltcG9ydFN0YXRlbWVudDMgPSBzcGxpdEltcG9ydFN0YXRlbWVudHMoc291cmNlLCBhYnNvbHV0ZVVybCksXG4gICAgICAgICAgICBfc3BsaXRJbXBvcnRTdGF0ZW1lbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX3NwbGl0SW1wb3J0U3RhdGVtZW50MywgMiksXG4gICAgICAgICAgICBpbXBvcnRTdGF0ZW1lbnRzID0gX3NwbGl0SW1wb3J0U3RhdGVtZW50NFswXSxcbiAgICAgICAgICAgIHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzID0gX3NwbGl0SW1wb3J0U3RhdGVtZW50NFsxXTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEJ1ZyAjMTc5OiBGaXJlZm94IGRvZXMgbm90IGFsbG93IHRvIHRyYW5zZmVyIGFueSBidWZmZXIgd2hpY2ggaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSBwcm9jZXNzKCkgbWV0aG9kIGFzIGFuIGFyZ3VtZW50LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyB0aGUgdW5taW5pZmllZCB2ZXJzaW9uIG9mIHRoZSBjb2RlIHVzZWQgYmVsb3cuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgICAqIGNsYXNzIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yIHtcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICBfX2J1ZmZlcnMgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgICAgKiAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSA9ICgocG9zdE1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgKiAgICAgICAgICAgICByZXR1cm4gKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpID0+IHtcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUcmFuc2ZlcmFibGVzID0gKHRyYW5zZmVyYWJsZXMpXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICA/IHRyYW5zZmVyYWJsZXMuZmlsdGVyKCh0cmFuc2ZlcmFibGUpID0+ICF0aGlzLl9fYnVmZmVycy5oYXModHJhbnNmZXJhYmxlKSlcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgIDogdHJhbnNmZXJhYmxlcztcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICAgICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2UuY2FsbCh0aGlzLnBvcnQsIG1lc3NhZ2UsIGZpbHRlcmVkVHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICogICAgICAgICAgICAgIH07XG4gICAgICAgICAgICogICAgICAgICB9KSh0aGlzLnBvcnQucG9zdE1lc3NhZ2UpO1xuICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICogfVxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBwYXRjaGVkQXVkaW9Xb3JrbGV0UHJvY2Vzc29yID0gaXNTdXBwb3J0aW5nUG9zdE1lc3NhZ2UgPyAnQXVkaW9Xb3JrbGV0UHJvY2Vzc29yJyA6ICdjbGFzcyBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvciB7X19iPW5ldyBXZWFrU2V0KCk7Y29uc3RydWN0b3IoKXtzdXBlcigpOyhwPT5wLnBvc3RNZXNzYWdlPShxPT4obSx0KT0+cS5jYWxsKHAsbSx0P3QuZmlsdGVyKHU9PiF0aGlzLl9fYi5oYXModSkpOnQpKShwLnBvc3RNZXNzYWdlKSkodGhpcy5wb3J0KX19JztcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEJ1ZyAjMTcwOiBDaHJvbWUgYW5kIEVkZ2UgZG8gY2FsbCBwcm9jZXNzKCkgd2l0aCBhbiBhcnJheSB3aXRoIGVtcHR5IGNoYW5uZWxEYXRhIGZvciBlYWNoIGlucHV0IGlmIG5vIGlucHV0IGlzIGNvbm5lY3RlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEJ1ZyAjMTc5OiBGaXJlZm94IGRvZXMgbm90IGFsbG93IHRvIHRyYW5zZmVyIGFueSBidWZmZXIgd2hpY2ggaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSBwcm9jZXNzKCkgbWV0aG9kIGFzIGFuIGFyZ3VtZW50LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQnVnICMxOTA6IFNhZmFyaSBkb2Vzbid0IHRocm93IGFuIGVycm9yIHdoZW4gbG9hZGluZyBhbiB1bnBhcnNhYmxlIG1vZHVsZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgaXMgdGhlIHVubWluaWZpZWQgdmVyc2lvbiBvZiB0aGUgY29kZSB1c2VkIGJlbG93OlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogYGBganNcbiAgICAgICAgICAgKiBgJHsgaW1wb3J0U3RhdGVtZW50cyB9O1xuICAgICAgICAgICAqICgoQXVkaW9Xb3JrbGV0UHJvY2Vzc29yLCByZWdpc3RlclByb2Nlc3NvcikgPT4geyR7IHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzIH1cbiAgICAgICAgICAgKiB9KShcbiAgICAgICAgICAgKiAgICAgJHvCoHBhdGNoZWRBdWRpb1dvcmtsZXRQcm9jZXNzb3IgfSxcbiAgICAgICAgICAgKiAgICAgKG5hbWUsIHByb2Nlc3NvckN0b3IpID0+IHJlZ2lzdGVyUHJvY2Vzc29yKG5hbWUsIGNsYXNzIGV4dGVuZHMgcHJvY2Vzc29yQ3RvciB7XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICAgICAgIF9fY29sbGVjdEJ1ZmZlcnMgPSAoYXJyYXkpID0+IHtcbiAgICAgICAgICAgKiAgICAgICAgICAgICBhcnJheS5mb3JFYWNoKChlbGVtZW50KSA9PiB0aGlzLl9fYnVmZmVycy5hZGQoZWxlbWVudC5idWZmZXIpKTtcbiAgICAgICAgICAgKiAgICAgICAgIH07XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICAgICAgIHByb2Nlc3MgKGlucHV0cywgb3V0cHV0cywgcGFyYW1ldGVycykge1xuICAgICAgICAgICAqICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKHRoaXMuX19jb2xsZWN0QnVmZmVycyk7XG4gICAgICAgICAgICogICAgICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKHRoaXMuX19jb2xsZWN0QnVmZmVycyk7XG4gICAgICAgICAgICogICAgICAgICAgICAgdGhpcy5fX2NvbGxlY3RCdWZmZXJzKE9iamVjdC52YWx1ZXMocGFyYW1ldGVycykpO1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnByb2Nlc3MoXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgIChpbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuc29tZSgoY2hhbm5lbERhdGEpID0+IGNoYW5uZWxEYXRhLmxlbmd0aCA9PT0gMCkpID8gWyBdIDogaW5wdXQpLFxuICAgICAgICAgICAqICAgICAgICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAqICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXG4gICAgICAgICAgICogICAgICAgICAgICAgKTtcbiAgICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICB9KVxuICAgICAgICAgICAqICk7XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiByZWdpc3RlclByb2Nlc3NvcihgX19zYWMke2N1cnJlbnRJbmRleH1gLCBjbGFzcyBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvcntcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICBwcm9jZXNzICgpIHtcbiAgICAgICAgICAgKiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgKiAgICAgfVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogfSlgXG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIG1lbWJlckRlZmluaXRpb24gPSBpc1N1cHBvcnRpbmdQb3N0TWVzc2FnZSA/ICcnIDogJ19fYyA9IChhKSA9PiBhLmZvckVhY2goZT0+dGhpcy5fX2IuYWRkKGUuYnVmZmVyKSk7JztcbiAgICAgICAgICB2YXIgYnVmZmVyUmVnaXN0cmF0aW9uID0gaXNTdXBwb3J0aW5nUG9zdE1lc3NhZ2UgPyAnJyA6ICdpLmZvckVhY2godGhpcy5fX2MpO28uZm9yRWFjaCh0aGlzLl9fYyk7dGhpcy5fX2MoT2JqZWN0LnZhbHVlcyhwKSk7JztcbiAgICAgICAgICB2YXIgd3JhcHBlZFNvdXJjZSA9IFwiXCIuY29uY2F0KGltcG9ydFN0YXRlbWVudHMsIFwiOygoQXVkaW9Xb3JrbGV0UHJvY2Vzc29yLHJlZ2lzdGVyUHJvY2Vzc29yKT0+e1wiKS5jb25jYXQoc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMsIFwiXFxufSkoXCIpLmNvbmNhdChwYXRjaGVkQXVkaW9Xb3JrbGV0UHJvY2Vzc29yLCBcIiwobixwKT0+cmVnaXN0ZXJQcm9jZXNzb3IobixjbGFzcyBleHRlbmRzIHB7XCIpLmNvbmNhdChtZW1iZXJEZWZpbml0aW9uLCBcInByb2Nlc3MoaSxvLHApe1wiKS5jb25jYXQoYnVmZmVyUmVnaXN0cmF0aW9uLCBcInJldHVybiBzdXBlci5wcm9jZXNzKGkubWFwKGo9Pmouc29tZShrPT5rLmxlbmd0aD09PTApP1tdOmopLG8scCl9fSkpO3JlZ2lzdGVyUHJvY2Vzc29yKCdfX3NhY1wiKS5jb25jYXQoY3VycmVudEluZGV4LCBcIicsY2xhc3MgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7cHJvY2Vzcygpe3JldHVybiAhMX19KVwiKTtcbiAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFt3cmFwcGVkU291cmNlXSwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7IGNoYXJzZXQ9dXRmLTgnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUNvbnRleHQuYXVkaW9Xb3JrbGV0LmFkZE1vZHVsZSh1cmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjMTg2OiBDaHJvbWUgYW5kIEVkZ2UgZG8gbm90IGFsbG93IHRvIGNyZWF0ZSBhbiBBdWRpb1dvcmtsZXROb2RlIG9uIGEgY2xvc2VkIEF1ZGlvQ29udGV4dC5cbiAgICAgICAgICAgIHZhciBiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0ID0gZ2V0T3JDcmVhdGVCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQuYXVkaW9Xb3JrbGV0LmFkZE1vZHVsZSh1cmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHRPckJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBCdWcgIzE5MDogU2FmYXJpIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBsb2FkaW5nIGFuIHVucGFyc2FibGUgbW9kdWxlLlxuICAgICAgICAgICAgICBuZXcgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKG5hdGl2ZUNvbnRleHRPckJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQsIFwiX19zYWNcIi5jb25jYXQoY3VycmVudEluZGV4KSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25nb2luZ1JlcXVlc3RzT2ZDb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvbmdvaW5nUmVxdWVzdHMuc2V0KGNvbnRleHQsIG5ldyBNYXAoW1ttb2R1bGVVUkwsIHByb21pc2VdXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uZ29pbmdSZXF1ZXN0c09mQ29udGV4dC5zZXQobW9kdWxlVVJMLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB1cGRhdGVkUmVzb2x2ZWRSZXF1ZXN0c09mQ29udGV4dCA9IHJlc29sdmVkUmVxdWVzdHMuZ2V0KGNvbnRleHQpO1xuICAgICAgICAgIGlmICh1cGRhdGVkUmVzb2x2ZWRSZXF1ZXN0c09mQ29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZFJlcXVlc3RzLnNldChjb250ZXh0LCBuZXcgU2V0KFttb2R1bGVVUkxdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZWRSZXNvbHZlZFJlcXVlc3RzT2ZDb250ZXh0LmFkZChtb2R1bGVVUkwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdXBkYXRlZE9uZ29pbmdSZXF1ZXN0c09mQ29udGV4dCA9IG9uZ29pbmdSZXF1ZXN0cy5nZXQoY29udGV4dCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRPbmdvaW5nUmVxdWVzdHNPZkNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlZE9uZ29pbmdSZXF1ZXN0c09mQ29udGV4dFtcImRlbGV0ZVwiXShtb2R1bGVVUkwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFZhbHVlRm9yS2V5ID0gZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkobWFwLCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSB2YWx1ZSB3aXRoIHRoZSBnaXZlbiBrZXkgY291bGQgbm90IGJlIGZvdW5kLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgcGlja0VsZW1lbnRGcm9tU2V0ID0gZnVuY3Rpb24gcGlja0VsZW1lbnRGcm9tU2V0KHNldCwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdFbGVtZW50cyA9IEFycmF5LmZyb20oc2V0KS5maWx0ZXIocHJlZGljYXRlKTtcbiAgICAgIGlmIChtYXRjaGluZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ01vcmUgdGhhbiBvbmUgZWxlbWVudCB3YXMgZm91bmQuJyk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2hpbmdFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vIGVsZW1lbnQgd2FzIGZvdW5kLicpO1xuICAgICAgfVxuICAgICAgdmFyIF9tYXRjaGluZ0VsZW1lbnRzID0gX3NsaWNlZFRvQXJyYXkobWF0Y2hpbmdFbGVtZW50cywgMSksXG4gICAgICAgIG1hdGNoaW5nRWxlbWVudCA9IF9tYXRjaGluZ0VsZW1lbnRzWzBdO1xuICAgICAgc2V0W1wiZGVsZXRlXCJdKG1hdGNoaW5nRWxlbWVudCk7XG4gICAgICByZXR1cm4gbWF0Y2hpbmdFbGVtZW50O1xuICAgIH07XG5cbiAgICB2YXIgZGVsZXRlUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlID0gZnVuY3Rpb24gZGVsZXRlUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKHBhc3NpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0LCBpbnB1dCkge1xuICAgICAgdmFyIHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zID0gZ2V0VmFsdWVGb3JLZXkocGFzc2l2ZUlucHV0cywgc291cmNlKTtcbiAgICAgIHZhciBtYXRjaGluZ0Nvbm5lY3Rpb24gPSBwaWNrRWxlbWVudEZyb21TZXQocGFzc2l2ZUlucHV0Q29ubmVjdGlvbnMsIGZ1bmN0aW9uIChwYXNzaXZlSW5wdXRDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwYXNzaXZlSW5wdXRDb25uZWN0aW9uWzBdID09PSBvdXRwdXQgJiYgcGFzc2l2ZUlucHV0Q29ubmVjdGlvblsxXSA9PT0gaW5wdXQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXNzaXZlSW5wdXRDb25uZWN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgIHBhc3NpdmVJbnB1dHNbXCJkZWxldGVcIl0oc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGluZ0Nvbm5lY3Rpb247XG4gICAgfTtcblxuICAgIHZhciBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlID0gZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lcnNPZkF1ZGlvTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBnZXRWYWx1ZUZvcktleShFVkVOVF9MSVNURU5FUlMsIGF1ZGlvTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBzZXRJbnRlcm5hbFN0YXRlVG9BY3RpdmUgPSBmdW5jdGlvbiBzZXRJbnRlcm5hbFN0YXRlVG9BY3RpdmUoYXVkaW9Ob2RlKSB7XG4gICAgICBpZiAoQUNUSVZFX0FVRElPX05PREVfU1RPUkUuaGFzKGF1ZGlvTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQXVkaW9Ob2RlIGlzIGFscmVhZHkgc3RvcmVkLicpO1xuICAgICAgfVxuICAgICAgQUNUSVZFX0FVRElPX05PREVfU1RPUkUuYWRkKGF1ZGlvTm9kZSk7XG4gICAgICBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlKGF1ZGlvTm9kZSkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcih0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgaXNBdWRpb1dvcmtsZXROb2RlID0gZnVuY3Rpb24gaXNBdWRpb1dvcmtsZXROb2RlKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuICdwb3J0JyBpbiBhdWRpb05vZGU7XG4gICAgfTtcblxuICAgIHZhciBzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlID0gZnVuY3Rpb24gc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZShhdWRpb05vZGUpIHtcbiAgICAgIGlmICghQUNUSVZFX0FVRElPX05PREVfU1RPUkUuaGFzKGF1ZGlvTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQXVkaW9Ob2RlIGlzIG5vdCBzdG9yZWQuJyk7XG4gICAgICB9XG4gICAgICBBQ1RJVkVfQVVESU9fTk9ERV9TVE9SRVtcImRlbGV0ZVwiXShhdWRpb05vZGUpO1xuICAgICAgZ2V0RXZlbnRMaXN0ZW5lcnNPZkF1ZGlvTm9kZShhdWRpb05vZGUpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXIoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFNldCB0aGUgaW50ZXJuYWxTdGF0ZSBvZiB0aGUgYXVkaW9Ob2RlIHRvICdwYXNzaXZlJyBpZiBpdCBpcyBub3QgYW4gQXVkaW9Xb3JrbGV0Tm9kZSBhbmQgaWYgaXQgaGFzIG5vICdhY3RpdmUnIGlucHV0IGNvbm5lY3Rpb25zLlxuICAgIHZhciBzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlV2hlbk5lY2Vzc2FyeSA9IGZ1bmN0aW9uIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmVXaGVuTmVjZXNzYXJ5KGF1ZGlvTm9kZSwgYWN0aXZlSW5wdXRzKSB7XG4gICAgICBpZiAoIWlzQXVkaW9Xb3JrbGV0Tm9kZShhdWRpb05vZGUpICYmIGFjdGl2ZUlucHV0cy5ldmVyeShmdW5jdGlvbiAoY29ubmVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25zLnNpemUgPT09IDA7XG4gICAgICB9KSkge1xuICAgICAgICBzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKGF1ZGlvTm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBZGRDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBmdW5jdGlvbiBjcmVhdGVBZGRDb25uZWN0aW9uVG9BdWRpb05vZGUoYWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUsIGFkZFBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZSwgY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlLCBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZSwgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZUZyb21OYXRpdmVBdWRpb05vZGUsIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXRBdWRpb05vZGVUYWlsVGltZSwgZ2V0RXZlbnRMaXN0ZW5lcnNPZkF1ZGlvTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBpbnNlcnRFbGVtZW50SW5TZXQsIGlzQWN0aXZlQXVkaW9Ob2RlLCBpc1BhcnRPZkFDeWNsZSwgaXNQYXNzaXZlQXVkaW9Ob2RlKSB7XG4gICAgICB2YXIgdGFpbFRpbWVUaW1lb3V0SWRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlLCBkZXN0aW5hdGlvbiwgb3V0cHV0LCBpbnB1dCwgaXNPZmZsaW5lKSB7XG4gICAgICAgIHZhciBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhkZXN0aW5hdGlvbiksXG4gICAgICAgICAgYWN0aXZlSW5wdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpLmFjdGl2ZUlucHV0cyxcbiAgICAgICAgICBwYXNzaXZlSW5wdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpLnBhc3NpdmVJbnB1dHM7XG4gICAgICAgIHZhciBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkyID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoc291cmNlKSxcbiAgICAgICAgICBvdXRwdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpMi5vdXRwdXRzO1xuICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlKHNvdXJjZSk7XG4gICAgICAgIHZhciBldmVudExpc3RlbmVyID0gZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcihpc0FjdGl2ZSkge1xuICAgICAgICAgIHZhciBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgdmFyIG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShzb3VyY2UpO1xuICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxDb25uZWN0aW9uID0gZGVsZXRlUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKHBhc3NpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICAgICBhZGRBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShhY3RpdmVJbnB1dHMsIHNvdXJjZSwgcGFydGlhbENvbm5lY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghaXNPZmZsaW5lICYmICFpc1BhcnRPZkFDeWNsZShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgIGNvbm5lY3ROYXRpdmVBdWRpb05vZGVUb05hdGl2ZUF1ZGlvTm9kZShuYXRpdmVTb3VyY2VBdWRpb05vZGUsIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Bhc3NpdmVBdWRpb05vZGUoZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldEludGVybmFsU3RhdGVUb0FjdGl2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfcGFydGlhbENvbm5lY3Rpb24gPSBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShhY3RpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICAgICBhZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUocGFzc2l2ZUlucHV0cywgaW5wdXQsIF9wYXJ0aWFsQ29ubmVjdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFpc09mZmxpbmUgJiYgIWlzUGFydE9mQUN5Y2xlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZUZyb21OYXRpdmVBdWRpb05vZGUobmF0aXZlU291cmNlQXVkaW9Ob2RlLCBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSwgb3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFpbFRpbWUgPSBnZXRBdWRpb05vZGVUYWlsVGltZShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBpZiAodGFpbFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmVXaGVuTmVjZXNzYXJ5KGRlc3RpbmF0aW9uLCBhY3RpdmVJbnB1dHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdGFpbFRpbWVUaW1lb3V0SWQgPSB0YWlsVGltZVRpbWVvdXRJZHMuZ2V0KGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKHRhaWxUaW1lVGltZW91dElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGFpbFRpbWVUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhaWxUaW1lVGltZW91dElkcy5zZXQoZGVzdGluYXRpb24sIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZUF1ZGlvTm9kZShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmVXaGVuTmVjZXNzYXJ5KGRlc3RpbmF0aW9uLCBhY3RpdmVJbnB1dHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgdGFpbFRpbWUgKiAxMDAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5zZXJ0RWxlbWVudEluU2V0KG91dHB1dHMsIFtkZXN0aW5hdGlvbiwgb3V0cHV0LCBpbnB1dF0sIGZ1bmN0aW9uIChvdXRwdXRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dENvbm5lY3Rpb25bMF0gPT09IGRlc3RpbmF0aW9uICYmIG91dHB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dCAmJiBvdXRwdXRDb25uZWN0aW9uWzJdID09PSBpbnB1dDtcbiAgICAgICAgfSwgdHJ1ZSkpIHtcbiAgICAgICAgICBldmVudExpc3RlbmVycy5hZGQoZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKGFjdGl2ZUlucHV0cywgc291cmNlLCBbb3V0cHV0LCBpbnB1dCwgZXZlbnRMaXN0ZW5lcl0sIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUocGFzc2l2ZUlucHV0cywgaW5wdXQsIFtzb3VyY2UsIG91dHB1dCwgZXZlbnRMaXN0ZW5lcl0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlID0gZnVuY3Rpb24gY3JlYXRlQWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKGluc2VydEVsZW1lbnRJblNldCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXNzaXZlSW5wdXRzLCBpbnB1dCwgX3JlZiwgaWdub3JlRHVwbGljYXRlcykge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAzKSxcbiAgICAgICAgICBzb3VyY2UgPSBfcmVmMlswXSxcbiAgICAgICAgICBvdXRwdXQgPSBfcmVmMlsxXSxcbiAgICAgICAgICBldmVudExpc3RlbmVyID0gX3JlZjJbMl07XG4gICAgICAgIHZhciBwYXNzaXZlSW5wdXRDb25uZWN0aW9ucyA9IHBhc3NpdmVJbnB1dHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgIGlmIChwYXNzaXZlSW5wdXRDb25uZWN0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFzc2l2ZUlucHV0cy5zZXQoc291cmNlLCBuZXcgU2V0KFtbb3V0cHV0LCBpbnB1dCwgZXZlbnRMaXN0ZW5lcl1dKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0RWxlbWVudEluU2V0KHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zLCBbb3V0cHV0LCBpbnB1dCwgZXZlbnRMaXN0ZW5lcl0sIGZ1bmN0aW9uIChwYXNzaXZlSW5wdXRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFzc2l2ZUlucHV0Q29ubmVjdGlvblswXSA9PT0gb3V0cHV0ICYmIHBhc3NpdmVJbnB1dENvbm5lY3Rpb25bMV0gPT09IGlucHV0O1xuICAgICAgICAgIH0sIGlnbm9yZUR1cGxpY2F0ZXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQWRkU2lsZW50Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUFkZFNpbGVudENvbm5lY3Rpb24oY3JlYXRlTmF0aXZlR2Fpbk5vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlKSB7XG4gICAgICAgIHZhciBuYXRpdmVHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KTtcbiAgICAgICAgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLmNvbm5lY3QobmF0aXZlR2Fpbk5vZGUpLmNvbm5lY3QobmF0aXZlQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIHZhciBfZGlzY29ubmVjdCA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX2Rpc2Nvbm5lY3QpO1xuICAgICAgICAgIG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZS5kaXNjb25uZWN0KG5hdGl2ZUdhaW5Ob2RlKTtcbiAgICAgICAgICBuYXRpdmVHYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIF9kaXNjb25uZWN0KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBZGRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZUFkZFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlKGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2Rlcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBhdWRpb1dvcmtsZXROb2RlKSB7XG4gICAgICAgIGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlcyhuYXRpdmVDb250ZXh0KS5hZGQoYXVkaW9Xb3JrbGV0Tm9kZSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJHcoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkdyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJHcoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJHcoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJHIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRyKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRrID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ21heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBmZnRTaXplOiAyMDQ4LFxuICAgICAgbWF4RGVjaWJlbHM6IC0zMCxcbiAgICAgIG1pbkRlY2liZWxzOiAtMTAwLFxuICAgICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwLjhcbiAgICB9O1xuICAgIHZhciBjcmVhdGVBbmFseXNlck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUFuYWx5c2VyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvbk5vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQW5hbHlzZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBjcmVhdGVOYXRpdmVBbmFseXNlck5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvbk5vZGVDb25zdHJ1Y3RvKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuYWx5c2VyTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmFseXNlck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkdyhfb2JqZWN0U3ByZWFkJHcoe30sIERFRkFVTFRfT1BUSU9OUyRrKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUFuYWx5c2VyTm9kZSA9IGNyZWF0ZU5hdGl2ZUFuYWx5c2VyTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgYW5hbHlzZXJOb2RlUmVuZGVyZXIgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCkgPyBjcmVhdGVBbmFseXNlck5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkcih0aGlzLCBBbmFseXNlck5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlQW5hbHlzZXJOb2RlLCBhbmFseXNlck5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVBbmFseXNlck5vZGUgPSBuYXRpdmVBbmFseXNlck5vZGU7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhBbmFseXNlck5vZGUsIF9hdWRpb25Ob2RlQ29uc3RydWN0byk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQW5hbHlzZXJOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJmZnRTaXplXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLmZmdFNpemU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLmZmdFNpemUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZnJlcXVlbmN5QmluQ291bnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuZnJlcXVlbmN5QmluQ291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm1heERlY2liZWxzXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLm1heERlY2liZWxzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTE4OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgbWF4RGVjaWJlbHMgaXMgbm90IG1vcmUgdGhhbiBtaW5EZWNpYmVscy5cbiAgICAgICAgICAgIHZhciBtYXhEZWNpYmVscyA9IHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5tYXhEZWNpYmVscztcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5tYXhEZWNpYmVscyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCEodmFsdWUgPiB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUubWluRGVjaWJlbHMpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5tYXhEZWNpYmVscyA9IG1heERlY2liZWxzO1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJtaW5EZWNpYmVsc1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5taW5EZWNpYmVscztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzExODogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIGlmIG1heERlY2liZWxzIGlzIG5vdCBtb3JlIHRoYW4gbWluRGVjaWJlbHMuXG4gICAgICAgICAgICB2YXIgbWluRGVjaWJlbHMgPSB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUubWluRGVjaWJlbHM7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUubWluRGVjaWJlbHMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5tYXhEZWNpYmVscyA+IHZhbHVlKSkge1xuICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUubWluRGVjaWJlbHMgPSBtaW5EZWNpYmVscztcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW5kZXhTaXplRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic21vb3RoaW5nVGltZUNvbnN0YW50XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLnNtb290aGluZ1RpbWVDb25zdGFudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldEJ5dGVGcmVxdWVuY3lEYXRhXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJ5dGVGcmVxdWVuY3lEYXRhKGFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoYXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJnZXRCeXRlVGltZURvbWFpbkRhdGFcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKGFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKGFycmF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZ2V0RmxvYXRGcmVxdWVuY3lEYXRhXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZsb2F0RnJlcXVlbmN5RGF0YShhcnJheSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLmdldEZsb2F0RnJlcXVlbmN5RGF0YShhcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldEZsb2F0VGltZURvbWFpbkRhdGFcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmxvYXRUaW1lRG9tYWluRGF0YShhcnJheSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLmdldEZsb2F0VGltZURvbWFpbkRhdGEoYXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb25Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgaXNPd25lZEJ5Q29udGV4dCA9IGZ1bmN0aW9uIGlzT3duZWRCeUNvbnRleHQobmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVDb250ZXh0KSB7XG4gICAgICByZXR1cm4gbmF0aXZlQXVkaW9Ob2RlLmNvbnRleHQgPT09IG5hdGl2ZUNvbnRleHQ7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBbmFseXNlck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVBbmFseXNlck5vZGVSZW5kZXJlckZhY3RvcnkoY3JlYXRlTmF0aXZlQW5hbHlzZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBbmFseXNlck5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGNyZWF0ZUFuYWx5c2VyTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVBbmFseXNlck5vZGUsIG5hdGl2ZUFuYWx5c2VyTm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQW5hbHlzZXJOb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTsgLy8gSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZUFuYWx5c2VyTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUFuYWx5c2VyTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZUFuYWx5c2VyTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZUFuYWx5c2VyTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZUFuYWx5c2VyTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlQW5hbHlzZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVBbmFseXNlck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGZmdFNpemU6IG5hdGl2ZUFuYWx5c2VyTm9kZS5mZnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgIG1heERlY2liZWxzOiBuYXRpdmVBbmFseXNlck5vZGUubWF4RGVjaWJlbHMsXG4gICAgICAgICAgICAgICAgICAgICAgbWluRGVjaWJlbHM6IG5hdGl2ZUFuYWx5c2VyTm9kZS5taW5EZWNpYmVscyxcbiAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IG5hdGl2ZUFuYWx5c2VyTm9kZS5zbW9vdGhpbmdUaW1lQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQW5hbHlzZXJOb2RlID0gY3JlYXRlTmF0aXZlQW5hbHlzZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBbmFseXNlck5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBbmFseXNlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUFuYWx5c2VyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVBbmFseXNlck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFuYWx5c2VyTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQW5hbHlzZXJOb2RlID0gcmVuZGVyZWROYXRpdmVBbmFseXNlck5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUFuYWx5c2VyTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVBbmFseXNlck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFuYWx5c2VyTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydCA9IGZ1bmN0aW9uIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydChuYXRpdmVBdWRpb0J1ZmZlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXIuY29weVRvQ2hhbm5lbChuZXcgRmxvYXQzMkFycmF5KDEpLCAwLCAtMSk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSW5kZXhTaXplRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVJbmRleFNpemVFcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnSW5kZXhTaXplRXJyb3InKTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBBdWRpb0J1ZmZlckdldENoYW5uZWxEYXRhTWV0aG9kID0gZnVuY3Rpb24gd3JhcEF1ZGlvQnVmZmVyR2V0Q2hhbm5lbERhdGFNZXRob2QoYXVkaW9CdWZmZXIpIHtcbiAgICAgIGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhID0gZnVuY3Rpb24gKGdldENoYW5uZWxEYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbERhdGEuY2FsbChhdWRpb0J1ZmZlciwgY2hhbm5lbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDEyKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfShhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkdihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCR2KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkdihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkdihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkaiA9IHtcbiAgICAgIG51bWJlck9mQ2hhbm5lbHM6IDFcbiAgICB9O1xuICAgIHZhciBjcmVhdGVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9CdWZmZXJDb25zdHJ1Y3RvcihhdWRpb0J1ZmZlclN0b3JlLCBjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBuYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHRlc3ROYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yU3VwcG9ydCwgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzLCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcykge1xuICAgICAgdmFyIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvQnVmZmVyKG9wdGlvbnMpIHtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9CdWZmZXIpO1xuICAgICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgbmF0aXZlIE9mZmxpbmVBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfREVGQVVMVF9PUFRJT05TJG9wdGkgPSBfb2JqZWN0U3ByZWFkJHYoX29iamVjdFNwcmVhZCR2KHt9LCBERUZBVUxUX09QVElPTlMkaiksIG9wdGlvbnMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gX0RFRkFVTFRfT1BUSU9OUyRvcHRpLmxlbmd0aCxcbiAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSBfREVGQVVMVF9PUFRJT05TJG9wdGkubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgIHNhbXBsZVJhdGUgPSBfREVGQVVMVF9PUFRJT05TJG9wdGkuc2FtcGxlUmF0ZTtcbiAgICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEJ1ZyAjOTk6IEZpcmVmb3ggZG9lcyBub3QgdGhyb3cgYSBOb3RTdXBwb3J0ZWRFcnJvciB3aGVuIHRoZSBudW1iZXJPZkNoYW5uZWxzIGlzIHplcm8uIEJ1dCBpdCBvbmx5IGRvZXMgaXQgd2hlbiB1c2luZyB0aGVcbiAgICAgICAgICAgKiBmYWN0b3J5IGZ1bmN0aW9uLiBCdXQgc2luY2UgRmlyZWZveCBhbHNvIHN1cHBvcnRzIHRoZSBjb25zdHJ1Y3RvciBldmVyeXRoaW5nIHNob3VsZCBiZSBmaW5lLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBhdWRpb0J1ZmZlciA9IG5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IgIT09IG51bGwgJiYgY2FjaGVUZXN0UmVzdWx0KHRlc3ROYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yU3VwcG9ydCwgdGVzdE5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3JTdXBwb3J0KSA/IG5ldyBuYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVsczogbnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGVcbiAgICAgICAgICB9KSA6IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKG51bWJlck9mQ2hhbm5lbHMsIGxlbmd0aCwgc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgLy8gQnVnICM5OTogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW4gdGhlIG51bWJlck9mQ2hhbm5lbHMgaXMgemVyby5cbiAgICAgICAgICBpZiAoYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICM1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjb3B5RnJvbUNoYW5uZWwoKSBhbmQgY29weVRvQ2hhbm5lbCgpLlxuICAgICAgICAgIC8vIEJ1ZyAjMTAwOiBTYWZhcmkgZG9lcyB0aHJvdyBhIHdyb25nIGVycm9yIHdoZW4gY2FsbGluZyBnZXRDaGFubmVsRGF0YSgpIHdpdGggYW4gb3V0LW9mLWJvdW5kcyB2YWx1ZS5cbiAgICAgICAgICBpZiAodHlwZW9mIGF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlckdldENoYW5uZWxEYXRhTWV0aG9kKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTU3OiBGaXJlZm94IGRvZXMgbm90IGFsbG93IHRoZSBidWZmZXJPZmZzZXQgdG8gYmUgb3V0LW9mLWJvdW5kcy5cbiAgICAgICAgICB9IGVsc2UgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0KGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdWRpb0J1ZmZlclN0b3JlLmFkZChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBUaGlzIGRvZXMgdmlvbGF0ZSBhbGwgZ29vZCBwcmF0aWNlcyBidXQgaXQgaXMgbmVjZXNzYXJ5IHRvIGFsbG93IHRoaXMgQXVkaW9CdWZmZXIgdG8gYmUgdXNlZCB3aXRoIG5hdGl2ZVxuICAgICAgICAgICAqIChPZmZsaW5lKUF1ZGlvQ29udGV4dHMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQXVkaW9CdWZmZXIsIG51bGwsIFt7XG4gICAgICAgICAga2V5OiBTeW1ib2wuaGFzSW5zdGFuY2UsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UgIT09IG51bGwgJiYgX3R5cGVvZihpbnN0YW5jZSkgPT09ICdvYmplY3QnICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSkgPT09IEF1ZGlvQnVmZmVyLnByb3RvdHlwZSB8fCBhdWRpb0J1ZmZlclN0b3JlLmhhcyhpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KCk7XG4gICAgfTtcblxuICAgIHZhciBNT1NUX05FR0FUSVZFX1NJTkdMRV9GTE9BVCA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4gICAgdmFyIE1PU1RfUE9TSVRJVkVfU0lOR0xFX0ZMT0FUID0gLU1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUO1xuXG4gICAgdmFyIGlzQWN0aXZlQXVkaW9Ob2RlID0gZnVuY3Rpb24gaXNBY3RpdmVBdWRpb05vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gQUNUSVZFX0FVRElPX05PREVfU1RPUkUuaGFzKGF1ZGlvTm9kZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkdShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCR1KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkdShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkdShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkcSh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHEoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJGkgPSB7XG4gICAgICBidWZmZXI6IG51bGwsXG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIC8vIEJ1ZyAjMTQ5OiBTYWZhcmkgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIGRldHVuZSBBdWRpb1BhcmFtLlxuICAgICAgbG9vcDogZmFsc2UsXG4gICAgICBsb29wRW5kOiAwLFxuICAgICAgbG9vcFN0YXJ0OiAwLFxuICAgICAgcGxheWJhY2tSYXRlOiAxXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXIsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgd3JhcEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJHUoX29iamVjdFNwcmVhZCR1KHt9LCBERUZBVUxUX09QVElPTlMkaSksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgYXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkcSh0aGlzLCBBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBhdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIF90aGlzLl9hdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlciA9IGF1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyO1xuICAgICAgICAgIF90aGlzLl9pc0J1ZmZlck51bGxpZmllZCA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLl9pc0J1ZmZlclNldCA9IG1lcmdlZE9wdGlvbnMuYnVmZmVyICE9PSBudWxsO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XG4gICAgICAgICAgX3RoaXMuX29uZW5kZWQgPSBudWxsO1xuICAgICAgICAgIC8vIEJ1ZyAjNzM6IFNhZmFyaSBkb2VzIG5vdCBleHBvcnQgdGhlIGNvcnJlY3QgdmFsdWVzIGZvciBtYXhWYWx1ZSBhbmQgbWluVmFsdWUuXG4gICAgICAgICAgX3RoaXMuX3BsYXliYWNrUmF0ZSA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnBsYXliYWNrUmF0ZSwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKEF1ZGlvQnVmZmVyU291cmNlTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImJ1ZmZlclwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQnVmZmVyTnVsbGlmaWVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5idWZmZXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmJ1ZmZlciA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gQnVnICM3MjogT25seSBDaHJvbWUgJiBFZGdlIGRvIG5vdCBhbGxvdyB0byByZWFzc2lnbiB0aGUgYnVmZmVyIHlldC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faXNCdWZmZXJTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2lzQnVmZmVyU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibG9vcFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImxvb3BFbmRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUubG9vcEVuZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUubG9vcEVuZCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJsb29wU3RhcnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUubG9vcFN0YXJ0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wU3RhcnQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib25lbmRlZFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZW5kZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWRMaXN0ZW5lciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBFdmVudExpc3RlbmVyKHRoaXMsIHZhbHVlKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUub25lbmRlZCA9IHdyYXBwZWRMaXN0ZW5lcjtcbiAgICAgICAgICAgIHZhciBuYXRpdmVPbkVuZGVkID0gdGhpcy5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLm9uZW5kZWQ7XG4gICAgICAgICAgICB0aGlzLl9vbmVuZGVkID0gbmF0aXZlT25FbmRlZCAhPT0gbnVsbCAmJiBuYXRpdmVPbkVuZGVkID09PSB3cmFwcGVkTGlzdGVuZXIgPyB2YWx1ZSA6IG5hdGl2ZU9uRW5kZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInBsYXliYWNrUmF0ZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgIHZhciB3aGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KHdoZW4sIG9mZnNldCwgZHVyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyLnN0YXJ0ID0gZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IFt3aGVuLCBvZmZzZXRdIDogW3doZW4sIG9mZnNldCwgZHVyYXRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvQWN0aXZlKHRoaXMpO1xuICAgICAgICAgICAgICB2YXIgX3Jlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSA9IGZ1bmN0aW9uIHJlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIF9yZXNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZUF1ZGlvTm9kZShfdGhpczIpKSB7XG4gICAgICAgICAgICAgICAgICBzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKF90aGlzMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBfcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCh3aGVuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlci5zdG9wID0gd2hlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgICAgICB2YXIgc3RvcCA9IG51bGw7XG4gICAgICAgIHZhciBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zLCBfbmF0aXZlQXVkaW9CdWZmZXJTb3U7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTtcbiAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgKiBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTQ5OiBTYWZhcmkgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIGRldHVuZSBBdWRpb1BhcmFtLlxuICAgICAgICAgICAgICAgICAgICAgIGxvb3A6IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wLFxuICAgICAgICAgICAgICAgICAgICAgIGxvb3BFbmQ6IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wRW5kLFxuICAgICAgICAgICAgICAgICAgICAgIGxvb3BTdGFydDogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmxvb3BTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBwbGF5YmFja1JhdGU6IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5wbGF5YmFja1JhdGUudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAoX25hdGl2ZUF1ZGlvQnVmZmVyU291ID0gbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKS5zdGFydC5hcHBseShfbmF0aXZlQXVkaW9CdWZmZXJTb3UsIF90b0NvbnN1bWFibGVBcnJheShzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0b3Aoc3RvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucGxheWJhY2tSYXRlLCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUucGxheWJhY2tSYXRlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucGxheWJhY2tSYXRlLCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUucGxheWJhY2tSYXRlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZXQgc3RhcnQodmFsdWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgc3RvcCh2YWx1ZSkge1xuICAgICAgICAgICAgc3RvcCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IHJlbmRlcmVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpc0F1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGZ1bmN0aW9uIGlzQXVkaW9CdWZmZXJTb3VyY2VOb2RlKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuICdwbGF5YmFja1JhdGUnIGluIGF1ZGlvTm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQmlxdWFkRmlsdGVyTm9kZSA9IGZ1bmN0aW9uIGlzQmlxdWFkRmlsdGVyTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiAnZnJlcXVlbmN5JyBpbiBhdWRpb05vZGUgJiYgJ2dhaW4nIGluIGF1ZGlvTm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQ29uc3RhbnRTb3VyY2VOb2RlID0gZnVuY3Rpb24gaXNDb25zdGFudFNvdXJjZU5vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gJ29mZnNldCcgaW4gYXVkaW9Ob2RlO1xuICAgIH07XG5cbiAgICB2YXIgaXNHYWluTm9kZSA9IGZ1bmN0aW9uIGlzR2Fpbk5vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gISgnZnJlcXVlbmN5JyBpbiBhdWRpb05vZGUpICYmICdnYWluJyBpbiBhdWRpb05vZGU7XG4gICAgfTtcblxuICAgIHZhciBpc09zY2lsbGF0b3JOb2RlID0gZnVuY3Rpb24gaXNPc2NpbGxhdG9yTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiAnZGV0dW5lJyBpbiBhdWRpb05vZGUgJiYgJ2ZyZXF1ZW5jeScgaW4gYXVkaW9Ob2RlICYmICEoJ2dhaW4nIGluIGF1ZGlvTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBpc1N0ZXJlb1Bhbm5lck5vZGUgPSBmdW5jdGlvbiBpc1N0ZXJlb1Bhbm5lck5vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gJ3BhbicgaW4gYXVkaW9Ob2RlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBnZXRWYWx1ZUZvcktleShBVURJT19OT0RFX0NPTk5FQ1RJT05TX1NUT1JFLCBhdWRpb05vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zID0gZnVuY3Rpb24gZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zKGF1ZGlvUGFyYW0pIHtcbiAgICAgIHJldHVybiBnZXRWYWx1ZUZvcktleShBVURJT19QQVJBTV9DT05ORUNUSU9OU19TVE9SRSwgYXVkaW9QYXJhbSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGIociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRiKHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGIociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JGIociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JGIociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JGIociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciBfZGVhY3RpdmF0ZUFjdGl2ZUF1ZGlvTm9kZUlucHV0Q29ubmVjdGlvbnMgPSBmdW5jdGlvbiBkZWFjdGl2YXRlQWN0aXZlQXVkaW9Ob2RlSW5wdXRDb25uZWN0aW9ucyhhdWRpb05vZGUsIHRyYWNlKSB7XG4gICAgICB2YXIgX2dldEF1ZGlvTm9kZUNvbm5lY3RpID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoYXVkaW9Ob2RlKSxcbiAgICAgICAgYWN0aXZlSW5wdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpLmFjdGl2ZUlucHV0cztcbiAgICAgIGFjdGl2ZUlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25uZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgICAgc291cmNlID0gX3JlZjJbMF07XG4gICAgICAgICAgaWYgKCF0cmFjZS5pbmNsdWRlcyhhdWRpb05vZGUpKSB7XG4gICAgICAgICAgICBfZGVhY3RpdmF0ZUFjdGl2ZUF1ZGlvTm9kZUlucHV0Q29ubmVjdGlvbnMoc291cmNlLCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRyYWNlKSwgW2F1ZGlvTm9kZV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgYXVkaW9QYXJhbXMgPSBpc0F1ZGlvQnVmZmVyU291cmNlTm9kZShhdWRpb05vZGUpID8gW1xuICAgICAgLy8gQnVnICMxNDk6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgZGV0dW5lIEF1ZGlvUGFyYW0uXG4gICAgICBhdWRpb05vZGUucGxheWJhY2tSYXRlXSA6IGlzQXVkaW9Xb3JrbGV0Tm9kZShhdWRpb05vZGUpID8gQXJyYXkuZnJvbShhdWRpb05vZGUucGFyYW1ldGVycy52YWx1ZXMoKSkgOiBpc0JpcXVhZEZpbHRlck5vZGUoYXVkaW9Ob2RlKSA/IFthdWRpb05vZGUuUSwgYXVkaW9Ob2RlLmRldHVuZSwgYXVkaW9Ob2RlLmZyZXF1ZW5jeSwgYXVkaW9Ob2RlLmdhaW5dIDogaXNDb25zdGFudFNvdXJjZU5vZGUoYXVkaW9Ob2RlKSA/IFthdWRpb05vZGUub2Zmc2V0XSA6IGlzR2Fpbk5vZGUoYXVkaW9Ob2RlKSA/IFthdWRpb05vZGUuZ2Fpbl0gOiBpc09zY2lsbGF0b3JOb2RlKGF1ZGlvTm9kZSkgPyBbYXVkaW9Ob2RlLmRldHVuZSwgYXVkaW9Ob2RlLmZyZXF1ZW5jeV0gOiBpc1N0ZXJlb1Bhbm5lck5vZGUoYXVkaW9Ob2RlKSA/IFthdWRpb05vZGUucGFuXSA6IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGIoYXVkaW9QYXJhbXMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGF1ZGlvUGFyYW0gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgYXVkaW9QYXJhbUNvbm5lY3Rpb25zID0gZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zKGF1ZGlvUGFyYW0pO1xuICAgICAgICAgIGlmIChhdWRpb1BhcmFtQ29ubmVjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXVkaW9QYXJhbUNvbm5lY3Rpb25zLmFjdGl2ZUlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICAgICAgICAgICAgc291cmNlID0gX3JlZjRbMF07XG4gICAgICAgICAgICAgIHJldHVybiBfZGVhY3RpdmF0ZUFjdGl2ZUF1ZGlvTm9kZUlucHV0Q29ubmVjdGlvbnMoc291cmNlLCB0cmFjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FjdGl2ZUF1ZGlvTm9kZShhdWRpb05vZGUpKSB7XG4gICAgICAgIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUoYXVkaW9Ob2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlYWN0aXZhdGVBdWRpb0dyYXBoID0gZnVuY3Rpb24gZGVhY3RpdmF0ZUF1ZGlvR3JhcGgoY29udGV4dCkge1xuICAgICAgX2RlYWN0aXZhdGVBY3RpdmVBdWRpb05vZGVJbnB1dENvbm5lY3Rpb25zKGNvbnRleHQuZGVzdGluYXRpb24sIFtdKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzVmFsaWRMYXRlbmN5SGludCA9IGZ1bmN0aW9uIGlzVmFsaWRMYXRlbmN5SGludChsYXRlbmN5SGludCkge1xuICAgICAgcmV0dXJuIGxhdGVuY3lIaW50ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGxhdGVuY3lIaW50ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbGF0ZW5jeUhpbnQgPT09ICdzdHJpbmcnICYmIChsYXRlbmN5SGludCA9PT0gJ2JhbGFuY2VkJyB8fCBsYXRlbmN5SGludCA9PT0gJ2ludGVyYWN0aXZlJyB8fCBsYXRlbmN5SGludCA9PT0gJ3BsYXliYWNrJyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkcCh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHAoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgY3JlYXRlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihiYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgY3JlYXRlVW5rbm93bkVycm9yLCBtZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciwgbWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yLCBtZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yLCBtZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IsIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYmFzZUF1ZGlvQ29udGV4dENvbnMpIHtcbiAgICAgICAgZnVuY3Rpb24gQXVkaW9Db250ZXh0KCkge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIG5hdGl2ZSBBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYXRpdmVBdWRpb0NvbnRleHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTkyIFNhZmFyaSBkb2VzIHRocm93IGEgU3ludGF4RXJyb3IgaWYgdGhlIHNhbXBsZVJhdGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMTIgJiYgZXJyLm1lc3NhZ2UgPT09ICdzYW1wbGVSYXRlIGlzIG5vdCBpbiByYW5nZScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICMxMzEgU2FmYXJpIHJldHVybnMgbnVsbCB3aGVuIHRoZXJlIGFyZSBmb3VyIG90aGVyIEF1ZGlvQ29udGV4dHMgcnVubmluZyBhbHJlYWR5LlxuICAgICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVVua25vd25FcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCdWcgIzUxIE9ubHkgQ2hyb21lIGFuZCBFZGdlIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiBsYXRlbmN5SGludCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmICghaXNWYWxpZExhdGVuY3lIaW50KG9wdGlvbnMubGF0ZW5jeUhpbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHByb3ZpZGVkIHZhbHVlICdcIi5jb25jYXQob3B0aW9ucy5sYXRlbmN5SGludCwgXCInIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBBdWRpb0NvbnRleHRMYXRlbmN5Q2F0ZWdvcnkuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICMxNTAgU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyB0aGUgc2FtcGxlUmF0ZS5cbiAgICAgICAgICBpZiAob3B0aW9ucy5zYW1wbGVSYXRlICE9PSB1bmRlZmluZWQgJiYgbmF0aXZlQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgIT09IG9wdGlvbnMuc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJHAodGhpcywgQXVkaW9Db250ZXh0LCBbbmF0aXZlQXVkaW9Db250ZXh0LCAyXSk7XG4gICAgICAgICAgdmFyIGxhdGVuY3lIaW50ID0gb3B0aW9ucy5sYXRlbmN5SGludDtcbiAgICAgICAgICB2YXIgX25hdGl2ZUF1ZGlvQ29udGV4dCA9IG5hdGl2ZUF1ZGlvQ29udGV4dCxcbiAgICAgICAgICAgIHNhbXBsZVJhdGUgPSBfbmF0aXZlQXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgLy8gQHRvZG8gVGhlIHZhbHVlcyBmb3IgJ2JhbGFuY2VkJywgJ2ludGVyYWN0aXZlJyBhbmQgJ3BsYXliYWNrJyBhcmUganVzdCBjb3BpZWQgZnJvbSBDaHJvbWUncyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBfdGhpcy5fYmFzZUxhdGVuY3kgPSB0eXBlb2YgbmF0aXZlQXVkaW9Db250ZXh0LmJhc2VMYXRlbmN5ID09PSAnbnVtYmVyJyA/IG5hdGl2ZUF1ZGlvQ29udGV4dC5iYXNlTGF0ZW5jeSA6IGxhdGVuY3lIaW50ID09PSAnYmFsYW5jZWQnID8gNTEyIC8gc2FtcGxlUmF0ZSA6IGxhdGVuY3lIaW50ID09PSAnaW50ZXJhY3RpdmUnIHx8IGxhdGVuY3lIaW50ID09PSB1bmRlZmluZWQgPyAyNTYgLyBzYW1wbGVSYXRlIDogbGF0ZW5jeUhpbnQgPT09ICdwbGF5YmFjaycgPyAxMDI0IC8gc2FtcGxlUmF0ZSA6XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBAdG9kbyBUaGUgbWluICgyNTYpIGFuZCBtYXggKDE2Mzg0KSB2YWx1ZXMgYXJlIHRha2VuIGZyb20gdGhlIGFsbG93ZWQgYnVmZmVyU2l6ZSB2YWx1ZXMgb2YgYVxuICAgICAgICAgICAqIFNjcmlwdFByb2Nlc3Nvck5vZGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgTWF0aC5tYXgoMiwgTWF0aC5taW4oMTI4LCBNYXRoLnJvdW5kKGxhdGVuY3lIaW50ICogc2FtcGxlUmF0ZSAvIDEyOCkpKSAqIDEyOCAvIHNhbXBsZVJhdGU7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUF1ZGlvQ29udGV4dCA9IG5hdGl2ZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgICAvLyBCdWcgIzE4ODogU2FmYXJpIHdpbGwgc2V0IHRoZSBjb250ZXh0J3Mgc3RhdGUgdG8gJ2ludGVycnVwdGVkJyBpbiBjYXNlIHRoZSB1c2VyIHN3aXRjaGVzIHRhYnMuXG4gICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLm5hbWUgPT09ICd3ZWJraXRBdWRpb0NvbnRleHQnKSB7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlR2Fpbk5vZGUgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVHYWluTm9kZS5nYWluLnZhbHVlID0gMWUtMzc7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUuY29ubmVjdChfdGhpcy5fbmF0aXZlR2Fpbk5vZGUpLmNvbm5lY3QobmF0aXZlQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5zdGFydCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlR2Fpbk5vZGUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEJ1ZyAjMzQ6IENocm9tZSBhbmQgRWRnZSBwcmV0ZW5kIHRvIGJlIHJ1bm5pbmcgcmlnaHQgYXdheSwgYnV0IGZpcmUgYW4gb25zdGF0ZWNoYW5nZSBldmVudCB3aGVuIHRoZSBzdGF0ZSBhY3R1YWxseSBjaGFuZ2VzXG4gICAgICAgICAgICogdG8gJ3J1bm5pbmcnLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHQuc3RhdGUgPT09ICdydW5uaW5nJykge1xuICAgICAgICAgICAgX3RoaXMuX3N0YXRlID0gJ3N1c3BlbmRlZCc7XG4gICAgICAgICAgICB2YXIgX3Jldm9rZVN0YXRlID0gZnVuY3Rpb24gcmV2b2tlU3RhdGUoKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuYXRpdmVBdWRpb0NvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBfcmV2b2tlU3RhdGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQ29udGV4dC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIF9yZXZva2VTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQXVkaW9Db250ZXh0LCBfYmFzZUF1ZGlvQ29udGV4dENvbnMpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF1ZGlvQ29udGV4dCwgW3tcbiAgICAgICAgICBrZXk6IFwiYmFzZUxhdGVuY3lcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXNlTGF0ZW5jeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhdGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSAhPT0gbnVsbCA/IHRoaXMuX3N0YXRlIDogdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LnN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQnVnICMzNTogRmlyZWZveCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgQXVkaW9Db250ZXh0IHdhcyBjbG9zZWQgYmVmb3JlLlxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0NvbnRleHQuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjMzQ6IElmIHRoZSBzdGF0ZSB3YXMgc2V0IHRvIHN1c3BlbmRlZCBiZWZvcmUgaXQgc2hvdWxkIGJlIHJldm9rZWQgbm93LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIuX25hdGl2ZUdhaW5Ob2RlICE9PSBudWxsICYmIF90aGlzMi5fbmF0aXZlT3NjaWxsYXRvck5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZUdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWFjdGl2YXRlQXVkaW9HcmFwaChfdGhpczIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKHRoaXMsIHtcbiAgICAgICAgICAgICAgbWVkaWFFbGVtZW50OiBtZWRpYUVsZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3Rvcih0aGlzLCB7XG4gICAgICAgICAgICAgIG1lZGlhU3RyZWFtOiBtZWRpYVN0cmVhbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZU1lZGlhU3RyZWFtVHJhY2tTb3VyY2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTWVkaWFTdHJlYW1UcmFja1NvdXJjZShtZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3Rvcih0aGlzLCB7XG4gICAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IG1lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZXN1bWVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLl9uYXRpdmVBdWRpb0NvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBfcmVzb2x2ZVByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMy5fbmF0aXZlQXVkaW9Db250ZXh0LnN0YXRlID09PSAncnVubmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzLnJlc3VtZSgpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzMy5fbmF0aXZlQXVkaW9Db250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgX3Jlc29sdmVQcm9taXNlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LnJlc3VtZSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAvLyBCdWcgIzU1OiBDaHJvbWUgYW5kIEVkZ2UgZG8gdGhyb3cgYW4gSW52YWxpZEFjY2Vzc0Vycm9yIGluc3RlYWQgb2YgYW4gSW52YWxpZFN0YXRlRXJyb3IuXG4gICAgICAgICAgICAgIC8vIEJ1ZyAjNTY6IFNhZmFyaSBpbnZva2VzIHRoZSBjYXRjaCBoYW5kbGVyIGJ1dCB3aXRob3V0IGFuIGVycm9yLlxuICAgICAgICAgICAgICBpZiAoZXJyID09PSB1bmRlZmluZWQgfHwgZXJyLmNvZGUgPT09IDE1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3VzcGVuZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdXNwZW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQ29udGV4dC5zdXNwZW5kKClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjNTY6IFNhZmFyaSBpbnZva2VzIHRoZSBjYXRjaCBoYW5kbGVyIGJ1dCB3aXRob3V0IGFuIGVycm9yLlxuICAgICAgICAgICAgICBpZiAoZXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShiYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJG8odCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRvKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8gPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIGNyZWF0ZUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb0Rlc3RpbmF0aW9uTm9kZVJlbmRlcmVyLCBjcmVhdGVJbmRleFNpemVFcnJvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gQXVkaW9EZXN0aW5hdGlvbk5vZGUoY29udGV4dCwgY2hhbm5lbENvdW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb0Rlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlID0gY3JlYXRlTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUobmF0aXZlQ29udGV4dCwgY2hhbm5lbENvdW50LCBpc09mZmxpbmUpO1xuICAgICAgICAgIHZhciBhdWRpb0Rlc3RpbmF0aW9uTm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGVSZW5kZXJlcihyZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRvKHRoaXMsIEF1ZGlvRGVzdGluYXRpb25Ob2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBhdWRpb0Rlc3RpbmF0aW9uTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgX3RoaXMuX2lzTm9kZU9mTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGlzT2ZmbGluZTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKEF1ZGlvRGVzdGluYXRpb25Ob2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF1ZGlvRGVzdGluYXRpb25Ob2RlLCBbe1xuICAgICAgICAgIGtleTogXCJjaGFubmVsQ291bnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQnVnICM1MjogQ2hyb21lLCBFZGdlICYgU2FmYXJpIGRvIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gYXQgYWxsLlxuICAgICAgICAgICAgLy8gQnVnICM1NDogRmlyZWZveCBkb2VzIHRocm93IGFuIEluZGV4U2l6ZUVycm9yLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTm9kZU9mTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVnICM0NzogVGhlIEF1ZGlvRGVzdGluYXRpb25Ob2RlIGluIFNhZmFyaSBkb2VzIG5vdCBpbml0aWFsaXplIHRoZSBtYXhDaGFubmVsQ291bnQgcHJvcGVydHkgY29ycmVjdGx5LlxuICAgICAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5fbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUubWF4Q2hhbm5lbENvdW50KSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY2hhbm5lbENvdW50TW9kZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQnVnICM1MzogTm8gYnJvd3NlciBkb2VzIHRocm93IGFuIGV4Y2VwdGlvbiB5ZXQuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNOb2RlT2ZOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm1heENoYW5uZWxDb3VudFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLm1heENoYW5uZWxDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGVSZW5kZXJlciA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvRGVzdGluYXRpb25Ob2RlUmVuZGVyZXIocmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICB2YXIgY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgIHZhciBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZTtcbiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlKTtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGUoX3gsIF94Mikge1xuICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlID0gcmVuZGVyZWROYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjcmVhdGVBdWRpb0Rlc3RpbmF0aW9uTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBdWRpb0xpc3RlbmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvTGlzdGVuZXJGYWN0b3J5KGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBnZXRGaXJzdFNhbXBsZSwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBvdmVyd3JpdGVBY2Nlc3NvcnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgbmF0aXZlQ29udGV4dCkge1xuICAgICAgICB2YXIgbmF0aXZlTGlzdGVuZXIgPSBuYXRpdmVDb250ZXh0Lmxpc3RlbmVyO1xuICAgICAgICAvLyBCdWcgIzExNzogT25seSBDaHJvbWUgJiBFZGdlIHN1cHBvcnQgdGhlIG5ldyBpbnRlcmZhY2UgYWxyZWFkeS5cbiAgICAgICAgdmFyIGNyZWF0ZUZha2VBdWRpb1BhcmFtcyA9IGZ1bmN0aW9uIGNyZWF0ZUZha2VBdWRpb1BhcmFtcygpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICAgICAgICB2YXIgY2hhbm5lbE1lcmdlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IDlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBpc1NjcmlwdFByb2Nlc3Nvck5vZGVDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGxhc3RPcmllbnRhdGlvbiA9IFswLCAwLCAtMSwgMCwgMSwgMF07XG4gICAgICAgICAgdmFyIGxhc3RQb3NpdGlvbiA9IFswLCAwLCAwXTtcbiAgICAgICAgICB2YXIgY3JlYXRlU2NyaXB0UHJvY2Vzc29yTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKSB7XG4gICAgICAgICAgICBpZiAoaXNTY3JpcHRQcm9jZXNzb3JOb2RlQ3JlYXRlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1NjcmlwdFByb2Nlc3Nvck5vZGVDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzY3JpcHRQcm9jZXNzb3JOb2RlID0gY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZShuYXRpdmVDb250ZXh0LCAyNTYsIDksIDApO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0QnVmZmVyID0gX3JlZi5pbnB1dEJ1ZmZlcjtcbiAgICAgICAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gW2dldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDApLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCAxKSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgMiksIGdldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDMpLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCA0KSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgNSldO1xuICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24uc29tZShmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBsYXN0T3JpZW50YXRpb25baW5kZXhdO1xuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZUxpc3RlbmVyLnNldE9yaWVudGF0aW9uLmFwcGx5KG5hdGl2ZUxpc3RlbmVyLCBvcmllbnRhdGlvbik7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgICAgICBsYXN0T3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcG9zaXRvbiA9IFtnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCA2KSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgNyksIGdldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDgpXTtcbiAgICAgICAgICAgICAgaWYgKHBvc2l0b24uc29tZShmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBsYXN0UG9zaXRpb25baW5kZXhdO1xuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZUxpc3RlbmVyLnNldFBvc2l0aW9uLmFwcGx5KG5hdGl2ZUxpc3RlbmVyLCBwb3NpdG9uKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgICAgICAgIGxhc3RQb3NpdGlvbiA9IHBvc2l0b247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFubmVsTWVyZ2VyTm9kZS5jb25uZWN0KHNjcmlwdFByb2Nlc3Nvck5vZGUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGNyZWF0ZVNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gY3JlYXRlU2V0T3JpZW50YXRpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBsYXN0T3JpZW50YXRpb25baW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9yaWVudGF0aW9uW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG5hdGl2ZUxpc3RlbmVyLnNldE9yaWVudGF0aW9uLmFwcGx5KG5hdGl2ZUxpc3RlbmVyLCBfdG9Db25zdW1hYmxlQXJyYXkobGFzdE9yaWVudGF0aW9uKSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjcmVhdGVTZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNldFBvc2l0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdFBvc2l0aW9uW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGxhc3RQb3NpdGlvbltpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBuYXRpdmVMaXN0ZW5lci5zZXRQb3NpdGlvbi5hcHBseShuYXRpdmVMaXN0ZW5lciwgX3RvQ29uc3VtYWJsZUFycmF5KGxhc3RQb3NpdGlvbikpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3JlYXRlRmFrZUF1ZGlvUGFyYW0gPSBmdW5jdGlvbiBjcmVhdGVGYWtlQXVkaW9QYXJhbShpbnB1dCwgaW5pdGlhbFZhbHVlLCBzZXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvbnN0YW50U291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgICAgICBvZmZzZXQ6IGluaXRpYWxWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgaW5wdXQpO1xuICAgICAgICAgICAgLy8gQHRvZG8gVGhpcyBzaG91bGQgYmUgc3RvcHBlZCB3aGVuIHRoZSBjb250ZXh0IGlzIGNsb3NlZC5cbiAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5zdGFydCgpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQsICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEJ1ZyAjNjIgJiAjNzQ6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IENvbnN0YW50U291cmNlTm9kZXMgYW5kIGRvZXMgbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZFxuICAgICAgICAgICAgICogbWluVmFsdWUgZm9yIEdhaW5Ob2Rlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGF1ZGlvUGFyYW0gPSBjcmVhdGVBdWRpb1BhcmFtKHtcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICAgICAgfSwgaXNPZmZsaW5lLCBjb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0LCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgICAgb3ZlcndyaXRlQWNjZXNzb3JzKGF1ZGlvUGFyYW0sICd2YWx1ZScsIGZ1bmN0aW9uIChnZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwoYXVkaW9QYXJhbSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgc2V0LmNhbGwoYXVkaW9QYXJhbSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0UHJvY2Vzc29yTm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc09mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTE3OiBVc2luZyBzZXRPcmllbnRhdGlvbigpIGFuZCBzZXRQb3NpdGlvbigpIGRvZXNuJ3Qgd29yayB3aXRoIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQuXG4gICAgICAgICAgICAgICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdWRpb1BhcmFtLmNhbmNlbEFuZEhvbGRBdFRpbWUgPSBmdW5jdGlvbiAoY2FuY2VsQW5kSG9sZEF0VGltZSkge1xuICAgICAgICAgICAgICBpZiAoaXNPZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FuY2VsQW5kSG9sZEF0VGltZS5hcHBseShhdWRpb1BhcmFtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRQcm9jZXNzb3JOb2RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShhdWRpb1BhcmFtLmNhbmNlbEFuZEhvbGRBdFRpbWUpO1xuICAgICAgICAgICAgYXVkaW9QYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMgPSBmdW5jdGlvbiAoY2FuY2VsU2NoZWR1bGVkVmFsdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc09mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhbmNlbFNjaGVkdWxlZFZhbHVlcy5hcHBseShhdWRpb1BhcmFtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRQcm9jZXNzb3JOb2RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShhdWRpb1BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyk7XG4gICAgICAgICAgICBhdWRpb1BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAoZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSkge1xuICAgICAgICAgICAgICBpZiAoaXNPZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lLmFwcGx5KGF1ZGlvUGFyYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGF1ZGlvUGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSk7XG4gICAgICAgICAgICBhdWRpb1BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKGxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKSB7XG4gICAgICAgICAgICAgIGlmIChpc09mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lLmFwcGx5KGF1ZGlvUGFyYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGF1ZGlvUGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUpO1xuICAgICAgICAgICAgYXVkaW9QYXJhbS5zZXRUYXJnZXRBdFRpbWUgPSBmdW5jdGlvbiAoc2V0VGFyZ2V0QXRUaW1lKSB7XG4gICAgICAgICAgICAgIGlmIChpc09mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNldFRhcmdldEF0VGltZS5hcHBseShhdWRpb1BhcmFtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRQcm9jZXNzb3JOb2RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShhdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSk7XG4gICAgICAgICAgICBhdWRpb1BhcmFtLnNldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHNldFZhbHVlQXRUaW1lKSB7XG4gICAgICAgICAgICAgIGlmIChpc09mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNldFZhbHVlQXRUaW1lLmFwcGx5KGF1ZGlvUGFyYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUpO1xuICAgICAgICAgICAgYXVkaW9QYXJhbS5zZXRWYWx1ZUN1cnZlQXRUaW1lID0gZnVuY3Rpb24gKHNldFZhbHVlQ3VydmVBdFRpbWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2V0VmFsdWVDdXJ2ZUF0VGltZS5hcHBseShhdWRpb1BhcmFtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRQcm9jZXNzb3JOb2RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShhdWRpb1BhcmFtLnNldFZhbHVlQ3VydmVBdFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9yd2FyZFg6IGNyZWF0ZUZha2VBdWRpb1BhcmFtKDAsIDAsIGNyZWF0ZVNldE9yaWVudGF0aW9uKDApKSxcbiAgICAgICAgICAgIGZvcndhcmRZOiBjcmVhdGVGYWtlQXVkaW9QYXJhbSgxLCAwLCBjcmVhdGVTZXRPcmllbnRhdGlvbigxKSksXG4gICAgICAgICAgICBmb3J3YXJkWjogY3JlYXRlRmFrZUF1ZGlvUGFyYW0oMiwgLTEsIGNyZWF0ZVNldE9yaWVudGF0aW9uKDIpKSxcbiAgICAgICAgICAgIHBvc2l0aW9uWDogY3JlYXRlRmFrZUF1ZGlvUGFyYW0oNiwgMCwgY3JlYXRlU2V0UG9zaXRpb24oMCkpLFxuICAgICAgICAgICAgcG9zaXRpb25ZOiBjcmVhdGVGYWtlQXVkaW9QYXJhbSg3LCAwLCBjcmVhdGVTZXRQb3NpdGlvbigxKSksXG4gICAgICAgICAgICBwb3NpdGlvblo6IGNyZWF0ZUZha2VBdWRpb1BhcmFtKDgsIDAsIGNyZWF0ZVNldFBvc2l0aW9uKDIpKSxcbiAgICAgICAgICAgIHVwWDogY3JlYXRlRmFrZUF1ZGlvUGFyYW0oMywgMCwgY3JlYXRlU2V0T3JpZW50YXRpb24oMykpLFxuICAgICAgICAgICAgdXBZOiBjcmVhdGVGYWtlQXVkaW9QYXJhbSg0LCAxLCBjcmVhdGVTZXRPcmllbnRhdGlvbig0KSksXG4gICAgICAgICAgICB1cFo6IGNyZWF0ZUZha2VBdWRpb1BhcmFtKDUsIDAsIGNyZWF0ZVNldE9yaWVudGF0aW9uKDUpKVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBfcmVmMiA9IG5hdGl2ZUxpc3RlbmVyLmZvcndhcmRYID09PSB1bmRlZmluZWQgPyBjcmVhdGVGYWtlQXVkaW9QYXJhbXMoKSA6IG5hdGl2ZUxpc3RlbmVyLFxuICAgICAgICAgIGZvcndhcmRYID0gX3JlZjIuZm9yd2FyZFgsXG4gICAgICAgICAgZm9yd2FyZFkgPSBfcmVmMi5mb3J3YXJkWSxcbiAgICAgICAgICBmb3J3YXJkWiA9IF9yZWYyLmZvcndhcmRaLFxuICAgICAgICAgIHBvc2l0aW9uWCA9IF9yZWYyLnBvc2l0aW9uWCxcbiAgICAgICAgICBwb3NpdGlvblkgPSBfcmVmMi5wb3NpdGlvblksXG4gICAgICAgICAgcG9zaXRpb25aID0gX3JlZjIucG9zaXRpb25aLFxuICAgICAgICAgIHVwWCA9IF9yZWYyLnVwWCxcbiAgICAgICAgICB1cFkgPSBfcmVmMi51cFksXG4gICAgICAgICAgdXBaID0gX3JlZjIudXBaO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdldCBmb3J3YXJkWCgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3J3YXJkWDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBmb3J3YXJkWSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3J3YXJkWTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBmb3J3YXJkWigpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3J3YXJkWjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwb3NpdGlvblgoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25YO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBvc2l0aW9uWSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvblk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgcG9zaXRpb25aKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uWjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCB1cFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBYO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHVwWSgpIHtcbiAgICAgICAgICAgIHJldHVybiB1cFk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgdXBaKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwWjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaXNBdWRpb05vZGUgPSBmdW5jdGlvbiBpc0F1ZGlvTm9kZShhdWRpb05vZGVPckF1ZGlvUGFyYW0pIHtcbiAgICAgIHJldHVybiAnY29udGV4dCcgaW4gYXVkaW9Ob2RlT3JBdWRpb1BhcmFtO1xuICAgIH07XG5cbiAgICB2YXIgaXNBdWRpb05vZGVPdXRwdXRDb25uZWN0aW9uID0gZnVuY3Rpb24gaXNBdWRpb05vZGVPdXRwdXRDb25uZWN0aW9uKG91dHB1dENvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiBpc0F1ZGlvTm9kZShvdXRwdXRDb25uZWN0aW9uWzBdKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYShyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGEocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkYShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkYShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkYShyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkYShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIGluc2VydEVsZW1lbnRJblNldCA9IGZ1bmN0aW9uIGluc2VydEVsZW1lbnRJblNldChzZXQsIGVsZW1lbnQsIHByZWRpY2F0ZSwgaWdub3JlRHVwbGljYXRlcykge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJGEoc2V0KSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBsbW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShsbW50KSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZUR1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSBzZXQgY29udGFpbnMgYXQgbGVhc3Qgb25lIHNpbWlsYXIgZWxlbWVudC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHNldC5hZGQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbShhY3RpdmVJbnB1dHMsIHNvdXJjZSwgX3JlZiwgaWdub3JlRHVwbGljYXRlcykge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIG91dHB1dCA9IF9yZWYyWzBdLFxuICAgICAgICBldmVudExpc3RlbmVyID0gX3JlZjJbMV07XG4gICAgICBpbnNlcnRFbGVtZW50SW5TZXQoYWN0aXZlSW5wdXRzLCBbc291cmNlLCBvdXRwdXQsIGV2ZW50TGlzdGVuZXJdLCBmdW5jdGlvbiAoYWN0aXZlSW5wdXRDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVJbnB1dENvbm5lY3Rpb25bMF0gPT09IHNvdXJjZSAmJiBhY3RpdmVJbnB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dDtcbiAgICAgIH0sIGlnbm9yZUR1cGxpY2F0ZXMpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGFkZFBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0ocGFzc2l2ZUlucHV0cywgX3JlZiwgaWdub3JlRHVwbGljYXRlcykge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMyksXG4gICAgICAgIHNvdXJjZSA9IF9yZWYyWzBdLFxuICAgICAgICBvdXRwdXQgPSBfcmVmMlsxXSxcbiAgICAgICAgZXZlbnRMaXN0ZW5lciA9IF9yZWYyWzJdO1xuICAgICAgdmFyIHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zID0gcGFzc2l2ZUlucHV0cy5nZXQoc291cmNlKTtcbiAgICAgIGlmIChwYXNzaXZlSW5wdXRDb25uZWN0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhc3NpdmVJbnB1dHMuc2V0KHNvdXJjZSwgbmV3IFNldChbW291dHB1dCwgZXZlbnRMaXN0ZW5lcl1dKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNlcnRFbGVtZW50SW5TZXQocGFzc2l2ZUlucHV0Q29ubmVjdGlvbnMsIFtvdXRwdXQsIGV2ZW50TGlzdGVuZXJdLCBmdW5jdGlvbiAocGFzc2l2ZUlucHV0Q29ubmVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBwYXNzaXZlSW5wdXRDb25uZWN0aW9uWzBdID09PSBvdXRwdXQ7XG4gICAgICAgIH0sIGlnbm9yZUR1cGxpY2F0ZXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaXNOYXRpdmVBdWRpb05vZGVGYWtlciA9IGZ1bmN0aW9uIGlzTmF0aXZlQXVkaW9Ob2RlRmFrZXIobmF0aXZlQXVkaW9Ob2RlT3JOYXRpdmVBdWRpb05vZGVGYWtlcikge1xuICAgICAgcmV0dXJuICdpbnB1dHMnIGluIG5hdGl2ZUF1ZGlvTm9kZU9yTmF0aXZlQXVkaW9Ob2RlRmFrZXI7XG4gICAgfTtcblxuICAgIHZhciBjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUgPSBmdW5jdGlvbiBjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUobmF0aXZlU291cmNlQXVkaW9Ob2RlLCBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSwgb3V0cHV0LCBpbnB1dCkge1xuICAgICAgaWYgKGlzTmF0aXZlQXVkaW9Ob2RlRmFrZXIobmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUpKSB7XG4gICAgICAgIHZhciBmYWtlTmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUgPSBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZS5pbnB1dHNbaW5wdXRdO1xuICAgICAgICBuYXRpdmVTb3VyY2VBdWRpb05vZGUuY29ubmVjdChmYWtlTmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dCwgMCk7XG4gICAgICAgIHJldHVybiBbZmFrZU5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIDBdO1xuICAgICAgfVxuICAgICAgbmF0aXZlU291cmNlQXVkaW9Ob2RlLmNvbm5lY3QobmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dCwgaW5wdXQpO1xuICAgICAgcmV0dXJuIFtuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSwgb3V0cHV0LCBpbnB1dF07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDkociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ5KHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDkociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb24gPSBmdW5jdGlvbiBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb24oYWN0aXZlSW5wdXRDb25uZWN0aW9ucywgc291cmNlLCBvdXRwdXQpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ5KGFjdGl2ZUlucHV0Q29ubmVjdGlvbnMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGFjdGl2ZUlucHV0Q29ubmVjdGlvbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChhY3RpdmVJbnB1dENvbm5lY3Rpb25bMF0gPT09IHNvdXJjZSAmJiBhY3RpdmVJbnB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dCkge1xuICAgICAgICAgICAgYWN0aXZlSW5wdXRDb25uZWN0aW9uc1tcImRlbGV0ZVwiXShhY3RpdmVJbnB1dENvbm5lY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUlucHV0Q29ubmVjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgZGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtID0gZnVuY3Rpb24gZGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKGFjdGl2ZUlucHV0cywgc291cmNlLCBvdXRwdXQpIHtcbiAgICAgIHJldHVybiBwaWNrRWxlbWVudEZyb21TZXQoYWN0aXZlSW5wdXRzLCBmdW5jdGlvbiAoYWN0aXZlSW5wdXRDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVJbnB1dENvbm5lY3Rpb25bMF0gPT09IHNvdXJjZSAmJiBhY3RpdmVJbnB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZGVsZXRlRXZlbnRMaXN0ZW5lck9mQXVkaW9Ob2RlID0gZnVuY3Rpb24gZGVsZXRlRXZlbnRMaXN0ZW5lck9mQXVkaW9Ob2RlKGF1ZGlvTm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gZ2V0RXZlbnRMaXN0ZW5lcnNPZkF1ZGlvTm9kZShhdWRpb05vZGUpO1xuICAgICAgaWYgKCFldmVudExpc3RlbmVyc1tcImRlbGV0ZVwiXShldmVudExpc3RlbmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIGV4cGVjdGVkIGV2ZW50IGxpc3RlbmVyLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVsZXRlUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGRlbGV0ZVBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0ocGFzc2l2ZUlucHV0cywgc291cmNlLCBvdXRwdXQpIHtcbiAgICAgIHZhciBwYXNzaXZlSW5wdXRDb25uZWN0aW9ucyA9IGdldFZhbHVlRm9yS2V5KHBhc3NpdmVJbnB1dHMsIHNvdXJjZSk7XG4gICAgICB2YXIgbWF0Y2hpbmdDb25uZWN0aW9uID0gcGlja0VsZW1lbnRGcm9tU2V0KHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zLCBmdW5jdGlvbiAocGFzc2l2ZUlucHV0Q29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gcGFzc2l2ZUlucHV0Q29ubmVjdGlvblswXSA9PT0gb3V0cHV0O1xuICAgICAgfSk7XG4gICAgICBpZiAocGFzc2l2ZUlucHV0Q29ubmVjdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBwYXNzaXZlSW5wdXRzW1wiZGVsZXRlXCJdKHNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hpbmdDb25uZWN0aW9uO1xuICAgIH07XG5cbiAgICB2YXIgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZUZyb21OYXRpdmVBdWRpb05vZGUgPSBmdW5jdGlvbiBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZShuYXRpdmVTb3VyY2VBdWRpb05vZGUsIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0KSB7XG4gICAgICBpZiAoaXNOYXRpdmVBdWRpb05vZGVGYWtlcihuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSkpIHtcbiAgICAgICAgbmF0aXZlU291cmNlQXVkaW9Ob2RlLmRpc2Nvbm5lY3QobmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUuaW5wdXRzW2lucHV0XSwgb3V0cHV0LCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZS5kaXNjb25uZWN0KG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldE5hdGl2ZUF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGdldE5hdGl2ZUF1ZGlvTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBnZXRWYWx1ZUZvcktleShBVURJT19OT0RFX1NUT1JFLCBhdWRpb05vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TmF0aXZlQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGdldE5hdGl2ZUF1ZGlvUGFyYW0oYXVkaW9QYXJhbSkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlRm9yS2V5KEFVRElPX1BBUkFNX1NUT1JFLCBhdWRpb1BhcmFtKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzUGFydE9mQUN5Y2xlID0gZnVuY3Rpb24gaXNQYXJ0T2ZBQ3ljbGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gQ1lDTEVfQ09VTlRFUlMuaGFzKGF1ZGlvTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBpc1Bhc3NpdmVBdWRpb05vZGUgPSBmdW5jdGlvbiBpc1Bhc3NpdmVBdWRpb05vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gIUFDVElWRV9BVURJT19OT0RFX1NUT1JFLmhhcyhhdWRpb05vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvTm9kZURpc2Nvbm5lY3RNZXRob2RTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEF1ZGlvTm9kZURpc2Nvbm5lY3RNZXRob2RTdXBwb3J0KG5hdGl2ZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBidWcgZXhpc3RlZCBpbiBTYWZhcmkgdXAgdW50aWwgdjE0LjAuMi4gU2luY2UgQXVkaW9Xb3JrbGV0cyB3ZXJlIG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpIHVudGlsIHYxNC4xIHRoZSBwcmVzZW5jZSBvZiB0aGVcbiAgICAgICAgICogY29uc3RydWN0b3IgZm9yIGFuIEF1ZGlvV29ya2xldE5vZGUgY2FuIGJlIHVzZWQgaGVyZSB0byBza2lwIHRoZSB0ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFuYWx5emVyID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigyNTYsIDEsIDEpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uXG4gICAgICAgICAgdmFyIGR1bW15ID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgICAvLyBCdWcgIzk1OiBTYWZhcmkgZG9lcyBub3QgcGxheSBvbmUgc2FtcGxlIGJ1ZmZlcnMuXG4gICAgICAgICAgdmFyIG9uZXMgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDIsIDQ0MTAwKTtcbiAgICAgICAgICB2YXIgY2hhbm5lbERhdGEgPSBvbmVzLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICAgIGNoYW5uZWxEYXRhWzBdID0gMTtcbiAgICAgICAgICBjaGFubmVsRGF0YVsxXSA9IDE7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IG5hdGl2ZUF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgICBzb3VyY2UuYnVmZmVyID0gb25lcztcbiAgICAgICAgICBzb3VyY2UubG9vcCA9IHRydWU7XG4gICAgICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHl6ZXIpLmNvbm5lY3QobmF0aXZlQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICBzb3VyY2UuY29ubmVjdChkdW1teSk7XG4gICAgICAgICAgc291cmNlLmRpc2Nvbm5lY3QoZHVtbXkpO1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgIGFuYWx5emVyLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgY2hubmxEdCA9IGV2ZW50LmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uXG4gICAgICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChjaG5ubER0LCBmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzYW1wbGUgPT09IDE7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2Uuc3RvcCgpO1xuICAgICAgICAgICAgYW5hbHl6ZXIub25hdWRpb3Byb2Nlc3MgPSBudWxsOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgICBzb3VyY2UuZGlzY29ubmVjdChhbmFseXplcik7XG4gICAgICAgICAgICBhbmFseXplci5kaXNjb25uZWN0KG5hdGl2ZUF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzb3VyY2Uuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDgociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ4KHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDgociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDgociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDgociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDgociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciB2aXNpdEVhY2hBdWRpb05vZGVPbmNlID0gZnVuY3Rpb24gdmlzaXRFYWNoQXVkaW9Ob2RlT25jZShjeWNsZXMsIHZpc2l0b3IpIHtcbiAgICAgIHZhciBjb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOChjeWNsZXMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGN5Y2xlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KGN5Y2xlKSxcbiAgICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGF1ZGlvTm9kZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gY291bnRzLmdldChhdWRpb05vZGUpO1xuICAgICAgICAgICAgICBjb3VudHMuc2V0KGF1ZGlvTm9kZSwgY291bnQgPT09IHVuZGVmaW5lZCA/IDEgOiBjb3VudCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgY291bnRzLmZvckVhY2goZnVuY3Rpb24gKGNvdW50LCBhdWRpb05vZGUpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IoYXVkaW9Ob2RlLCBjb3VudCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGlzTmF0aXZlQXVkaW9Ob2RlJDEgPSBmdW5jdGlvbiBpc05hdGl2ZUF1ZGlvTm9kZShuYXRpdmVBdWRpb05vZGVPckF1ZGlvUGFyYW0pIHtcbiAgICAgIHJldHVybiAnY29udGV4dCcgaW4gbmF0aXZlQXVkaW9Ob2RlT3JBdWRpb1BhcmFtO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KHIsIGUpIHsgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIXQpIHsgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhyKSkgfHwgZSkgeyB0ICYmIChyID0gdCk7IHZhciBfbiA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbiA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB0aHJvdyByOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBvLCBhID0gITAsIHUgPSAhMTsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgdCA9IHQuY2FsbChyKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHIgPSB0Lm5leHQoKTsgcmV0dXJuIGEgPSByLmRvbmUsIHI7IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB1ID0gITAsIG8gPSByOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmICh1KSB0aHJvdyBvOyB9IH0gfTsgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheSQ3KHIsIGEpIDogdm9pZCAwOyB9IH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ3KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbiAgICB2YXIgd3JhcEF1ZGlvTm9kZURpc2Nvbm5lY3RNZXRob2QgPSBmdW5jdGlvbiB3cmFwQXVkaW9Ob2RlRGlzY29ubmVjdE1ldGhvZChuYXRpdmVBdWRpb05vZGUpIHtcbiAgICAgIHZhciBjb25uZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIG5hdGl2ZUF1ZGlvTm9kZS5jb25uZWN0ID0gZnVuY3Rpb24gKGNvbm5lY3QpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmludmFsaWQtdm9pZCBuby1pbmZlcnJhYmxlLXR5cGVzXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgIHZhciBpbnB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBpc05hdGl2ZUF1ZGlvTm9kZSQxKGRlc3RpbmF0aW9uKSA/IGNvbm5lY3QoZGVzdGluYXRpb24sIG91dHB1dCwgaW5wdXQpIDogY29ubmVjdChkZXN0aW5hdGlvbiwgb3V0cHV0KTtcbiAgICAgICAgICAvLyBTYXZlIHRoZSBuZXcgY29ubmVjdGlvbiBvbmx5IGlmIHRoZSBjYWxscyB0byBjb25uZWN0IGFib3ZlIGRpZG4ndCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICB2YXIgY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uID0gY29ubmVjdGlvbnMuZ2V0KGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICBpZiAoY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNldChkZXN0aW5hdGlvbiwgW3tcbiAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuICAgICAgICAgICAgfV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmlucHV0ICE9PSBpbnB1dCB8fCBjb25uZWN0aW9uLm91dHB1dCAhPT0gb3V0cHV0O1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfShuYXRpdmVBdWRpb05vZGUuY29ubmVjdC5iaW5kKG5hdGl2ZUF1ZGlvTm9kZSkpO1xuICAgICAgbmF0aXZlQXVkaW9Ob2RlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZGlzY29ubmVjdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlc3RpbmF0aW9uT3JPdXRwdXQsIG91dHB1dCwgaW5wdXQpIHtcbiAgICAgICAgICBkaXNjb25uZWN0LmFwcGx5KG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yT3V0cHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoY29ubmVjdGlvbnMpLFxuICAgICAgICAgICAgICBfc3RlcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zVG9EZXN0aW5hdGlvbiA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZENvbm5lY3Rpb25zID0gY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uLmZpbHRlcihmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ub3V0cHV0ICE9PSBkZXN0aW5hdGlvbk9yT3V0cHV0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZENvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNbXCJkZWxldGVcIl0oZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25uZWN0aW9ucy5zZXQoZGVzdGluYXRpb24sIGZpbHRlcmVkQ29ubmVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvbnMuaGFzKGRlc3RpbmF0aW9uT3JPdXRwdXQpKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbnNbXCJkZWxldGVcIl0oZGVzdGluYXRpb25Pck91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2Nvbm5lY3Rpb25zVG9EZXN0aW5hdGlvbiA9IGNvbm5lY3Rpb25zLmdldChkZXN0aW5hdGlvbk9yT3V0cHV0KTtcbiAgICAgICAgICAgICAgaWYgKF9jb25uZWN0aW9uc1RvRGVzdGluYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBfZmlsdGVyZWRDb25uZWN0aW9ucyA9IF9jb25uZWN0aW9uc1RvRGVzdGluYXRpb24uZmlsdGVyKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5vdXRwdXQgIT09IG91dHB1dCAmJiAoY29ubmVjdGlvbi5pbnB1dCAhPT0gaW5wdXQgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKF9maWx0ZXJlZENvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNbXCJkZWxldGVcIl0oZGVzdGluYXRpb25Pck91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNldChkZXN0aW5hdGlvbk9yT3V0cHV0LCBfZmlsdGVyZWRDb25uZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhjb25uZWN0aW9ucyksXG4gICAgICAgICAgICBfc3RlcDI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1RvRGVzdGluYXRpb24gPSBfc3RlcDIkdmFsdWVbMV07XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25zVG9EZXN0aW5hdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmF0aXZlQXVkaW9Ob2RlJDEoZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb05vZGUuY29ubmVjdChkZXN0aW5hdGlvbiwgY29ubmVjdGlvbi5vdXRwdXQsIGNvbm5lY3Rpb24uaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb05vZGUuY29ubmVjdChkZXN0aW5hdGlvbiwgY29ubmVjdGlvbi5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KG5hdGl2ZUF1ZGlvTm9kZS5kaXNjb25uZWN0KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRuKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDYociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDYociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciBhZGRDb25uZWN0aW9uVG9BdWRpb1BhcmFtT2ZBdWRpb0NvbnRleHQgPSBmdW5jdGlvbiBhZGRDb25uZWN0aW9uVG9BdWRpb1BhcmFtT2ZBdWRpb0NvbnRleHQoc291cmNlLCBkZXN0aW5hdGlvbiwgb3V0cHV0LCBpc09mZmxpbmUpIHtcbiAgICAgIHZhciBfZ2V0QXVkaW9QYXJhbUNvbm5lY3QgPSBnZXRBdWRpb1BhcmFtQ29ubmVjdGlvbnMoZGVzdGluYXRpb24pLFxuICAgICAgICBhY3RpdmVJbnB1dHMgPSBfZ2V0QXVkaW9QYXJhbUNvbm5lY3QuYWN0aXZlSW5wdXRzLFxuICAgICAgICBwYXNzaXZlSW5wdXRzID0gX2dldEF1ZGlvUGFyYW1Db25uZWN0LnBhc3NpdmVJbnB1dHM7XG4gICAgICB2YXIgX2dldEF1ZGlvTm9kZUNvbm5lY3RpID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoc291cmNlKSxcbiAgICAgICAgb3V0cHV0cyA9IF9nZXRBdWRpb05vZGVDb25uZWN0aS5vdXRwdXRzO1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gZ2V0RXZlbnRMaXN0ZW5lcnNPZkF1ZGlvTm9kZShzb3VyY2UpO1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBldmVudExpc3RlbmVyKGlzQWN0aXZlKSB7XG4gICAgICAgIHZhciBuYXRpdmVBdWRpb05vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUoc291cmNlKTtcbiAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvUGFyYW0gPSBnZXROYXRpdmVBdWRpb1BhcmFtKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgdmFyIHBhcnRpYWxDb25uZWN0aW9uID0gZGVsZXRlUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbShwYXNzaXZlSW5wdXRzLCBzb3VyY2UsIG91dHB1dCk7XG4gICAgICAgICAgYWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKGFjdGl2ZUlucHV0cywgc291cmNlLCBwYXJ0aWFsQ29ubmVjdGlvbiwgZmFsc2UpO1xuICAgICAgICAgIGlmICghaXNPZmZsaW5lICYmICFpc1BhcnRPZkFDeWNsZShzb3VyY2UpKSB7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb05vZGUuY29ubmVjdChuYXRpdmVBdWRpb1BhcmFtLCBvdXRwdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BhcnRpYWxDb25uZWN0aW9uID0gZGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKGFjdGl2ZUlucHV0cywgc291cmNlLCBvdXRwdXQpO1xuICAgICAgICAgIGFkZFBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0ocGFzc2l2ZUlucHV0cywgX3BhcnRpYWxDb25uZWN0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKCFpc09mZmxpbmUgJiYgIWlzUGFydE9mQUN5Y2xlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZS5kaXNjb25uZWN0KG5hdGl2ZUF1ZGlvUGFyYW0sIG91dHB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGluc2VydEVsZW1lbnRJblNldChvdXRwdXRzLCBbZGVzdGluYXRpb24sIG91dHB1dF0sIGZ1bmN0aW9uIChvdXRwdXRDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRDb25uZWN0aW9uWzBdID09PSBkZXN0aW5hdGlvbiAmJiBvdXRwdXRDb25uZWN0aW9uWzFdID09PSBvdXRwdXQ7XG4gICAgICB9LCB0cnVlKSkge1xuICAgICAgICBldmVudExpc3RlbmVycy5hZGQoZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIGlmIChpc0FjdGl2ZUF1ZGlvTm9kZShzb3VyY2UpKSB7XG4gICAgICAgICAgYWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKGFjdGl2ZUlucHV0cywgc291cmNlLCBbb3V0cHV0LCBldmVudExpc3RlbmVyXSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbShwYXNzaXZlSW5wdXRzLCBbc291cmNlLCBvdXRwdXQsIGV2ZW50TGlzdGVuZXJdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHZhciBkZWxldGVJbnB1dENvbm5lY3Rpb25PZkF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGRlbGV0ZUlucHV0Q29ubmVjdGlvbk9mQXVkaW9Ob2RlKHNvdXJjZSwgZGVzdGluYXRpb24sIG91dHB1dCwgaW5wdXQpIHtcbiAgICAgIHZhciBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkyID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoZGVzdGluYXRpb24pLFxuICAgICAgICBhY3RpdmVJbnB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkyLmFjdGl2ZUlucHV0cyxcbiAgICAgICAgcGFzc2l2ZUlucHV0cyA9IF9nZXRBdWRpb05vZGVDb25uZWN0aTIucGFzc2l2ZUlucHV0cztcbiAgICAgIHZhciBhY3RpdmVJbnB1dENvbm5lY3Rpb24gPSBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb24oYWN0aXZlSW5wdXRzW2lucHV0XSwgc291cmNlLCBvdXRwdXQpO1xuICAgICAgaWYgKGFjdGl2ZUlucHV0Q29ubmVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFzc2l2ZUlucHV0Q29ubmVjdGlvbiA9IGRlbGV0ZVBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShwYXNzaXZlSW5wdXRzLCBzb3VyY2UsIG91dHB1dCwgaW5wdXQpO1xuICAgICAgICByZXR1cm4gW3Bhc3NpdmVJbnB1dENvbm5lY3Rpb25bMl0sIGZhbHNlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYWN0aXZlSW5wdXRDb25uZWN0aW9uWzJdLCB0cnVlXTtcbiAgICB9O1xuICAgIHZhciBkZWxldGVJbnB1dENvbm5lY3Rpb25PZkF1ZGlvUGFyYW0gPSBmdW5jdGlvbiBkZWxldGVJbnB1dENvbm5lY3Rpb25PZkF1ZGlvUGFyYW0oc291cmNlLCBkZXN0aW5hdGlvbiwgb3V0cHV0KSB7XG4gICAgICB2YXIgX2dldEF1ZGlvUGFyYW1Db25uZWN0MiA9IGdldEF1ZGlvUGFyYW1Db25uZWN0aW9ucyhkZXN0aW5hdGlvbiksXG4gICAgICAgIGFjdGl2ZUlucHV0cyA9IF9nZXRBdWRpb1BhcmFtQ29ubmVjdDIuYWN0aXZlSW5wdXRzLFxuICAgICAgICBwYXNzaXZlSW5wdXRzID0gX2dldEF1ZGlvUGFyYW1Db25uZWN0Mi5wYXNzaXZlSW5wdXRzO1xuICAgICAgdmFyIGFjdGl2ZUlucHV0Q29ubmVjdGlvbiA9IGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvbihhY3RpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0KTtcbiAgICAgIGlmIChhY3RpdmVJbnB1dENvbm5lY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhc3NpdmVJbnB1dENvbm5lY3Rpb24gPSBkZWxldGVQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKHBhc3NpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIFtwYXNzaXZlSW5wdXRDb25uZWN0aW9uWzFdLCBmYWxzZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW2FjdGl2ZUlucHV0Q29ubmVjdGlvblsyXSwgdHJ1ZV07XG4gICAgfTtcbiAgICB2YXIgZGVsZXRlSW5wdXRzT2ZBdWRpb05vZGUgPSBmdW5jdGlvbiBkZWxldGVJbnB1dHNPZkF1ZGlvTm9kZShzb3VyY2UsIGlzT2ZmbGluZSwgZGVzdGluYXRpb24sIG91dHB1dCwgaW5wdXQpIHtcbiAgICAgIHZhciBfZGVsZXRlSW5wdXRDb25uZWN0aW8gPSBkZWxldGVJbnB1dENvbm5lY3Rpb25PZkF1ZGlvTm9kZShzb3VyY2UsIGRlc3RpbmF0aW9uLCBvdXRwdXQsIGlucHV0KSxcbiAgICAgICAgX2RlbGV0ZUlucHV0Q29ubmVjdGlvMiA9IF9zbGljZWRUb0FycmF5KF9kZWxldGVJbnB1dENvbm5lY3RpbywgMiksXG4gICAgICAgIGxpc3RlbmVyID0gX2RlbGV0ZUlucHV0Q29ubmVjdGlvMlswXSxcbiAgICAgICAgaXNBY3RpdmUgPSBfZGVsZXRlSW5wdXRDb25uZWN0aW8yWzFdO1xuICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZUV2ZW50TGlzdGVuZXJPZkF1ZGlvTm9kZShzb3VyY2UsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGlzQWN0aXZlICYmICFpc09mZmxpbmUgJiYgIWlzUGFydE9mQUN5Y2xlKHNvdXJjZSkpIHtcbiAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZShnZXROYXRpdmVBdWRpb05vZGUoc291cmNlKSwgZ2V0TmF0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSwgb3V0cHV0LCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0FjdGl2ZUF1ZGlvTm9kZShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgdmFyIF9nZXRBdWRpb05vZGVDb25uZWN0aTMgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhkZXN0aW5hdGlvbiksXG4gICAgICAgICAgYWN0aXZlSW5wdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpMy5hY3RpdmVJbnB1dHM7XG4gICAgICAgIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmVXaGVuTmVjZXNzYXJ5KGRlc3RpbmF0aW9uLCBhY3RpdmVJbnB1dHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRlbGV0ZUlucHV0c09mQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGRlbGV0ZUlucHV0c09mQXVkaW9QYXJhbShzb3VyY2UsIGlzT2ZmbGluZSwgZGVzdGluYXRpb24sIG91dHB1dCkge1xuICAgICAgdmFyIF9kZWxldGVJbnB1dENvbm5lY3RpbzMgPSBkZWxldGVJbnB1dENvbm5lY3Rpb25PZkF1ZGlvUGFyYW0oc291cmNlLCBkZXN0aW5hdGlvbiwgb3V0cHV0KSxcbiAgICAgICAgX2RlbGV0ZUlucHV0Q29ubmVjdGlvNCA9IF9zbGljZWRUb0FycmF5KF9kZWxldGVJbnB1dENvbm5lY3RpbzMsIDIpLFxuICAgICAgICBsaXN0ZW5lciA9IF9kZWxldGVJbnB1dENvbm5lY3RpbzRbMF0sXG4gICAgICAgIGlzQWN0aXZlID0gX2RlbGV0ZUlucHV0Q29ubmVjdGlvNFsxXTtcbiAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBkZWxldGVFdmVudExpc3RlbmVyT2ZBdWRpb05vZGUoc291cmNlLCBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpc0FjdGl2ZSAmJiAhaXNPZmZsaW5lICYmICFpc1BhcnRPZkFDeWNsZShzb3VyY2UpKSB7XG4gICAgICAgICAgZ2V0TmF0aXZlQXVkaW9Ob2RlKHNvdXJjZSkuZGlzY29ubmVjdChnZXROYXRpdmVBdWRpb1BhcmFtKGRlc3RpbmF0aW9uKSwgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRlbGV0ZUFueUNvbm5lY3Rpb24gPSBmdW5jdGlvbiBkZWxldGVBbnlDb25uZWN0aW9uKHNvdXJjZSwgaXNPZmZsaW5lKSB7XG4gICAgICB2YXIgYXVkaW9Ob2RlQ29ubmVjdGlvbnNPZlNvdXJjZSA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKHNvdXJjZSk7XG4gICAgICB2YXIgZGVzdGluYXRpb25zID0gW107XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihhdWRpb05vZGVDb25uZWN0aW9uc09mU291cmNlLm91dHB1dHMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG91dHB1dENvbm5lY3Rpb24gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoaXNBdWRpb05vZGVPdXRwdXRDb25uZWN0aW9uKG91dHB1dENvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBkZWxldGVJbnB1dHNPZkF1ZGlvTm9kZS5hcHBseSh2b2lkIDAsIFtzb3VyY2UsIGlzT2ZmbGluZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvdXRwdXRDb25uZWN0aW9uKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGVJbnB1dHNPZkF1ZGlvUGFyYW0uYXBwbHkodm9pZCAwLCBbc291cmNlLCBpc09mZmxpbmVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob3V0cHV0Q29ubmVjdGlvbikpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdGluYXRpb25zLnB1c2gob3V0cHV0Q29ubmVjdGlvblswXSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIGF1ZGlvTm9kZUNvbm5lY3Rpb25zT2ZTb3VyY2Uub3V0cHV0cy5jbGVhcigpO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9ucztcbiAgICB9O1xuICAgIHZhciBkZWxldGVDb25uZWN0aW9uQXRPdXRwdXQgPSBmdW5jdGlvbiBkZWxldGVDb25uZWN0aW9uQXRPdXRwdXQoc291cmNlLCBpc09mZmxpbmUsIG91dHB1dCkge1xuICAgICAgdmFyIGF1ZGlvTm9kZUNvbm5lY3Rpb25zT2ZTb3VyY2UgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhzb3VyY2UpO1xuICAgICAgdmFyIGRlc3RpbmF0aW9ucyA9IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KGF1ZGlvTm9kZUNvbm5lY3Rpb25zT2ZTb3VyY2Uub3V0cHV0cyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG91dHB1dENvbm5lY3Rpb24gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgaWYgKG91dHB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dCkge1xuICAgICAgICAgICAgaWYgKGlzQXVkaW9Ob2RlT3V0cHV0Q29ubmVjdGlvbihvdXRwdXRDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICBkZWxldGVJbnB1dHNPZkF1ZGlvTm9kZS5hcHBseSh2b2lkIDAsIFtzb3VyY2UsIGlzT2ZmbGluZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvdXRwdXRDb25uZWN0aW9uKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlSW5wdXRzT2ZBdWRpb1BhcmFtLmFwcGx5KHZvaWQgMCwgW3NvdXJjZSwgaXNPZmZsaW5lXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG91dHB1dENvbm5lY3Rpb24pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0aW5hdGlvbnMucHVzaChvdXRwdXRDb25uZWN0aW9uWzBdKTtcbiAgICAgICAgICAgIGF1ZGlvTm9kZUNvbm5lY3Rpb25zT2ZTb3VyY2Uub3V0cHV0c1tcImRlbGV0ZVwiXShvdXRwdXRDb25uZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9ucztcbiAgICB9O1xuICAgIHZhciBkZWxldGVDb25uZWN0aW9uVG9EZXN0aW5hdGlvbiA9IGZ1bmN0aW9uIGRlbGV0ZUNvbm5lY3Rpb25Ub0Rlc3RpbmF0aW9uKHNvdXJjZSwgaXNPZmZsaW5lLCBkZXN0aW5hdGlvbiwgb3V0cHV0LCBpbnB1dCkge1xuICAgICAgdmFyIGF1ZGlvTm9kZUNvbm5lY3Rpb25zT2ZTb3VyY2UgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXVkaW9Ob2RlQ29ubmVjdGlvbnNPZlNvdXJjZS5vdXRwdXRzKS5maWx0ZXIoZnVuY3Rpb24gKG91dHB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dENvbm5lY3Rpb25bMF0gPT09IGRlc3RpbmF0aW9uICYmIChvdXRwdXQgPT09IHVuZGVmaW5lZCB8fCBvdXRwdXRDb25uZWN0aW9uWzFdID09PSBvdXRwdXQpICYmIChpbnB1dCA9PT0gdW5kZWZpbmVkIHx8IG91dHB1dENvbm5lY3Rpb25bMl0gPT09IGlucHV0KTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAob3V0cHV0Q29ubmVjdGlvbikge1xuICAgICAgICBpZiAoaXNBdWRpb05vZGVPdXRwdXRDb25uZWN0aW9uKG91dHB1dENvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgZGVsZXRlSW5wdXRzT2ZBdWRpb05vZGUuYXBwbHkodm9pZCAwLCBbc291cmNlLCBpc09mZmxpbmVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob3V0cHV0Q29ubmVjdGlvbikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVJbnB1dHNPZkF1ZGlvUGFyYW0uYXBwbHkodm9pZCAwLCBbc291cmNlLCBpc09mZmxpbmVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob3V0cHV0Q29ubmVjdGlvbikpKTtcbiAgICAgICAgfVxuICAgICAgICBhdWRpb05vZGVDb25uZWN0aW9uc09mU291cmNlLm91dHB1dHNbXCJkZWxldGVcIl0ob3V0cHV0Q29ubmVjdGlvbik7XG4gICAgICAgIHJldHVybiBvdXRwdXRDb25uZWN0aW9uWzBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQXVkaW9Ob2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb05vZGVDb25zdHJ1Y3RvcihhZGRBdWRpb05vZGVDb25uZWN0aW9ucywgYWRkQ29ubmVjdGlvblRvQXVkaW9Ob2RlLCBjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZUluY3JlbWVudEN5Y2xlQ291bnRlciwgY3JlYXRlSW5kZXhTaXplRXJyb3IsIGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGRlY3JlbWVudEN5Y2xlQ291bnRlciwgZGV0ZWN0Q3ljbGVzLCBldmVudFRhcmdldENvbnN0cnVjdG9yLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZUF1ZGlvQ29udGV4dCwgaXNOYXRpdmVBdWRpb05vZGUsIGlzTmF0aXZlQXVkaW9QYXJhbSwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ldmVudFRhcmdldENvbnN0cnVjdCkge1xuICAgICAgICBmdW5jdGlvbiBBdWRpb05vZGUoY29udGV4dCwgaXNBY3RpdmUsIG5hdGl2ZUF1ZGlvTm9kZSwgYXVkaW9Ob2RlUmVuZGVyZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvTm9kZSk7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJG4odGhpcywgQXVkaW9Ob2RlLCBbbmF0aXZlQXVkaW9Ob2RlXSk7XG4gICAgICAgICAgX3RoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVBdWRpb05vZGUgPSBuYXRpdmVBdWRpb05vZGU7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIC8vIEJ1ZyAjMTI6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHRvIGRpc2Nvbm5lY3QgYSBzcGVjaWZpYyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICBpZiAoaXNOYXRpdmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCkgJiYgdHJ1ZSAhPT0gY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb05vZGVEaXNjb25uZWN0TWV0aG9kU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb05vZGVEaXNjb25uZWN0TWV0aG9kU3VwcG9ydChuYXRpdmVDb250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB3cmFwQXVkaW9Ob2RlRGlzY29ubmVjdE1ldGhvZChuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBBVURJT19OT0RFX1NUT1JFLnNldChfdGhpcywgbmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICBFVkVOVF9MSVNURU5FUlMuc2V0KF90aGlzLCBuZXcgU2V0KCkpO1xuICAgICAgICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAnY2xvc2VkJyAmJiBpc0FjdGl2ZSkge1xuICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvQWN0aXZlKF90aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkQXVkaW9Ob2RlQ29ubmVjdGlvbnMoX3RoaXMsIGF1ZGlvTm9kZVJlbmRlcmVyLCBuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQXVkaW9Ob2RlLCBfZXZlbnRUYXJnZXRDb25zdHJ1Y3QpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF1ZGlvTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwiY2hhbm5lbENvdW50XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Ob2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNoYW5uZWxDb3VudE1vZGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50TW9kZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjaGFubmVsSW50ZXJwcmV0YXRpb25cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb05vZGUuY2hhbm5lbEludGVycHJldGF0aW9uO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY29udGV4dFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm51bWJlck9mSW5wdXRzXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Ob2RlLm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJudW1iZXJPZk91dHB1dHNcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb05vZGUubnVtYmVyT2ZPdXRwdXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6aW52YWxpZC12b2lkXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICAgICAgLy8gQnVnICMxNzQ6IFNhZmFyaSBkb2VzIGV4cG9zZSBhIHdyb25nIG51bWJlck9mT3V0cHV0cyBmb3IgTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZXMuXG4gICAgICAgICAgICBpZiAob3V0cHV0IDwgMCB8fCBvdXRwdXQgPj0gdGhpcy5fbmF0aXZlQXVkaW9Ob2RlLm51bWJlck9mT3V0cHV0cykge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KHRoaXMuX2NvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpc05hdGl2ZUF1ZGlvTm9kZShkZXN0aW5hdGlvbikgfHwgaXNOYXRpdmVBdWRpb1BhcmFtKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0F1ZGlvTm9kZShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgdmFyIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3ROYXRpdmVBdWRpb05vZGVUb05hdGl2ZUF1ZGlvTm9kZSh0aGlzLl9uYXRpdmVBdWRpb05vZGUsIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNQYXNzaXZlID0gaXNQYXNzaXZlQXVkaW9Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChpc09mZmxpbmUgfHwgaXNQYXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX25hdGl2ZUF1ZGlvTm9kO1xuICAgICAgICAgICAgICAgICAgKF90aGlzJF9uYXRpdmVBdWRpb05vZCA9IHRoaXMuX25hdGl2ZUF1ZGlvTm9kZSkuZGlzY29ubmVjdC5hcHBseShfdGhpcyRfbmF0aXZlQXVkaW9Ob2QsIF90b0NvbnN1bWFibGVBcnJheShjb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RhdGUgIT09ICdjbG9zZWQnICYmICFpc1Bhc3NpdmUgJiYgaXNQYXNzaXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvQWN0aXZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIEJ1ZyAjNDE6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyB0aGUgY29ycmVjdCBleGNlcHRpb24gc28gZmFyLlxuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGlzTmV3Q29ubmVjdGlvblRvQXVkaW9Ob2RlID0gYWRkQ29ubmVjdGlvblRvQXVkaW9Ob2RlKHRoaXMsIGRlc3RpbmF0aW9uLCBvdXRwdXQsIGlucHV0LCBpc09mZmxpbmUpO1xuICAgICAgICAgICAgICAvLyBCdWcgIzE2NDogT25seSBGaXJlZm94IGRldGVjdHMgY3ljbGVzIHNvIGZhci5cbiAgICAgICAgICAgICAgaWYgKGlzTmV3Q29ubmVjdGlvblRvQXVkaW9Ob2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN5Y2xlcyA9IGRldGVjdEN5Y2xlcyhbdGhpc10sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICB2aXNpdEVhY2hBdWRpb05vZGVPbmNlKGN5Y2xlcywgY3JlYXRlSW5jcmVtZW50Q3ljbGVDb3VudGVyKGlzT2ZmbGluZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYXRpdmVBdWRpb1BhcmFtID0gZ2V0TmF0aXZlQXVkaW9QYXJhbShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQnVnICM3MywgIzE0NyAmICMxNTM6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHRvIGNvbm5lY3QgYW4gaW5wdXQgc2lnbmFsIHRvIHRoZSBwbGF5YmFja1JhdGUgQXVkaW9QYXJhbSBvZiBhblxuICAgICAgICAgICAgICogQXVkaW9CdWZmZXJTb3VyY2VOb2RlLiBUaGlzIGNhbid0IGJlIGVhc2lseSBkZXRlY3RlZCBhbmQgdGhhdCdzIHdoeSB0aGUgb3V0ZGF0ZWQgbmFtZSBwcm9wZXJ0eSBpcyB1c2VkIGhlcmUgdG8gaWRlbnRpZnlcbiAgICAgICAgICAgICAqIFNhZmFyaS4gSW4gYWRkaXRpb24gdG8gdGhhdCB0aGUgbWF4VmFsdWUgcHJvcGVydHkgaXMgdXNlZCB0byBvbmx5IGRldGVjdCB0aGUgYWZmZWN0ZWQgdmVyc2lvbnMgYmVsb3cgdjE0LjAuMi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvUGFyYW0ubmFtZSA9PT0gJ3BsYXliYWNrUmF0ZScgJiYgbmF0aXZlQXVkaW9QYXJhbS5tYXhWYWx1ZSA9PT0gMTAyNCkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlQXVkaW9Ob2RlLmNvbm5lY3QobmF0aXZlQXVkaW9QYXJhbSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSB8fCBpc1Bhc3NpdmVBdWRpb05vZGUodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb05vZGUuZGlzY29ubmVjdChuYXRpdmVBdWRpb1BhcmFtLCBvdXRwdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgLy8gQnVnICM1ODogU2FmYXJpIGRvZXNuJ3QgdGhyb3cgYW4gSW52YWxpZEFjY2Vzc0Vycm9yIHlldC5cbiAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAxMikge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc05ld0Nvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0gPSBhZGRDb25uZWN0aW9uVG9BdWRpb1BhcmFtT2ZBdWRpb0NvbnRleHQodGhpcywgZGVzdGluYXRpb24sIG91dHB1dCwgaXNPZmZsaW5lKTtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTY0OiBPbmx5IEZpcmVmb3ggZGV0ZWN0cyBjeWNsZXMgc28gZmFyLlxuICAgICAgICAgICAgaWYgKGlzTmV3Q29ubmVjdGlvblRvQXVkaW9QYXJhbSkge1xuICAgICAgICAgICAgICB2YXIgX2N5Y2xlcyA9IGRldGVjdEN5Y2xlcyhbdGhpc10sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgdmlzaXRFYWNoQXVkaW9Ob2RlT25jZShfY3ljbGVzLCBjcmVhdGVJbmNyZW1lbnRDeWNsZUNvdW50ZXIoaXNPZmZsaW5lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdChkZXN0aW5hdGlvbk9yT3V0cHV0LCBvdXRwdXQsIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb25zO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KHRoaXMuX2NvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25zID0gZGVsZXRlQW55Q29ubmVjdGlvbih0aGlzLCBpc09mZmxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck91dHB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JPdXRwdXQgPCAwIHx8IGRlc3RpbmF0aW9uT3JPdXRwdXQgPj0gdGhpcy5udW1iZXJPZk91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9ucyA9IGRlbGV0ZUNvbm5lY3Rpb25BdE91dHB1dCh0aGlzLCBpc09mZmxpbmUsIGRlc3RpbmF0aW9uT3JPdXRwdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkICYmIChvdXRwdXQgPCAwIHx8IG91dHB1dCA+PSB0aGlzLm51bWJlck9mT3V0cHV0cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0F1ZGlvTm9kZShkZXN0aW5hdGlvbk9yT3V0cHV0KSAmJiBpbnB1dCAhPT0gdW5kZWZpbmVkICYmIChpbnB1dCA8IDAgfHwgaW5wdXQgPj0gZGVzdGluYXRpb25Pck91dHB1dC5udW1iZXJPZklucHV0cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9ucyA9IGRlbGV0ZUNvbm5lY3Rpb25Ub0Rlc3RpbmF0aW9uKHRoaXMsIGlzT2ZmbGluZSwgZGVzdGluYXRpb25Pck91dHB1dCwgb3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjMTY0OiBPbmx5IEZpcmVmb3ggZGV0ZWN0cyBjeWNsZXMgc28gZmFyLlxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KGRlc3RpbmF0aW9ucyksXG4gICAgICAgICAgICAgIF9zdGVwMztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBjeWNsZXMgPSBkZXRlY3RDeWNsZXMoW3RoaXNdLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgdmlzaXRFYWNoQXVkaW9Ob2RlT25jZShjeWNsZXMsIGRlY3JlbWVudEN5Y2xlQ291bnRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShldmVudFRhcmdldENvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUF1ZGlvUGFyYW1GYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9QYXJhbUZhY3RvcnkoYWRkQXVkaW9QYXJhbUNvbm5lY3Rpb25zLCBhdWRpb1BhcmFtQXVkaW9Ob2RlU3RvcmUsIGF1ZGlvUGFyYW1TdG9yZSwgY3JlYXRlQXVkaW9QYXJhbVJlbmRlcmVyLCBjcmVhdGVDYW5jZWxBbmRIb2xkQXV0b21hdGlvbkV2ZW50LCBjcmVhdGVDYW5jZWxTY2hlZHVsZWRWYWx1ZXNBdXRvbWF0aW9uRXZlbnQsIGNyZWF0ZUV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdXRvbWF0aW9uRXZlbnQsIGNyZWF0ZUxpbmVhclJhbXBUb1ZhbHVlQXV0b21hdGlvbkV2ZW50LCBjcmVhdGVTZXRUYXJnZXRBdXRvbWF0aW9uRXZlbnQsIGNyZWF0ZVNldFZhbHVlQXV0b21hdGlvbkV2ZW50LCBjcmVhdGVTZXRWYWx1ZUN1cnZlQXV0b21hdGlvbkV2ZW50LCBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvciwgc2V0VmFsdWVBdFRpbWVVbnRpbFBvc3NpYmxlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvTm9kZSwgaXNBdWRpb1BhcmFtT2ZPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1BhcmFtKSB7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgICAgdmFyIG1pblZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuICAgICAgICAvLyBCdWcgIzE5NiBPbmx5IFNhZmFyaSBzZXRzIHRoZSBkZWZhdWx0VmFsdWUgdG8gdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBuYXRpdmVBdWRpb1BhcmFtLnZhbHVlO1xuICAgICAgICB2YXIgYXV0b21hdGlvbkV2ZW50TGlzdCA9IG5ldyBhdXRvbWF0aW9uRXZlbnRzLkF1dG9tYXRpb25FdmVudExpc3QoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgdmFyIGF1ZGlvUGFyYW1SZW5kZXJlciA9IGlzQXVkaW9QYXJhbU9mT2ZmbGluZUF1ZGlvQ29udGV4dCA/IGNyZWF0ZUF1ZGlvUGFyYW1SZW5kZXJlcihhdXRvbWF0aW9uRXZlbnRMaXN0KSA6IG51bGw7XG4gICAgICAgIHZhciBhdWRpb1BhcmFtID0ge1xuICAgICAgICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heFZhbHVlID09PSBudWxsID8gbmF0aXZlQXVkaW9QYXJhbS5tYXhWYWx1ZSA6IG1heFZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pblZhbHVlID09PSBudWxsID8gbmF0aXZlQXVkaW9QYXJhbS5taW5WYWx1ZSA6IG1pblZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUF1ZGlvUGFyYW0udmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIEJ1ZyAjOTg6IEZpcmVmb3ggJiBTYWZhcmkgZG8gbm90IHlldCB0cmVhdCB0aGUgdmFsdWUgc2V0dGVyIGxpa2UgYSBjYWxsIHRvIHNldFZhbHVlQXRUaW1lKCkuXG4gICAgICAgICAgICBhdWRpb1BhcmFtLnNldFZhbHVlQXRUaW1lKHZhbHVlLCBhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBbmRIb2xkQXRUaW1lOiBmdW5jdGlvbiBjYW5jZWxBbmRIb2xkQXRUaW1lKGNhbmNlbFRpbWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMjg6IEZpcmVmb3ggJiBTYWZhcmkgZG8gbm90IHlldCBpbXBsZW1lbnQgY2FuY2VsQW5kSG9sZEF0VGltZSgpLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYXRpdmVBdWRpb1BhcmFtLmNhbmNlbEFuZEhvbGRBdFRpbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvUGFyYW1SZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuZmx1c2goYXVkaW9Ob2RlLmNvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuYWRkKGNyZWF0ZUNhbmNlbEFuZEhvbGRBdXRvbWF0aW9uRXZlbnQoY2FuY2VsVGltZSkpO1xuICAgICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLmNhbmNlbEFuZEhvbGRBdFRpbWUoY2FuY2VsVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldmlvdXNMYXN0RXZlbnQgPSBBcnJheS5mcm9tKGF1dG9tYXRpb25FdmVudExpc3QpLnBvcCgpO1xuICAgICAgICAgICAgICBpZiAoYXVkaW9QYXJhbVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5mbHVzaChhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlQ2FuY2VsQW5kSG9sZEF1dG9tYXRpb25FdmVudChjYW5jZWxUaW1lKSk7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50TGFzdEV2ZW50ID0gQXJyYXkuZnJvbShhdXRvbWF0aW9uRXZlbnRMaXN0KS5wb3AoKTtcbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoY2FuY2VsVGltZSk7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c0xhc3RFdmVudCAhPT0gY3VycmVudExhc3RFdmVudCAmJiBjdXJyZW50TGFzdEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExhc3RFdmVudC50eXBlID09PSAnZXhwb25lbnRpYWxSYW1wVG9WYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZShjdXJyZW50TGFzdEV2ZW50LnZhbHVlLCBjdXJyZW50TGFzdEV2ZW50LmVuZFRpbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudExhc3RFdmVudC50eXBlID09PSAnbGluZWFyUmFtcFRvVmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGN1cnJlbnRMYXN0RXZlbnQudmFsdWUsIGN1cnJlbnRMYXN0RXZlbnQuZW5kVGltZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGFzdEV2ZW50LnR5cGUgPT09ICdzZXRWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUoY3VycmVudExhc3RFdmVudC52YWx1ZSwgY3VycmVudExhc3RFdmVudC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudExhc3RFdmVudC50eXBlID09PSAnc2V0VmFsdWVDdXJ2ZScpIHtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uc2V0VmFsdWVDdXJ2ZUF0VGltZShjdXJyZW50TGFzdEV2ZW50LnZhbHVlcywgY3VycmVudExhc3RFdmVudC5zdGFydFRpbWUsIGN1cnJlbnRMYXN0RXZlbnQuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxTY2hlZHVsZWRWYWx1ZXM6IGZ1bmN0aW9uIGNhbmNlbFNjaGVkdWxlZFZhbHVlcyhjYW5jZWxUaW1lKSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9QYXJhbVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuZmx1c2goYXVkaW9Ob2RlLmNvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlQ2FuY2VsU2NoZWR1bGVkVmFsdWVzQXV0b21hdGlvbkV2ZW50KGNhbmNlbFRpbWUpKTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGNhbmNlbFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lOiBmdW5jdGlvbiBleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBlbmRUaW1lKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzQ1OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgeWV0LlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWcgIzE4NzogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHlldC5cbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVuZFRpbWUpIHx8IGVuZFRpbWUgPCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIGlmIChhdWRpb1BhcmFtUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5mbHVzaChjdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWcgIzE5NDogRmlyZWZveCBkb2VzIG5vdCBpbXBsaWNpdGx5IGNhbGwgc2V0VmFsdWVBdFRpbWUoKSBpZiB0aGVyZSBpcyBubyBwcmV2aW91cyBldmVudC5cbiAgICAgICAgICAgIGlmIChBcnJheS5mcm9tKGF1dG9tYXRpb25FdmVudExpc3QpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmFkZChjcmVhdGVTZXRWYWx1ZUF1dG9tYXRpb25FdmVudChkZWZhdWx0VmFsdWUsIGN1cnJlbnRUaW1lKSk7XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUoZGVmYXVsdFZhbHVlLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmFkZChjcmVhdGVFeHBvbmVudGlhbFJhbXBUb1ZhbHVlQXV0b21hdGlvbkV2ZW50KHZhbHVlLCBlbmRUaW1lKSk7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZTogZnVuY3Rpb24gbGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgaWYgKGF1ZGlvUGFyYW1SZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmZsdXNoKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjMTk1OiBGaXJlZm94IGRvZXMgbm90IGltcGxpY2l0bHkgY2FsbCBzZXRWYWx1ZUF0VGltZSgpIGlmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGV2ZW50LlxuICAgICAgICAgICAgaWYgKEFycmF5LmZyb20oYXV0b21hdGlvbkV2ZW50TGlzdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuYWRkKGNyZWF0ZVNldFZhbHVlQXV0b21hdGlvbkV2ZW50KGRlZmF1bHRWYWx1ZSwgY3VycmVudFRpbWUpKTtcbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5zZXRWYWx1ZUF0VGltZShkZWZhdWx0VmFsdWUsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuYWRkKGNyZWF0ZUxpbmVhclJhbXBUb1ZhbHVlQXV0b21hdGlvbkV2ZW50KHZhbHVlLCBlbmRUaW1lKSk7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBlbmRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb1BhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0VGFyZ2V0QXRUaW1lOiBmdW5jdGlvbiBzZXRUYXJnZXRBdFRpbWUodGFyZ2V0LCBzdGFydFRpbWUsIHRpbWVDb25zdGFudCkge1xuICAgICAgICAgICAgaWYgKGF1ZGlvUGFyYW1SZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmZsdXNoKGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuYWRkKGNyZWF0ZVNldFRhcmdldEF1dG9tYXRpb25FdmVudCh0YXJnZXQsIHN0YXJ0VGltZSwgdGltZUNvbnN0YW50KSk7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSh0YXJnZXQsIHN0YXJ0VGltZSwgdGltZUNvbnN0YW50KTtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb1BhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0VmFsdWVBdFRpbWU6IGZ1bmN0aW9uIHNldFZhbHVlQXRUaW1lKHZhbHVlLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1BhcmFtUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5mbHVzaChhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmFkZChjcmVhdGVTZXRWYWx1ZUF1dG9tYXRpb25FdmVudCh2YWx1ZSwgc3RhcnRUaW1lKSk7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLnNldFZhbHVlQXRUaW1lKHZhbHVlLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRWYWx1ZUN1cnZlQXRUaW1lOiBmdW5jdGlvbiBzZXRWYWx1ZUN1cnZlQXRUaW1lKHZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gQnVnIDE4MzogU2FmYXJpIG9ubHkgYWNjZXB0cyBhIEZsb2F0MzJBcnJheS5cbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRWYWx1ZXMgPSB2YWx1ZXMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyB2YWx1ZXMgOiBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcyk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQnVnICMxNTI6IFNhZmFyaSBkb2VzIG5vdCBjb3JyZWN0bHkgaW50ZXJwb2xhdGUgdGhlIHZhbHVlcyBvZiB0aGUgY3VydmUuXG4gICAgICAgICAgICAgKiBAdG9kbyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGlzIG5vIHdheSB0byB0ZXN0IGZvciB0aGlzIGJlaGF2aW9yIGluIGEgc3luY2hyb25vdXMgZmFzaGlvbiB3aGljaCBpcyB3aHkgdGVzdGluZyBmb3IgdGhlXG4gICAgICAgICAgICAgKiBleGlzdGVuY2Ugb2YgdGhlIHdlYmtpdEF1ZGlvQ29udGV4dCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBoZXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgIT09IG51bGwgJiYgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IubmFtZSA9PT0gJ3dlYmtpdEF1ZGlvQ29udGV4dCcpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSBhdWRpb05vZGUuY29udGV4dC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgICB2YXIgZmlyc3RTYW1wbGUgPSBNYXRoLmNlaWwoc3RhcnRUaW1lICogc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgIHZhciBsYXN0U2FtcGxlID0gTWF0aC5mbG9vcihlbmRUaW1lICogc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgIHZhciBudW1iZXJPZkludGVycG9sYXRlZFZhbHVlcyA9IGxhc3RTYW1wbGUgLSBmaXJzdFNhbXBsZTtcbiAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRlZFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtYmVyT2ZJbnRlcnBvbGF0ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mSW50ZXJwb2xhdGVkVmFsdWVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlb3JldGljSW5kZXggPSAoY29udmVydGVkVmFsdWVzLmxlbmd0aCAtIDEpIC8gZHVyYXRpb24gKiAoKGZpcnN0U2FtcGxlICsgaSkgLyBzYW1wbGVSYXRlIC0gc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXJJbmRleCA9IE1hdGguZmxvb3IodGhlb3JldGljSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciB1cHBlckluZGV4ID0gTWF0aC5jZWlsKHRoZW9yZXRpY0luZGV4KTtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRWYWx1ZXNbaV0gPSBsb3dlckluZGV4ID09PSB1cHBlckluZGV4ID8gY29udmVydGVkVmFsdWVzW2xvd2VySW5kZXhdIDogKDEgLSAodGhlb3JldGljSW5kZXggLSBsb3dlckluZGV4KSkgKiBjb252ZXJ0ZWRWYWx1ZXNbbG93ZXJJbmRleF0gKyAoMSAtICh1cHBlckluZGV4IC0gdGhlb3JldGljSW5kZXgpKSAqIGNvbnZlcnRlZFZhbHVlc1t1cHBlckluZGV4XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXVkaW9QYXJhbVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5mbHVzaChhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlU2V0VmFsdWVDdXJ2ZUF1dG9tYXRpb25FdmVudChpbnRlcnBvbGF0ZWRWYWx1ZXMsIHN0YXJ0VGltZSwgZHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5zZXRWYWx1ZUN1cnZlQXRUaW1lKGludGVycG9sYXRlZFZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgIHZhciB0aW1lT2ZMYXN0U2FtcGxlID0gbGFzdFNhbXBsZSAvIHNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgIGlmICh0aW1lT2ZMYXN0U2FtcGxlIDwgZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlQXRUaW1lVW50aWxQb3NzaWJsZShhdWRpb1BhcmFtLCBpbnRlcnBvbGF0ZWRWYWx1ZXNbaW50ZXJwb2xhdGVkVmFsdWVzLmxlbmd0aCAtIDFdLCB0aW1lT2ZMYXN0U2FtcGxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRWYWx1ZUF0VGltZVVudGlsUG9zc2libGUoYXVkaW9QYXJhbSwgY29udmVydGVkVmFsdWVzW2NvbnZlcnRlZFZhbHVlcy5sZW5ndGggLSAxXSwgZW5kVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9QYXJhbVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5mbHVzaChhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlU2V0VmFsdWVDdXJ2ZUF1dG9tYXRpb25FdmVudChjb252ZXJ0ZWRWYWx1ZXMsIHN0YXJ0VGltZSwgZHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5zZXRWYWx1ZUN1cnZlQXRUaW1lKGNvbnZlcnRlZFZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9QYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGF1ZGlvUGFyYW1TdG9yZS5zZXQoYXVkaW9QYXJhbSwgbmF0aXZlQXVkaW9QYXJhbSk7XG4gICAgICAgIGF1ZGlvUGFyYW1BdWRpb05vZGVTdG9yZS5zZXQoYXVkaW9QYXJhbSwgYXVkaW9Ob2RlKTtcbiAgICAgICAgYWRkQXVkaW9QYXJhbUNvbm5lY3Rpb25zKGF1ZGlvUGFyYW0sIGF1ZGlvUGFyYW1SZW5kZXJlcik7XG4gICAgICAgIHJldHVybiBhdWRpb1BhcmFtO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkNShyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIGNyZWF0ZUF1ZGlvUGFyYW1SZW5kZXJlciA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvUGFyYW1SZW5kZXJlcihhdXRvbWF0aW9uRXZlbnRMaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXBsYXk6IGZ1bmN0aW9uIHJlcGxheShhdWRpb1BhcmFtKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoYXV0b21hdGlvbkV2ZW50TGlzdCksXG4gICAgICAgICAgICBfc3RlcDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGF1dG9tYXRpb25FdmVudCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoYXV0b21hdGlvbkV2ZW50LnR5cGUgPT09ICdleHBvbmVudGlhbFJhbXBUb1ZhbHVlJykge1xuICAgICAgICAgICAgICAgIHZhciBlbmRUaW1lID0gYXV0b21hdGlvbkV2ZW50LmVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9tYXRpb25FdmVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBhdWRpb1BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1dG9tYXRpb25FdmVudC50eXBlID09PSAnbGluZWFyUmFtcFRvVmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbmRUaW1lID0gYXV0b21hdGlvbkV2ZW50LmVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICBfdmFsdWUgPSBhdXRvbWF0aW9uRXZlbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgYXVkaW9QYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfdmFsdWUsIF9lbmRUaW1lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdXRvbWF0aW9uRXZlbnQudHlwZSA9PT0gJ3NldFRhcmdldCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gYXV0b21hdGlvbkV2ZW50LnN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGF1dG9tYXRpb25FdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICB0aW1lQ29uc3RhbnQgPSBhdXRvbWF0aW9uRXZlbnQudGltZUNvbnN0YW50O1xuICAgICAgICAgICAgICAgIGF1ZGlvUGFyYW0uc2V0VGFyZ2V0QXRUaW1lKHRhcmdldCwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1dG9tYXRpb25FdmVudC50eXBlID09PSAnc2V0VmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zdGFydFRpbWUgPSBhdXRvbWF0aW9uRXZlbnQuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgX3ZhbHVlMiA9IGF1dG9tYXRpb25FdmVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBhdWRpb1BhcmFtLnNldFZhbHVlQXRUaW1lKF92YWx1ZTIsIF9zdGFydFRpbWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1dG9tYXRpb25FdmVudC50eXBlID09PSAnc2V0VmFsdWVDdXJ2ZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBhdXRvbWF0aW9uRXZlbnQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICBfc3RhcnRUaW1lMiA9IGF1dG9tYXRpb25FdmVudC5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBhdXRvbWF0aW9uRXZlbnQudmFsdWVzO1xuICAgICAgICAgICAgICAgIGF1ZGlvUGFyYW0uc2V0VmFsdWVDdXJ2ZUF0VGltZSh2YWx1ZXMsIF9zdGFydFRpbWUyLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXBwbHkgYW4gdW5rbm93biBhdXRvbWF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBSZWFkT25seU1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZWFkT25seU1hcChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFkT25seU1hcCk7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAocGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlYWRPbmx5TWFwLCBbe1xuICAgICAgICBrZXk6IFwic2l6ZVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVudHJpZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZvckVhY2hcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgX3RoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImhhc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwia2V5c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkdChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCR0KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkdChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkdChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkbSh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG0oKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJGggPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICAvLyBCdWcgIzYxOiBUaGUgY2hhbm5lbENvdW50TW9kZSBzaG91bGQgYmUgJ21heCcgYWNjb3JkaW5nIHRvIHRoZSBzcGVjIGJ1dCBpcyBzZXQgdG8gJ2V4cGxpY2l0JyB0byBhY2hpZXZlIGNvbnNpc3RlbnQgYmVoYXZpb3IuXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgbnVtYmVyT2ZJbnB1dHM6IDEsXG4gICAgICBudW1iZXJPZk91dHB1dHM6IDEsXG4gICAgICBwYXJhbWV0ZXJEYXRhOiB7fSxcbiAgICAgIHByb2Nlc3Nvck9wdGlvbnM6IHt9XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKGFkZFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlLCBhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlLCBnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0QmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIHNhbml0aXplQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMsIHNldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMsIHRlc3RBdWRpb1dvcmtsZXROb2RlT3B0aW9uc0Nsb25hYmlsaXR5LCB3cmFwRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvV29ya2xldE5vZGUoY29udGV4dCwgbmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9Xb3JrbGV0Tm9kZSk7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gc2FuaXRpemVBdWRpb1dvcmtsZXROb2RlT3B0aW9ucyhfb2JqZWN0U3ByZWFkJHQoX29iamVjdFNwcmVhZCR0KHt9LCBERUZBVUxUX09QVElPTlMkaCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAvLyBCdWcgIzE5MTogU2FmYXJpIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG9wdGlvbnMgYXJlbid0IGNsb25hYmxlLlxuICAgICAgICAgIHRlc3RBdWRpb1dvcmtsZXROb2RlT3B0aW9uc0Nsb25hYmlsaXR5KG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBub2RlTmFtZVRvUHJvY2Vzc29yQ29uc3RydWN0b3JNYXAgPSBOT0RFX05BTUVfVE9fUFJPQ0VTU09SX0NPTlNUUlVDVE9SX01BUFMuZ2V0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBwcm9jZXNzb3JDb25zdHJ1Y3RvciA9IG5vZGVOYW1lVG9Qcm9jZXNzb3JDb25zdHJ1Y3Rvck1hcCA9PT0gbnVsbCB8fCBub2RlTmFtZVRvUHJvY2Vzc29yQ29uc3RydWN0b3JNYXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVOYW1lVG9Qcm9jZXNzb3JDb25zdHJ1Y3Rvck1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgLy8gQnVnICMxODY6IENocm9tZSBhbmQgRWRnZSBkbyBub3QgYWxsb3cgdG8gY3JlYXRlIGFuIEF1ZGlvV29ya2xldE5vZGUgb24gYSBjbG9zZWQgQXVkaW9Db250ZXh0LlxuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0T3JCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0ID0gaXNPZmZsaW5lIHx8IG5hdGl2ZUNvbnRleHQuc3RhdGUgIT09ICdjbG9zZWQnID8gbmF0aXZlQ29udGV4dCA6IChfYSA9IGdldEJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5hdGl2ZUNvbnRleHQ7XG4gICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUgPSBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlKG5hdGl2ZUNvbnRleHRPckJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQsIGlzT2ZmbGluZSA/IG51bGwgOiBjb250ZXh0LmJhc2VMYXRlbmN5LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5hbWUsIHByb2Nlc3NvckNvbnN0cnVjdG9yLCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgYXVkaW9Xb3JrbGV0Tm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZVJlbmRlcmVyKG5hbWUsIG1lcmdlZE9wdGlvbnMsIHByb2Nlc3NvckNvbnN0cnVjdG9yKSA6IG51bGw7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBAdG9kbyBBZGQgYSBtZWNoYW5pc20gdG8gc3dpdGNoIGFuIEF1ZGlvV29ya2xldE5vZGUgdG8gcGFzc2l2ZSBvbmNlIHRoZSBwcm9jZXNzKCkgZnVuY3Rpb24gb2YgdGhlIEF1ZGlvV29ya2xldFByb2Nlc3NvclxuICAgICAgICAgICAqIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJG0odGhpcywgQXVkaW9Xb3JrbGV0Tm9kZSwgW2NvbnRleHQsIHRydWUsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIGF1ZGlvV29ya2xldE5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKG5hdGl2ZUF1ZGlvUGFyYW0sIG5tKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9QYXJhbSA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlQXVkaW9QYXJhbSk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goW25tLCBhdWRpb1BhcmFtXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUF1ZGlvV29ya2xldE5vZGUgPSBuYXRpdmVBdWRpb1dvcmtsZXROb2RlO1xuICAgICAgICAgIF90aGlzLl9vbnByb2Nlc3NvcmVycm9yID0gbnVsbDtcbiAgICAgICAgICBfdGhpcy5fcGFyYW1ldGVycyA9IG5ldyBSZWFkT25seU1hcChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEJ1ZyAjODYgJiAjODc6IEludm9raW5nIHRoZSByZW5kZXJlciBvZiBhbiBBdWRpb1dvcmtsZXROb2RlIG1pZ2h0IGJlIG5lY2Vzc2FyeSBpZiBpdCBoYXMgbm8gZGlyZWN0IG9yIGluZGlyZWN0IGNvbm5lY3Rpb24gdG9cbiAgICAgICAgICAgKiB0aGUgZGVzdGluYXRpb24uXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKGlzT2ZmbGluZSkge1xuICAgICAgICAgICAgYWRkVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUobmF0aXZlQ29udGV4dCwgX3RoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX2dldEF1ZGlvTm9kZUNvbm5lY3RpID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoX3RoaXMpLFxuICAgICAgICAgICAgYWN0aXZlSW5wdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpLmFjdGl2ZUlucHV0cztcbiAgICAgICAgICBzZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIGFjdGl2ZUlucHV0cyk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhBdWRpb1dvcmtsZXROb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF1ZGlvV29ya2xldE5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcIm9ucHJvY2Vzc29yZXJyb3JcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbnByb2Nlc3NvcmVycm9yO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkTGlzdGVuZXIgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwRXZlbnRMaXN0ZW5lcih0aGlzLCB2YWx1ZSkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5vbnByb2Nlc3NvcmVycm9yID0gd3JhcHBlZExpc3RlbmVyO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU9uUHJvY2Vzc29yRXJyb3IgPSB0aGlzLl9uYXRpdmVBdWRpb1dvcmtsZXROb2RlLm9ucHJvY2Vzc29yZXJyb3I7XG4gICAgICAgICAgICB0aGlzLl9vbnByb2Nlc3NvcmVycm9yID0gbmF0aXZlT25Qcm9jZXNzb3JFcnJvciAhPT0gbnVsbCAmJiBuYXRpdmVPblByb2Nlc3NvckVycm9yID09PSB3cmFwcGVkTGlzdGVuZXIgPyB2YWx1ZSA6IG5hdGl2ZU9uUHJvY2Vzc29yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInBhcmFtZXRlcnNcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJhbWV0ZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIEB0b2RvIFRoZSBkZWZpbml0aW9uIHRoYXQgVHlwZVNjcmlwdCB1c2VzIG9mIHRoZSBBdWRpb1BhcmFtTWFwIGlzIGxhY2tpbmcgbWFueSBtZXRob2RzLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInBvcnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb1dvcmtsZXROb2RlLnBvcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29weUZyb21DaGFubmVsKGF1ZGlvQnVmZmVyLFxuICAgIC8vIEB0b2RvIFRoZXJlIGlzIGN1cnJlbnRseSBubyB3YXkgdG8gZGVmaW5lIHNvbWV0aGluZyBsaWtlIHsgWyBrZXk6IG51bWJlciB8IHN0cmluZyBdOiBGbG9hdDMyQXJyYXkgfVxuICAgIHBhcmVudCwga2V5LCBjaGFubmVsTnVtYmVyLCBidWZmZXJPZmZzZXQpIHtcbiAgICAgIGlmICh0eXBlb2YgYXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRoZSBieXRlTGVuZ3RoIHdpbGwgYmUgMCB3aGVuIHRoZSBBcnJheUJ1ZmZlciB3YXMgdHJhbnNmZXJyZWQuXG4gICAgICAgIGlmIChwYXJlbnRba2V5XS5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcGFyZW50W2tleV0gPSBuZXcgRmxvYXQzMkFycmF5KDEyOCk7XG4gICAgICAgIH1cbiAgICAgICAgYXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsKHBhcmVudFtrZXldLCBjaGFubmVsTnVtYmVyLCBidWZmZXJPZmZzZXQpO1xuICAgICAgICAvLyBCdWcgIzU6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IGNvcHlGcm9tQ2hhbm5lbCgpLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbE51bWJlcik7XG4gICAgICAgIC8vIFRoZSBieXRlTGVuZ3RoIHdpbGwgYmUgMCB3aGVuIHRoZSBBcnJheUJ1ZmZlciB3YXMgdHJhbnNmZXJyZWQuXG4gICAgICAgIGlmIChwYXJlbnRba2V5XS5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcGFyZW50W2tleV0gPSBjaGFubmVsRGF0YS5zbGljZShidWZmZXJPZmZzZXQsIGJ1ZmZlck9mZnNldCArIDEyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNsaWNlZElucHV0ID0gbmV3IEZsb2F0MzJBcnJheShjaGFubmVsRGF0YS5idWZmZXIsIGJ1ZmZlck9mZnNldCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMTI4KTtcbiAgICAgICAgICBwYXJlbnRba2V5XS5zZXQoc2xpY2VkSW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvcHlUb0NoYW5uZWwgPSBmdW5jdGlvbiBjb3B5VG9DaGFubmVsKGF1ZGlvQnVmZmVyLCBwYXJlbnQsIGtleSwgY2hhbm5lbE51bWJlciwgYnVmZmVyT2Zmc2V0KSB7XG4gICAgICBpZiAodHlwZW9mIGF1ZGlvQnVmZmVyLmNvcHlUb0NoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVGhlIGJ5dGVMZW5ndGggd2lsbCBiZSAwIHdoZW4gdGhlIEFycmF5QnVmZmVyIHdhcyB0cmFuc2ZlcnJlZC5cbiAgICAgICAgaWYgKHBhcmVudFtrZXldLmJ5dGVMZW5ndGggIT09IDApIHtcbiAgICAgICAgICBhdWRpb0J1ZmZlci5jb3B5VG9DaGFubmVsKHBhcmVudFtrZXldLCBjaGFubmVsTnVtYmVyLCBidWZmZXJPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY29weVRvQ2hhbm5lbCgpLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGJ5dGVMZW5ndGggd2lsbCBiZSAwIHdoZW4gdGhlIEFycmF5QnVmZmVyIHdhcyB0cmFuc2ZlcnJlZC5cbiAgICAgICAgaWYgKHBhcmVudFtrZXldLmJ5dGVMZW5ndGggIT09IDApIHtcbiAgICAgICAgICBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsTnVtYmVyKS5zZXQocGFyZW50W2tleV0sIGJ1ZmZlck9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5lc3RlZEFycmF5cyA9IGZ1bmN0aW9uIGNyZWF0ZU5lc3RlZEFycmF5cyh4LCB5KSB7XG4gICAgICB2YXIgYXJyYXlzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHR5cGVvZiB5ID09PSAnbnVtYmVyJyA/IHkgOiB5W2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChuZXcgRmxvYXQzMkFycmF5KDEyOCkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5cy5wdXNoKGFycmF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheXM7XG4gICAgfTtcblxuICAgIHZhciBnZXRBdWRpb1dvcmtsZXRQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRBdWRpb1dvcmtsZXRQcm9jZXNzb3IobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkpIHtcbiAgICAgIHZhciBub2RlVG9Qcm9jZXNzb3JNYXAgPSBnZXRWYWx1ZUZvcktleShOT0RFX1RPX1BST0NFU1NPUl9NQVBTLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgIHZhciBuYXRpdmVBdWRpb1dvcmtsZXROb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTtcbiAgICAgIHJldHVybiBnZXRWYWx1ZUZvcktleShub2RlVG9Qcm9jZXNzb3JNYXAsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KHIsIGUpIHsgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIXQpIHsgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChyKSkgfHwgZSkgeyB0ICYmIChyID0gdCk7IHZhciBfbiA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbiA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB0aHJvdyByOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBvLCBhID0gITAsIHUgPSAhMTsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgdCA9IHQuY2FsbChyKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHIgPSB0Lm5leHQoKTsgcmV0dXJuIGEgPSByLmRvbmUsIHI7IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB1ID0gITAsIG8gPSByOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmICh1KSB0aHJvdyBvOyB9IH0gfTsgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheSQ0KHIsIGEpIDogdm9pZCAwOyB9IH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ0KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbiAgICBmdW5jdGlvbiBvd25LZXlzJHMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkcyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJHMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJHMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgcHJvY2Vzc0J1ZmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgcmVuZGVyZWRCdWZmZXIsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMsIG91dHB1dENoYW5uZWxDb3VudCwgcHJvY2Vzc29yQ29uc3RydWN0b3IsIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHZhciBsZW5ndGgsIG51bWJlck9mSW5wdXRDaGFubmVscywgbnVtYmVyT2ZPdXRwdXRDaGFubmVscywgcHJvY2Vzc2VkQnVmZmVyLCBhdWRpb05vZGVDb25uZWN0aW9ucywgYXVkaW9Xb3JrbGV0UHJvY2Vzc29yLCBpbnB1dHMsIG91dHB1dHMsIHBhcmFtZXRlcnMsIF9sb29wLCBfcmV0LCBpO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8gQ2VpbCB0aGUgbGVuZ3RoIHRvIHRoZSBuZXh0IGZ1bGwgcmVuZGVyIHF1YW50dW0uXG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTc6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgZXhwb3NlIHRoZSBsZW5ndGguXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHJlbmRlcmVkQnVmZmVyID09PSBudWxsID8gTWF0aC5jZWlsKHByb3h5LmNvbnRleHQubGVuZ3RoIC8gMTI4KSAqIDEyOCA6IHJlbmRlcmVkQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dENoYW5uZWxzID0gb3B0aW9ucy5jaGFubmVsQ291bnQgKiBvcHRpb25zLm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgICAgICBudW1iZXJPZk91dHB1dENoYW5uZWxzID0gb3V0cHV0Q2hhbm5lbENvdW50LnJlZHVjZShmdW5jdGlvbiAoc3VtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyB2YWx1ZTtcbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgIHByb2Nlc3NlZEJ1ZmZlciA9IG51bWJlck9mT3V0cHV0Q2hhbm5lbHMgPT09IDAgPyBudWxsIDogbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIobnVtYmVyT2ZPdXRwdXRDaGFubmVscywgbGVuZ3RoLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICBpZiAoIShwcm9jZXNzb3JDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIHByb2Nlc3NvciBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgYXVkaW9Ob2RlQ29ubmVjdGlvbnMgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhwcm94eSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEF1ZGlvV29ya2xldFByb2Nlc3NvcihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eSk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGF1ZGlvV29ya2xldFByb2Nlc3NvciA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICBpbnB1dHMgPSBjcmVhdGVOZXN0ZWRBcnJheXMob3B0aW9ucy5udW1iZXJPZklucHV0cywgb3B0aW9ucy5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICBvdXRwdXRzID0gY3JlYXRlTmVzdGVkQXJyYXlzKG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzLCBvdXRwdXRDaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzID0gQXJyYXkuZnJvbShwcm94eS5wYXJhbWV0ZXJzLmtleXMoKSkucmVkdWNlKGZ1bmN0aW9uIChwcm10cnMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRzKF9vYmplY3RTcHJlYWQkcyh7fSwgcHJtdHJzKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgbmV3IEZsb2F0MzJBcnJheSgxMjgpKSk7XG4gICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgX2xvb3AgPSAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgaywgX2osIF9rLCBwb3RlbnRpYWxseUVtcHR5SW5wdXRzLCBhY3RpdmVTb3VyY2VGbGFnLCBfajIsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQsIF9rMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9sb29wJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm51bWJlck9mSW5wdXRzID4gMCAmJiByZW5kZXJlZEJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgb3B0aW9ucy5jaGFubmVsQ291bnQ7IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlGcm9tQ2hhbm5lbChyZW5kZXJlZEJ1ZmZlciwgaW5wdXRzW2pdLCBrLCBrLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMgIT09IHVuZGVmaW5lZCAmJiByZW5kZXJlZEJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUZyb21DaGFubmVsKHJlbmRlcmVkQnVmZmVyLCBwYXJhbWV0ZXJzLCBuYW1lLCBudW1iZXJPZklucHV0Q2hhbm5lbHMgKyBpbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChfaiA9IDA7IF9qIDwgb3B0aW9ucy5udW1iZXJPZklucHV0czsgX2ogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfayA9IDA7IF9rIDwgb3V0cHV0Q2hhbm5lbENvdW50W19qXTsgX2sgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYnl0ZUxlbmd0aCB3aWxsIGJlIDAgd2hlbiB0aGUgQXJyYXlCdWZmZXIgd2FzIHRyYW5zZmVycmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0c1tfal1bX2tdLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzW19qXVtfa10gPSBuZXcgRmxvYXQzMkFycmF5KDEyOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsbHlFbXB0eUlucHV0cyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvTm9kZUNvbm5lY3Rpb25zLmFjdGl2ZUlucHV0c1tpbmRleF0uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU291cmNlRmxhZyA9IGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lKGkgLyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvV29ya2xldFByb2Nlc3Nvci5wcm9jZXNzKHBvdGVudGlhbGx5RW1wdHlJbnB1dHMsIG91dHB1dHMsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRCdWZmZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2oyID0gMCwgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCA9IDA7IF9qMiA8IG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzOyBfajIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9rMiA9IDA7IF9rMiA8IG91dHB1dENoYW5uZWxDb3VudFtfajJdOyBfazIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlUb0NoYW5uZWwocHJvY2Vzc2VkQnVmZmVyLCBvdXRwdXRzW19qMl0sIF9rMiwgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArIF9rMiwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArPSBvdXRwdXRDaGFubmVsQ291bnRbX2oyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVNvdXJjZUZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgICAgICAgICAgICBwcm94eS5kaXNwYXRjaEV2ZW50KG5ldyBFcnJvckV2ZW50KCdwcm9jZXNzb3JlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG5vOiBfY29udGV4dC50MC5jb2xubyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBfY29udGV4dC50MC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVubzogX2NvbnRleHQudDAubGluZW5vLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogX2NvbnRleHQudDAubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIDApO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfbG9vcCwgbnVsbCwgW1szLCAxMV1dKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgaWYgKCEoaSA8IGxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZGVsZWdhdGVZaWVsZChfbG9vcChpKSwgXCJ0MFwiLCAxNyk7XG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBfcmV0ID0gX2NvbnRleHQyLnQwO1xuICAgICAgICAgICAgICBpZiAoIShfcmV0ID09PSAwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyMyk7XG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBpICs9IDEyODtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBwcm9jZXNzZWRCdWZmZXIpO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwcm9jZXNzQnVmZmVyKF94LCBfeDIsIF94MywgX3g0LCBfeDUsIF94NiwgX3g3KSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgICB2YXIgY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvV29ya2xldE5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNvbm5lY3RNdWx0aXBsZU91dHB1dHMsIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGRlbGV0ZVVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlLCBkaXNjb25uZWN0TXVsdGlwbGVPdXRwdXRzLCBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucywgcHJvY2Vzc29yQ29uc3RydWN0b3IpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBwcm9jZXNzZWRCdWZmZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdmFyIGNyZWF0ZUF1ZGlvTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNChwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIG5hdGl2ZU91dHB1dE5vZGVzLCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlSXNPd25lZEJ5Q29udGV4dCwgb3V0cHV0Q2hhbm5lbENvdW50LCBudW1iZXJPZk91dHB1dENoYW5uZWxzLCBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlLCBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXMsIGksIG91dHB1dEdhaW5Ob2RlLCBudW1iZXJPZklucHV0Q2hhbm5lbHMsIG51bWJlck9mUGFyYW1ldGVycywgbnVtYmVyT2ZDaGFubmVscywgcmVuZGVyQnVmZmVyLCBwcm9jZXNzZWRCdWZmZXIsIGF1ZGlvQnVmZmVyU291cmNlTm9kZSwgX25hdGl2ZU91dHB1dE5vZGVzLCBfbmF0aXZlT3V0cHV0Tm9kZXMyLCBfb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZSwgX291dHB1dENoYW5uZWxNZXJnZXJOb2RlcywgX291dHB1dEdhaW5Ob2RlLCBfaTMsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQsIG91dHB1dENoYW5uZWxNZXJnZXJOb2RlLCBqLCBfaXRlcmF0b3IyLCBfc3RlcDIsIF9zdGVwMiR2YWx1ZSwgbm0sIGF1ZGlvUGFyYW0sIF9pdGVyYXRvcjMsIF9zdGVwMywgX3N0ZXAzJHZhbHVlLCBfbm0sIF9hdWRpb1BhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb1dvcmtsZXROb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZU91dHB1dE5vZGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWxDb3VudCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQpID8gb3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQgOiBBcnJheS5mcm9tKG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50KTsgLy8gQnVnICM2MTogT25seSBDaHJvbWUsIEVkZ2UgJiBGaXJlZm94IGhhdmUgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIEF1ZGlvV29ya2xldE5vZGUgeWV0LlxuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZk91dHB1dENoYW5uZWxzID0gb3V0cHV0Q2hhbm5lbENvdW50LnJlZHVjZShmdW5jdGlvbiAoc3VtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IE1hdGgubWF4KDEsIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMpLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgICAgICAgICAgICAgIG51bWJlck9mT3V0cHV0czogTWF0aC5tYXgoMSwgbnVtYmVyT2ZPdXRwdXRDaGFubmVscylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWxNZXJnZXJOb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJveHkubnVtYmVyT2ZPdXRwdXRzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXMucHVzaChjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IG91dHB1dENoYW5uZWxDb3VudFtpXVxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG9wdGlvbnMuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG9wdGlvbnMuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG9wdGlvbnMuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEdhaW5Ob2RlLmNvbm5lY3QgPSBjb25uZWN0TXVsdGlwbGVPdXRwdXRzLmJpbmQobnVsbCwgb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0R2Fpbk5vZGUuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3RNdWx0aXBsZU91dHB1dHMuYmluZChudWxsLCBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVPdXRwdXROb2RlcyA9IFtvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlLCBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXMsIG91dHB1dEdhaW5Ob2RlXTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5hdGl2ZUF1ZGlvV29ya2xldE5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUgPSBuZXcgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVPdXRwdXROb2RlcyA9PT0gbnVsbCA/IG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUgOiBuYXRpdmVPdXRwdXROb2Rlc1syXSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShuYXRpdmVPdXRwdXROb2RlcyAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIShwcm9jZXNzZWRCdWZmZXJQcm9taXNlID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDMyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghKHByb2Nlc3NvckNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSBwcm9jZXNzb3IgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgIGlmICghKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIG5hdGl2ZSBPZmZsaW5lQXVkaW9Db250ZXh0IGNvbnN0cnVjdG9yLicpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAvLyBCdWcgIzQ3OiBUaGUgQXVkaW9EZXN0aW5hdGlvbk5vZGUgaW4gU2FmYXJpIGdldHMgbm90IGluaXRpYWxpemVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgIG51bWJlck9mSW5wdXRDaGFubmVscyA9IHByb3h5LmNoYW5uZWxDb3VudCAqIHByb3h5Lm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZQYXJhbWV0ZXJzID0gcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMgPT09IHVuZGVmaW5lZCA/IDAgOiBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzID0gbnVtYmVyT2ZJbnB1dENoYW5uZWxzICsgbnVtYmVyT2ZQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgcmVuZGVyQnVmZmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIGdhaW5Ob2RlcywgaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2RlcywgX2ksIGNvbnN0YW50U291cmNlTm9kZXMsIGlucHV0Q2hhbm5lbE1lcmdlck5vZGUsIF9pMiwgaiwgX2l0ZXJhdG9yLCBfc3RlcCwgX3N0ZXAkdmFsdWUsIGluZGV4LCBjb25zdGFudFNvdXJjZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IobnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZWlsIHRoZSBsZW5ndGggdG8gdGhlIG5leHQgZnVsbCByZW5kZXIgcXVhbnR1bS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCdWcgIzE3OiBTYWZhcmkgZG9lcyBub3QgeWV0IGV4cG9zZSB0aGUgbGVuZ3RoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChwcm94eS5jb250ZXh0Lmxlbmd0aCAvIDEyOCkgKiAxMjgsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbk5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwOyBfaSA8IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7IF9pICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5Ob2Rlcy5wdXNoKGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogb3B0aW9ucy5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG9wdGlvbnMuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBvcHRpb25zLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FpbjogMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2Rlcy5wdXNoKGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBvcHRpb25zLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IG9wdGlvbnMuY2hhbm5lbENvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShwcm94eS5wYXJhbWV0ZXJzLnZhbHVlcygpKS5tYXAoLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNSA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYXVkaW9QYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RhbnRTb3VyY2VOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZShwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGF1ZGlvUGFyYW0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24ocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIGF1ZGlvUGFyYW0sIGNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBjb25zdGFudFNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGVzID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsTWVyZ2VyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlKHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IE1hdGgubWF4KDEsIG51bWJlck9mSW5wdXRDaGFubmVscyArIG51bWJlck9mUGFyYW1ldGVycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7IF9pMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYWluTm9kZXNbX2kyXS5jb25uZWN0KGlucHV0Q2hhbm5lbFNwbGl0dGVyTm9kZXNbX2kyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgb3B0aW9ucy5jaGFubmVsQ291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxTcGxpdHRlck5vZGVzW19pMl0uY29ubmVjdChpbnB1dENoYW5uZWxNZXJnZXJOb2RlLCBqLCBfaTIgKiBvcHRpb25zLmNoYW5uZWxDb3VudCArIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KGNvbnN0YW50U291cmNlTm9kZXMuZW50cmllcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksIGluZGV4ID0gX3N0ZXAkdmFsdWVbMF0sIGNvbnN0YW50U291cmNlTm9kZSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuY29ubmVjdChpbnB1dENoYW5uZWxNZXJnZXJOb2RlLCAwLCBudW1iZXJPZklucHV0Q2hhbm5lbHMgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5zdGFydCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbE1lcmdlck5vZGUuY29ubmVjdChwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZ2Fpbk5vZGVzLm1hcChmdW5jdGlvbiAoZ2Fpbk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIGdhaW5Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVuZGVyTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZW5kZXJCdWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBwcm9jZXNzQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQxID0gcHJveHk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShudW1iZXJPZkNoYW5uZWxzID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MiA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUudDMgPSBfY29udGV4dDUudDI7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUudDQgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0O1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQ1ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50NiA9IG91dHB1dENoYW5uZWxDb3VudDtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50NyA9IHByb2Nlc3NvckNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQ4ID0gZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzZWRCdWZmZXJQcm9taXNlID0gKDAsIF9jb250ZXh0NS50MCkoX2NvbnRleHQ1LnQxLCBfY29udGV4dDUudDMsIF9jb250ZXh0NS50NCwgX2NvbnRleHQ1LnQ1LCBfY29udGV4dDUudDYsIF9jb250ZXh0NS50NywgX2NvbnRleHQ1LnQ4KTtcbiAgICAgICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzZWRCdWZmZXJQcm9taXNlO1xuICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzZWRCdWZmZXIgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgICAgICAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbG9vcEVuZDogMCxcbiAgICAgICAgICAgICAgICAgICAgbG9vcFN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBwbGF5YmFja1JhdGU6IDFcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgX25hdGl2ZU91dHB1dE5vZGVzID0gbmF0aXZlT3V0cHV0Tm9kZXMsIF9uYXRpdmVPdXRwdXROb2RlczIgPSBfc2xpY2VkVG9BcnJheShfbmF0aXZlT3V0cHV0Tm9kZXMsIDMpLCBfb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZSA9IF9uYXRpdmVPdXRwdXROb2RlczJbMF0sIF9vdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXMgPSBfbmF0aXZlT3V0cHV0Tm9kZXMyWzFdLCBfb3V0cHV0R2Fpbk5vZGUgPSBfbmF0aXZlT3V0cHV0Tm9kZXMyWzJdO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZEJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID0gcHJvY2Vzc2VkQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuY29ubmVjdChfb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKF9pMyA9IDAsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgPSAwOyBfaTMgPCBwcm94eS5udW1iZXJPZk91dHB1dHM7IF9pMyArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWxNZXJnZXJOb2RlID0gX291dHB1dENoYW5uZWxNZXJnZXJOb2Rlc1tfaTNdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgb3V0cHV0Q2hhbm5lbENvdW50W19pM107IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIF9vdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlLmNvbm5lY3Qob3V0cHV0Q2hhbm5lbE1lcmdlck5vZGUsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgKyBqLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ICs9IG91dHB1dENoYW5uZWxDb3VudFtfaTNdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX291dHB1dEdhaW5Ob2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQocHJveHkucGFyYW1ldGVycy5lbnRyaWVzKCkpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA0MztcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucygpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICBpZiAoKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSwgbm0gPSBfc3RlcDIkdmFsdWVbMF0sIGF1ZGlvUGFyYW0gPSBfc3RlcDIkdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgYXVkaW9QYXJhbSxcbiAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIFRoZSBkZWZpbml0aW9uIHRoYXQgVHlwZVNjcmlwdCB1c2VzIG9mIHRoZSBBdWRpb1BhcmFtTWFwIGlzIGxhY2tpbmcgbWFueSBtZXRob2RzLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5wYXJhbWV0ZXJzLmdldChubSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUzOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA1MztcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50OSA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDQzKTtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIuZShfY29udGV4dDUudDkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTY6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDU2O1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmZpbmlzaCg1Nik7XG4gICAgICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNzg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQocHJveHkucGFyYW1ldGVycy5lbnRyaWVzKCkpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA2MjtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucygpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgICBpZiAoKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNzA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSwgX25tID0gX3N0ZXAzJHZhbHVlWzBdLCBfYXVkaW9QYXJhbSA9IF9zdGVwMyR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgX2F1ZGlvUGFyYW0sXG4gICAgICAgICAgICAgICAgICAvLyBAdG9kbyBUaGUgZGVmaW5pdGlvbiB0aGF0IFR5cGVTY3JpcHQgdXNlcyBvZiB0aGUgQXVkaW9QYXJhbU1hcCBpcyBsYWNraW5nIG1hbnkgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUucGFyYW1ldGVycy5nZXQoX25tKSk7XG4gICAgICAgICAgICAgICAgY2FzZSA2ODpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDcwOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA3NTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzI6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDcyO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQxMCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDYyKTtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMuZShfY29udGV4dDUudDEwKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc1OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA3NTtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5maW5pc2goNzUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzg6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDgwO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDgwOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA4MTpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTQsIG51bGwsIFtbNDMsIDUzLCA1NiwgNTldLCBbNjIsIDcyLCA3NSwgNzhdXSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBdWRpb05vZGUoX3g4LCBfeDkpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgZGVsZXRlVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkpO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZU9yR2Fpbk5vZGUgPSByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZU9yR2Fpbk5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZU9yR2Fpbk5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRyKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJHIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRyKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRyKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRsKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBjcmVhdGVCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoYWRkQXVkaW9Xb3JrbGV0TW9kdWxlLCBhbmFseXNlck5vZGVDb25zdHJ1Y3RvciwgYXVkaW9CdWZmZXJDb25zdHJ1Y3RvciwgYXVkaW9CdWZmZXJTb3VyY2VOb2RlQ29uc3RydWN0b3IsIGJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3RvciwgY2hhbm5lbE1lcmdlck5vZGVDb25zdHJ1Y3RvciwgY2hhbm5lbFNwbGl0dGVyTm9kZUNvbnN0cnVjdG9yLCBjb25zdGFudFNvdXJjZU5vZGVDb25zdHJ1Y3RvciwgY29udm9sdmVyTm9kZUNvbnN0cnVjdG9yLCBfZGVjb2RlQXVkaW9EYXRhLCBkZWxheU5vZGVDb25zdHJ1Y3RvciwgZHluYW1pY3NDb21wcmVzc29yTm9kZUNvbnN0cnVjdG9yLCBnYWluTm9kZUNvbnN0cnVjdG9yLCBpSVJGaWx0ZXJOb2RlQ29uc3RydWN0b3IsIG1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIG9zY2lsbGF0b3JOb2RlQ29uc3RydWN0b3IsIHBhbm5lck5vZGVDb25zdHJ1Y3RvciwgcGVyaW9kaWNXYXZlQ29uc3RydWN0b3IsIHN0ZXJlb1Bhbm5lck5vZGVDb25zdHJ1Y3Rvciwgd2F2ZVNoYXBlck5vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21pbmltYWxCYXNlQXVkaW9Db250KSB7XG4gICAgICAgIGZ1bmN0aW9uIEJhc2VBdWRpb0NvbnRleHQoX25hdGl2ZUNvbnRleHQsIG51bWJlck9mQ2hhbm5lbHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRsKHRoaXMsIEJhc2VBdWRpb0NvbnRleHQsIFtfbmF0aXZlQ29udGV4dCwgbnVtYmVyT2ZDaGFubmVsc10pO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVDb250ZXh0ID0gX25hdGl2ZUNvbnRleHQ7XG4gICAgICAgICAgX3RoaXMuX2F1ZGlvV29ya2xldCA9IGFkZEF1ZGlvV29ya2xldE1vZHVsZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDoge1xuICAgICAgICAgICAgYWRkTW9kdWxlOiBmdW5jdGlvbiBhZGRNb2R1bGUobW9kdWxlVVJMLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhZGRBdWRpb1dvcmtsZXRNb2R1bGUoX3RoaXMsIG1vZHVsZVVSTCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKEJhc2VBdWRpb0NvbnRleHQsIF9taW5pbWFsQmFzZUF1ZGlvQ29udCk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQmFzZUF1ZGlvQ29udGV4dCwgW3tcbiAgICAgICAgICBrZXk6IFwiYXVkaW9Xb3JrbGV0XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXVkaW9Xb3JrbGV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVBbmFseXNlclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVBbmFseXNlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYW5hbHlzZXJOb2RlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUJpcXVhZEZpbHRlclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVCaXF1YWRGaWx0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlQnVmZmVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihudW1iZXJPZkNoYW5uZWxzLCBsZW5ndGgsIHNhbXBsZVJhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXVkaW9CdWZmZXJDb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiBudW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlQnVmZmVyU291cmNlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlclNvdXJjZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXVkaW9CdWZmZXJTb3VyY2VOb2RlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUNoYW5uZWxNZXJnZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbE1lcmdlcigpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJPZklucHV0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogNjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2hhbm5lbE1lcmdlck5vZGVDb25zdHJ1Y3Rvcih0aGlzLCB7XG4gICAgICAgICAgICAgIG51bWJlck9mSW5wdXRzOiBudW1iZXJPZklucHV0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUNoYW5uZWxTcGxpdHRlclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDaGFubmVsU3BsaXR0ZXIoKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyT2ZPdXRwdXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiA2O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3IodGhpcywge1xuICAgICAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IG51bWJlck9mT3V0cHV0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUNvbnN0YW50U291cmNlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNvbnN0YW50U291cmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25zdGFudFNvdXJjZU5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlQ29udm9sdmVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNvbnZvbHZlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29udm9sdmVyTm9kZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVEZWxheVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVEZWxheSgpIHtcbiAgICAgICAgICAgIHZhciBtYXhEZWxheVRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRlbGF5Tm9kZUNvbnN0cnVjdG9yKHRoaXMsIHtcbiAgICAgICAgICAgICAgbWF4RGVsYXlUaW1lOiBtYXhEZWxheVRpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBkeW5hbWljc0NvbXByZXNzb3JOb2RlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUdhaW5cIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlR2FpbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ2Fpbk5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlSUlSRmlsdGVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUlJUkZpbHRlcihmZWVkZm9yd2FyZCwgZmVlZGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaUlSRmlsdGVyTm9kZUNvbnN0cnVjdG9yKHRoaXMsIHtcbiAgICAgICAgICAgICAgZmVlZGJhY2s6IGZlZWRiYWNrLFxuICAgICAgICAgICAgICBmZWVkZm9yd2FyZDogZmVlZGZvcndhcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVPc2NpbGxhdG9yXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU9zY2lsbGF0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG9zY2lsbGF0b3JOb2RlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZVBhbm5lclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQYW5uZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBhbm5lck5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlUGVyaW9kaWNXYXZlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBlcmlvZGljV2F2ZShyZWFsLCBpbWFnKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgICAgICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwZXJpb2RpY1dhdmVDb25zdHJ1Y3Rvcih0aGlzLCBfb2JqZWN0U3ByZWFkJHIoX29iamVjdFNwcmVhZCRyKHt9LCBjb25zdHJhaW50cyksIHt9LCB7XG4gICAgICAgICAgICAgIGltYWc6IGltYWcsXG4gICAgICAgICAgICAgIHJlYWw6IHJlYWxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlU3RlcmVvUGFubmVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVN0ZXJlb1Bhbm5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RlcmVvUGFubmVyTm9kZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVXYXZlU2hhcGVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVdhdmVTaGFwZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHdhdmVTaGFwZXJOb2RlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRlY29kZUF1ZGlvRGF0YVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBfZGVjb2RlQXVkaW9EYXRhKHRoaXMuX25hdGl2ZUNvbnRleHQsIGF1ZGlvRGF0YSkudGhlbihmdW5jdGlvbiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRxKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJHEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRxKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRxKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRrKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaygpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkZyA9IHtcbiAgICAgIFE6IDEsXG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIGRldHVuZTogMCxcbiAgICAgIGZyZXF1ZW5jeTogMzUwLFxuICAgICAgZ2FpbjogMCxcbiAgICAgIHR5cGU6ICdsb3dwYXNzJ1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZUJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlQmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyLCBjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IsIGNyZWF0ZU5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBCaXF1YWRGaWx0ZXJOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJpcXVhZEZpbHRlck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkcShfb2JqZWN0U3ByZWFkJHEoe30sIERFRkFVTFRfT1BUSU9OUyRnKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUgPSBjcmVhdGVOYXRpdmVCaXF1YWRGaWx0ZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIGJpcXVhZEZpbHRlck5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZUJpcXVhZEZpbHRlck5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkayh0aGlzLCBCaXF1YWRGaWx0ZXJOb2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIGJpcXVhZEZpbHRlck5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIC8vIEJ1ZyAjODA6IFNhZmFyaSBkb2VzIG5vdCBleHBvcnQgdGhlIGNvcnJlY3QgdmFsdWVzIGZvciBtYXhWYWx1ZSBhbmQgbWluVmFsdWUuXG4gICAgICAgICAgX3RoaXMuX1EgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuUSwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICAvLyBCdWcgIzc4OiBGaXJlZm94ICYgU2FmYXJpIGRvIG5vdCBleHBvcnQgdGhlIGNvcnJlY3QgdmFsdWVzIGZvciBtYXhWYWx1ZSBhbmQgbWluVmFsdWUuXG4gICAgICAgICAgX3RoaXMuX2RldHVuZSA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5kZXR1bmUsIDEyMDAgKiBNYXRoLmxvZzIoTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQpLCAtMTIwMCAqIE1hdGgubG9nMihNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCkpO1xuICAgICAgICAgIC8vIEJ1ZyAjNzc6IEZpcmVmb3ggJiBTYWZhcmkgZG8gbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZSBmb3IgbWluVmFsdWUuXG4gICAgICAgICAgX3RoaXMuX2ZyZXF1ZW5jeSA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5mcmVxdWVuY3ksIGNvbnRleHQuc2FtcGxlUmF0ZSAvIDIsIDApO1xuICAgICAgICAgIC8vIEJ1ZyAjNzk6IEZpcmVmb3ggJiBTYWZhcmkgZG8gbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZCBtaW5WYWx1ZS5cbiAgICAgICAgICBfdGhpcy5fZ2FpbiA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5nYWluLCA0MCAqIE1hdGgubG9nMTAoTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQpLCBNT1NUX05FR0FUSVZFX1NJTkdMRV9GTE9BVCk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUJpcXVhZEZpbHRlck5vZGUgPSBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlO1xuICAgICAgICAgIC8vIEB0b2RvIERldGVybWluZSBhIG1lYW5pbmdmdWwgdGFpbC10aW1lIGluc3RlYWQgb2YganVzdCB1c2luZyBvbmUgc2Vjb25kLlxuICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKF90aGlzLCAxKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKEJpcXVhZEZpbHRlck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQmlxdWFkRmlsdGVyTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwiZGV0dW5lXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGV0dW5lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJmcmVxdWVuY3lcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmVxdWVuY3k7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdhaW5cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nYWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJRXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fUTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidHlwZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUJpcXVhZEZpbHRlck5vZGUudHlwZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLnR5cGUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZ2V0RnJlcXVlbmN5UmVzcG9uc2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnJlcXVlbmN5UmVzcG9uc2UoZnJlcXVlbmN5SHosIG1hZ1Jlc3BvbnNlLCBwaGFzZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzE4OTogU2FmYXJpIGRvZXMgdGhyb3cgYW4gSW52YWxpZFN0YXRlRXJyb3IuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmdldEZyZXF1ZW5jeVJlc3BvbnNlKGZyZXF1ZW5jeUh6LCBtYWdSZXNwb25zZSwgcGhhc2VSZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAxMSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjNjg6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcGFyYW1ldGVycyBkaWZmZXIgaW4gdGhlaXIgbGVuZ3RoLlxuICAgICAgICAgICAgaWYgKGZyZXF1ZW5jeUh6Lmxlbmd0aCAhPT0gbWFnUmVzcG9uc2UubGVuZ3RoIHx8IG1hZ1Jlc3BvbnNlLmxlbmd0aCAhPT0gcGhhc2VSZXNwb25zZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUJpcXVhZEZpbHRlck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVCaXF1YWRGaWx0ZXJOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpO1xuICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgKiBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIFE6IG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuUS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGRldHVuZTogbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5kZXR1bmUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmZyZXF1ZW5jeS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBnYWluOiBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmdhaW4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS50eXBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUgPSBjcmVhdGVOYXRpdmVCaXF1YWRGaWx0ZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVCaXF1YWRGaWx0ZXJOb2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmF0aXZlQmlxdWFkRmlsdGVyTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuUSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5RKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmRldHVuZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5kZXR1bmUpO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmZyZXF1ZW5jeSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5nYWluLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmdhaW4pO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LlEsIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuUSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5kZXR1bmUsIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuZGV0dW5lKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmZyZXF1ZW5jeSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZ2FpbiwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5nYWluKTtcbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQmlxdWFkRmlsdGVyTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQmlxdWFkRmlsdGVyTm9kZSA9IHJlbmRlcmVkTmF0aXZlQmlxdWFkRmlsdGVyTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlQmlxdWFkRmlsdGVyTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVCaXF1YWRGaWx0ZXJOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ2FjaGVUZXN0UmVzdWx0ID0gZnVuY3Rpb24gY3JlYXRlQ2FjaGVUZXN0UmVzdWx0KG9uZ29pbmdUZXN0cywgdGVzdFJlc3VsdHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodGVzdGVyLCB0ZXN0KSB7XG4gICAgICAgIHZhciBjYWNoZWRUZXN0UmVzdWx0ID0gdGVzdFJlc3VsdHMuZ2V0KHRlc3Rlcik7XG4gICAgICAgIGlmIChjYWNoZWRUZXN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkVGVzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb25nb2luZ1Rlc3QgPSBvbmdvaW5nVGVzdHMuZ2V0KHRlc3Rlcik7XG4gICAgICAgIGlmIChvbmdvaW5nVGVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZ29pbmdUZXN0O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHN5bmNocm9ub3VzVGVzdFJlc3VsdCA9IHRlc3QoKTtcbiAgICAgICAgICBpZiAoc3luY2hyb25vdXNUZXN0UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgb25nb2luZ1Rlc3RzLnNldCh0ZXN0ZXIsIHN5bmNocm9ub3VzVGVzdFJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gc3luY2hyb25vdXNUZXN0UmVzdWx0W1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChmaW5hbFRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgb25nb2luZ1Rlc3RzW1wiZGVsZXRlXCJdKHRlc3Rlcik7XG4gICAgICAgICAgICAgIHRlc3RSZXN1bHRzLnNldCh0ZXN0ZXIsIGZpbmFsVGVzdFJlc3VsdCk7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5hbFRlc3RSZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVzdFJlc3VsdHMuc2V0KHRlc3Rlciwgc3luY2hyb25vdXNUZXN0UmVzdWx0KTtcbiAgICAgICAgICByZXR1cm4gc3luY2hyb25vdXNUZXN0UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgdGVzdFJlc3VsdHMuc2V0KHRlc3RlciwgZmFsc2UpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRwKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJHAoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRwKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRwKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRqKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaigpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkZiA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBudW1iZXJPZklucHV0czogNlxuICAgIH07XG4gICAgdmFyIGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVDaGFubmVsTWVyZ2VyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVDaGFubmVsTWVyZ2VyTm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hhbm5lbE1lcmdlck5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRwKF9vYmplY3RTcHJlYWQkcCh7fSwgREVGQVVMVF9PUFRJT05TJGYpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgY2hhbm5lbE1lcmdlck5vZGVSZW5kZXJlciA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSA/IGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgcmV0dXJuIF9jYWxsU3VwZXIkaih0aGlzLCBDaGFubmVsTWVyZ2VyTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgY2hhbm5lbE1lcmdlck5vZGVSZW5kZXJlcl0pO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhDaGFubmVsTWVyZ2VyTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbE1lcmdlck5vZGVSZW5kZXJlckZhY3RvcnkoY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgY3JlYXRlQXVkaW9Ob2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvTm9kZSwgbmF0aXZlQXVkaW9Ob2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb05vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlQXVkaW9Ob2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Ob2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlQXVkaW9Ob2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlQXVkaW9Ob2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IG5hdGl2ZUF1ZGlvTm9kZS5udW1iZXJPZklucHV0c1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb05vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBdWRpb05vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSA9IHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVBdWRpb05vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkbyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRvKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkbyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkbyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkaSh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJGUgPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDYsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgbnVtYmVyT2ZPdXRwdXRzOiA2XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQ2hhbm5lbFNwbGl0dGVyTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbFNwbGl0dGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2FuaXRpemVDaGFubmVsU3BsaXR0ZXJPcHRpb25zKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hhbm5lbFNwbGl0dGVyTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYW5uZWxTcGxpdHRlck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IHNhbml0aXplQ2hhbm5lbFNwbGl0dGVyT3B0aW9ucyhfb2JqZWN0U3ByZWFkJG8oX29iamVjdFNwcmVhZCRvKHt9LCBERUZBVUxUX09QVElPTlMkZSksIG9wdGlvbnMpKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGNoYW5uZWxTcGxpdHRlck5vZGVSZW5kZXJlciA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSA/IGNyZWF0ZUNoYW5uZWxTcGxpdHRlck5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICByZXR1cm4gX2NhbGxTdXBlciRpKHRoaXMsIENoYW5uZWxTcGxpdHRlck5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgY2hhbm5lbFNwbGl0dGVyTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKENoYW5uZWxTcGxpdHRlck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQ2hhbm5lbFNwbGl0dGVyTm9kZSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNoYW5uZWxTcGxpdHRlck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgY3JlYXRlQXVkaW9Ob2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvTm9kZSwgbmF0aXZlQXVkaW9Ob2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb05vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlQXVkaW9Ob2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Ob2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlQXVkaW9Ob2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlQXVkaW9Ob2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZPdXRwdXRzOiBuYXRpdmVBdWRpb05vZGUubnVtYmVyT2ZPdXRwdXRzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXVkaW9Ob2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBdWRpb05vZGUgPSByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ29ubmVjdEF1ZGlvUGFyYW0gPSBmdW5jdGlvbiBjcmVhdGVDb25uZWN0QXVkaW9QYXJhbShyZW5kZXJJbnB1dHNPZkF1ZGlvUGFyYW0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgYXVkaW9QYXJhbSwgbmF0aXZlQXVkaW9QYXJhbSkge1xuICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb1BhcmFtKGF1ZGlvUGFyYW0sIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvUGFyYW0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNvbm5lY3RNdWx0aXBsZU91dHB1dHMgPSBmdW5jdGlvbiBjcmVhdGVDb25uZWN0TXVsdGlwbGVPdXRwdXRzKGNyZWF0ZUluZGV4U2l6ZUVycm9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG91dHB1dEF1ZGlvTm9kZXMsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIHZhciBpbnB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgICAgdmFyIG91dHB1dEF1ZGlvTm9kZSA9IG91dHB1dEF1ZGlvTm9kZXNbb3V0cHV0XTtcbiAgICAgICAgaWYgKG91dHB1dEF1ZGlvTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW5kZXhTaXplRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYXRpdmVBdWRpb05vZGUkMShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0QXVkaW9Ob2RlLmNvbm5lY3QoZGVzdGluYXRpb24sIDAsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0QXVkaW9Ob2RlLmNvbm5lY3QoZGVzdGluYXRpb24sIDApO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNvbm5lY3RlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBuYXRpdmVBdWRpb05vZGUpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgbG9vcDogZmFsc2UsXG4gICAgICAgICAgbG9vcEVuZDogMCxcbiAgICAgICAgICBsb29wU3RhcnQ6IDAsXG4gICAgICAgICAgcGxheWJhY2tSYXRlOiAxXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXIgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAyLCA0NDEwMCk7XG4gICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5idWZmZXIgPSBuYXRpdmVBdWRpb0J1ZmZlcjtcbiAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmxvb3AgPSB0cnVlO1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuY29ubmVjdChuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCgpO1xuICAgICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5kaXNjb25uZWN0KG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJG4oZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkbihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJG4oT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJG4oT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGgodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRoKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGgoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGggPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRkID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ21heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBvZmZzZXQ6IDFcbiAgICB9O1xuICAgIHZhciBjcmVhdGVDb25zdGFudFNvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVDb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlckZhY3RvcnksIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB3cmFwRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbnN0YW50U291cmNlTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25zdGFudFNvdXJjZU5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkbihfb2JqZWN0U3ByZWFkJG4oe30sIERFRkFVTFRfT1BUSU9OUyRkKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyRmFjdG9yeSgpIDogbnVsbDtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkaCh0aGlzLCBDb25zdGFudFNvdXJjZU5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBjb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIF90aGlzLl9jb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlciA9IGNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgPSBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGU7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBCdWcgIzYyICYgIzc0OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBDb25zdGFudFNvdXJjZU5vZGVzIGFuZCBkb2VzIG5vdCBleHBvcnQgdGhlIGNvcnJlY3QgdmFsdWVzIGZvciBtYXhWYWx1ZSBhbmQgbWluVmFsdWVcbiAgICAgICAgICAgKiBmb3IgR2Fpbk5vZGVzLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIF90aGlzLl9vZmZzZXQgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQsIE1PU1RfUE9TSVRJVkVfU0lOR0xFX0ZMT0FULCBNT1NUX05FR0FUSVZFX1NJTkdMRV9GTE9BVCk7XG4gICAgICAgICAgX3RoaXMuX29uZW5kZWQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQ29uc3RhbnRTb3VyY2VOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbnN0YW50U291cmNlTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvbmVuZGVkXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lbmRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcEV2ZW50TGlzdGVuZXIodGhpcywgdmFsdWUpIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5vbmVuZGVkID0gd3JhcHBlZExpc3RlbmVyO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU9uRW5kZWQgPSB0aGlzLl9uYXRpdmVDb25zdGFudFNvdXJjZU5vZGUub25lbmRlZDtcbiAgICAgICAgICAgIHRoaXMuX29uZW5kZWQgPSBuYXRpdmVPbkVuZGVkICE9PSBudWxsICYmIG5hdGl2ZU9uRW5kZWQgPT09IHdyYXBwZWRMaXN0ZW5lciA/IHZhbHVlIDogbmF0aXZlT25FbmRlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgIHZhciB3aGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLnN0YXJ0KHdoZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyLnN0YXJ0ID0gd2hlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgIHNldEludGVybmFsU3RhdGVUb0FjdGl2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgdmFyIF9yZXNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUgPSBmdW5jdGlvbiByZXNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9uYXRpdmVDb25zdGFudFNvdXJjZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBfcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVBdWRpb05vZGUoX3RoaXMyKSkge1xuICAgICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZShfdGhpczIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX3Jlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0b3BcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgIHZhciB3aGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLnN0b3Aod2hlbik7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXIuc3RvcCA9IHdoZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVDb25zdGFudFNvdXJjZU5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0b3AgPSBudWxsO1xuICAgICAgICB2YXIgY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpO1xuICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAqIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUuc3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLnN0b3Aoc3RvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkub2Zmc2V0LCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkub2Zmc2V0LCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZXQgc3RhcnQodmFsdWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgc3RvcCh2YWx1ZSkge1xuICAgICAgICAgICAgc3RvcCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSA9IHJlbmRlcmVkTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb25zdGFudFNvdXJjZU5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVDb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcgPSBmdW5jdGlvbiBjcmVhdGVDb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcodW5pdDMyQXJyYXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdW5pdDMyQXJyYXlbMF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuaXQzMkFycmF5WzBdO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRtKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJG0oZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRtKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRtKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRnKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZygpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkYyA9IHtcbiAgICAgIGJ1ZmZlcjogbnVsbCxcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdjbGFtcGVkLW1heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZmFsc2VcbiAgICB9O1xuICAgIHZhciBjcmVhdGVDb252b2x2ZXJOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVDb252b2x2ZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUNvbnZvbHZlck5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlQ29udm9sdmVyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbnZvbHZlck5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udm9sdmVyTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRtKF9vYmplY3RTcHJlYWQkbSh7fSwgREVGQVVMVF9PUFRJT05TJGMpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udm9sdmVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnZvbHZlck5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgY29udm9sdmVyTm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlQ29udm9sdmVyTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRnKHRoaXMsIENvbnZvbHZlck5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlQ29udm9sdmVyTm9kZSwgY29udm9sdmVyTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgX3RoaXMuX2lzQnVmZmVyTnVsbGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUNvbnZvbHZlck5vZGUgPSBuYXRpdmVDb252b2x2ZXJOb2RlO1xuICAgICAgICAgIGlmIChtZXJnZWRPcHRpb25zLmJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0QXVkaW9Ob2RlVGFpbFRpbWUoX3RoaXMsIG1lcmdlZE9wdGlvbnMuYnVmZmVyLmR1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhDb252b2x2ZXJOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbnZvbHZlck5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImJ1ZmZlclwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQnVmZmVyTnVsbGlmaWVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUNvbnZvbHZlck5vZGUuYnVmZmVyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUNvbnZvbHZlck5vZGUuYnVmZmVyID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBCdWcgIzExNTogU2FmYXJpIGRvZXMgbm90IGFsbG93IHRvIHNldCB0aGUgYnVmZmVyIHRvIG51bGwuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSB0aGlzLl9uYXRpdmVDb252b2x2ZXJOb2RlLmNvbnRleHQ7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUNvbnZvbHZlck5vZGUuYnVmZmVyID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgbmF0aXZlQ29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgdGhpcy5faXNCdWZmZXJOdWxsaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBzZXRBdWRpb05vZGVUYWlsVGltZSh0aGlzLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lzQnVmZmVyTnVsbGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKHRoaXMsIHRoaXMuX25hdGl2ZUNvbnZvbHZlck5vZGUuYnVmZmVyID09PSBudWxsID8gMCA6IHRoaXMuX25hdGl2ZUNvbnZvbHZlck5vZGUuYnVmZmVyLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibm9ybWFsaXplXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5ub3JtYWxpemU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5ub3JtYWxpemUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ29udm9sdmVyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnZvbHZlck5vZGVSZW5kZXJlckZhY3RvcnkoY3JlYXRlTmF0aXZlQ29udm9sdmVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQ29udm9sdmVyTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgY3JlYXRlQ29udm9sdmVyTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVDb252b2x2ZXJOb2RlLCBuYXRpdmVDb252b2x2ZXJOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVDb252b2x2ZXJOb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTsgLy8gSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZUNvbnZvbHZlck5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICBuYXRpdmVDb252b2x2ZXJOb2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlQ29udm9sdmVyTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZUNvbnZvbHZlck5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBuYXRpdmVDb252b2x2ZXJOb2RlLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZUNvbnZvbHZlck5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZUNvbnZvbHZlck5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUNvbnZvbHZlck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiAhbmF0aXZlQ29udm9sdmVyTm9kZS5ub3JtYWxpemVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ29udm9sdmVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnZvbHZlck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUNvbnZvbHZlck5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVDb252b2x2ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNOYXRpdmVBdWRpb05vZGVGYWtlcihuYXRpdmVDb252b2x2ZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQ29udm9sdmVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQ29udm9sdmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQ29udm9sdmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbnZvbHZlck5vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUNvbnZvbHZlck5vZGUgPSByZW5kZXJlZE5hdGl2ZUNvbnZvbHZlck5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUNvbnZvbHZlck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlQ29udm9sdmVyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29udm9sdmVyTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVDcmVhdGVOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobnVtYmVyT2ZDaGFubmVscywgbGVuZ3RoLCBzYW1wbGVSYXRlKSB7XG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIG5hdGl2ZSBPZmZsaW5lQXVkaW9Db250ZXh0IGNvbnN0cnVjdG9yLicpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IobnVtYmVyT2ZDaGFubmVscywgbGVuZ3RoLCBzYW1wbGVSYXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gQnVnICMxNDMsICMxNDQgJiAjMTQ2OiBTYWZhcmkgdGhyb3dzIGEgU3ludGF4RXJyb3Igd2hlbiBudW1iZXJPZkNoYW5uZWxzLCBsZW5ndGggb3Igc2FtcGxlUmF0ZSBhcmUgaW52YWxpZC5cbiAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURhdGFDbG9uZUVycm9yID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNsb25lRXJyb3IoKSB7XG4gICAgICByZXR1cm4gbmV3IERPTUV4Y2VwdGlvbignJywgJ0RhdGFDbG9uZUVycm9yJyk7XG4gICAgfTtcblxuICAgIHZhciBkZXRhY2hBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIGRldGFjaEFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgX01lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgICAgIHBvcnQxID0gX01lc3NhZ2VDaGFubmVsLnBvcnQxLFxuICAgICAgICBwb3J0MiA9IF9NZXNzYWdlQ2hhbm5lbC5wb3J0MjtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgY2xvc2VBbmRSZXNvbHZlID0gZnVuY3Rpb24gY2xvc2VBbmRSZXNvbHZlKCkge1xuICAgICAgICAgIHBvcnQyLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgICBwb3J0Mi5jbG9zZSgpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9ydDIub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjbG9zZUFuZFJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwb3J0MS5wb3N0TWVzc2FnZShhcnJheUJ1ZmZlciwgW2FycmF5QnVmZmVyXSk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGNsb3NlQW5kUmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURlY29kZUF1ZGlvRGF0YSA9IGZ1bmN0aW9uIGNyZWF0ZURlY29kZUF1ZGlvRGF0YShhdWRpb0J1ZmZlclN0b3JlLCBjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZURhdGFDbG9uZUVycm9yLCBjcmVhdGVFbmNvZGluZ0Vycm9yLCBkZXRhY2hlZEFycmF5QnVmZmVycywgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVDb250ZXh0LCB0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kc1N1cHBvcnQsIHRlc3RQcm9taXNlU3VwcG9ydCwgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzLCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnlDb250ZXh0LCBhdWRpb0RhdGEpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBpc05hdGl2ZUNvbnRleHQoYW55Q29udGV4dCkgPyBhbnlDb250ZXh0IDogZ2V0TmF0aXZlQ29udGV4dChhbnlDb250ZXh0KTtcbiAgICAgICAgLy8gQnVnICM0MzogT25seSBDaHJvbWUgYW5kIEVkZ2UgZG8gdGhyb3cgYSBEYXRhQ2xvbmVFcnJvci5cbiAgICAgICAgaWYgKGRldGFjaGVkQXJyYXlCdWZmZXJzLmhhcyhhdWRpb0RhdGEpKSB7XG4gICAgICAgICAgdmFyIGVyciA9IGNyZWF0ZURhdGFDbG9uZUVycm9yKCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGF1ZGlvRGF0YSBwYXJhbWV0ZXIgbWF5YmUgb2YgYSB0eXBlIHdoaWNoIGNhbid0IGJlIGFkZGVkIHRvIGEgV2Vha1NldC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZXRhY2hlZEFycmF5QnVmZmVycy5hZGQoYXVkaW9EYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMuXG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMyMTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJvbWlzZXMgeWV0LlxuICAgICAgICBpZiAoY2FjaGVUZXN0UmVzdWx0KHRlc3RQcm9taXNlU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0UHJvbWlzZVN1cHBvcnQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGF1ZGlvRGF0YSkudGhlbihmdW5jdGlvbiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTMzOiBTYWZhcmkgZG9lcyBuZXV0ZXIgdGhlIEFycmF5QnVmZmVyLlxuICAgICAgICAgICAgZGV0YWNoQXJyYXlCdWZmZXIoYXVkaW9EYXRhKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQnVnICMxNTc6IEZpcmVmb3ggZG9lcyBub3QgYWxsb3cgdGhlIGJ1ZmZlck9mZnNldCB0byBiZSBvdXQtb2YtYm91bmRzLlxuICAgICAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kc1N1cHBvcnQoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW9CdWZmZXJTdG9yZS5hZGQoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjMjE6IFNhZmFyaSBkb2VzIG5vdCByZXR1cm4gYSBQcm9taXNlIHlldC5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgY29tcGxldGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXRhY2hBcnJheUJ1ZmZlcihhdWRpb0RhdGEpO1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA1O1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzAsIDVdXSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0oKTtcbiAgICAgICAgICB2YXIgZmFpbCA9IGZ1bmN0aW9uIGZhaWwoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBCdWcgIzI2OiBTYWZhcmkgdGhyb3dzIGEgc3luY2hyb25vdXMgZXJyb3IuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTogU2FmYXJpIHJlcXVpcmVzIGEgc3VjY2Vzc0NhbGxiYWNrLlxuICAgICAgICAgICAgbmF0aXZlQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCBmdW5jdGlvbiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgICAgICAgLy8gQnVnICM1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjb3B5RnJvbUNoYW5uZWwoKSBhbmQgY29weVRvQ2hhbm5lbCgpLlxuICAgICAgICAgICAgICAvLyBCdWcgIzEwMDogU2FmYXJpIGRvZXMgdGhyb3cgYSB3cm9uZyBlcnJvciB3aGVuIGNhbGxpbmcgZ2V0Q2hhbm5lbERhdGEoKSB3aXRoIGFuIG91dC1vZi1ib3VuZHMgdmFsdWUuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJHZXRDaGFubmVsRGF0YU1ldGhvZChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXVkaW9CdWZmZXJTdG9yZS5hZGQoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgICBjb21wbGV0ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjNDogU2FmYXJpIHJldHVybnMgbnVsbCBpbnN0ZWFkIG9mIGFuIGVycm9yLlxuICAgICAgICAgICAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmFpbChjcmVhdGVFbmNvZGluZ0Vycm9yKCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZhaWwoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmYWlsKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDMociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDMociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciBjcmVhdGVEZWNyZW1lbnRDeWNsZUNvdW50ZXIgPSBmdW5jdGlvbiBjcmVhdGVEZWNyZW1lbnRDeWNsZUNvdW50ZXIoY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlLCBjeWNsZUNvdW50ZXJzLCBnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBnZXROYXRpdmVBdWRpb1BhcmFtLCBnZXROYXRpdmVDb250ZXh0LCBpc0FjdGl2ZUF1ZGlvTm9kZSwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvTm9kZSwgY291bnQpIHtcbiAgICAgICAgdmFyIGN5Y2xlQ291bnRlciA9IGN5Y2xlQ291bnRlcnMuZ2V0KGF1ZGlvTm9kZSk7XG4gICAgICAgIGlmIChjeWNsZUNvdW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgZXhwZWN0ZWQgY3ljbGUgY291bnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGF1ZGlvTm9kZS5jb250ZXh0KTtcbiAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgaWYgKGN5Y2xlQ291bnRlciA9PT0gY291bnQpIHtcbiAgICAgICAgICBjeWNsZUNvdW50ZXJzW1wiZGVsZXRlXCJdKGF1ZGlvTm9kZSk7XG4gICAgICAgICAgaWYgKCFpc09mZmxpbmUgJiYgaXNBY3RpdmVBdWRpb05vZGUoYXVkaW9Ob2RlKSkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShhdWRpb05vZGUpO1xuICAgICAgICAgICAgdmFyIF9nZXRBdWRpb05vZGVDb25uZWN0aSA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKGF1ZGlvTm9kZSksXG4gICAgICAgICAgICAgIG91dHB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkub3V0cHV0cztcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG91dHB1dHMpLFxuICAgICAgICAgICAgICBfc3RlcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc0F1ZGlvTm9kZU91dHB1dENvbm5lY3Rpb24ob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKG91dHB1dFswXSk7XG4gICAgICAgICAgICAgICAgICBjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUobmF0aXZlU291cmNlQXVkaW9Ob2RlLCBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSwgb3V0cHV0WzFdLCBvdXRwdXRbMl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRGVzdGluYXRpb25BdWRpb1BhcmFtID0gZ2V0TmF0aXZlQXVkaW9QYXJhbShvdXRwdXRbMF0pO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlU291cmNlQXVkaW9Ob2RlLmNvbm5lY3QobmF0aXZlRGVzdGluYXRpb25BdWRpb1BhcmFtLCBvdXRwdXRbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeWNsZUNvdW50ZXJzLnNldChhdWRpb05vZGUsIGN5Y2xlQ291bnRlciAtIGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRsKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGwoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRsKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRsKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRmKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZigpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkYiA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgZGVsYXlUaW1lOiAwLFxuICAgICAgbWF4RGVsYXlUaW1lOiAxXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlRGVsYXlOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVEZWxheU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlRGVsYXlOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZURlbGF5Tm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlbGF5Tm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWxheU5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkbChfb2JqZWN0U3ByZWFkJGwoe30sIERFRkFVTFRfT1BUSU9OUyRiKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZURlbGF5Tm9kZSA9IGNyZWF0ZU5hdGl2ZURlbGF5Tm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBkZWxheU5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZURlbGF5Tm9kZVJlbmRlcmVyKG1lcmdlZE9wdGlvbnMubWF4RGVsYXlUaW1lKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGYodGhpcywgRGVsYXlOb2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZURlbGF5Tm9kZSwgZGVsYXlOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICBfdGhpcy5fZGVsYXlUaW1lID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVEZWxheU5vZGUuZGVsYXlUaW1lKTtcbiAgICAgICAgICBzZXRBdWRpb05vZGVUYWlsVGltZShfdGhpcywgbWVyZ2VkT3B0aW9ucy5tYXhEZWxheVRpbWUpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoRGVsYXlOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKERlbGF5Tm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwiZGVsYXlUaW1lXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsYXlUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEZWxheU5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVEZWxheU5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZURlbGF5Tm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXhEZWxheVRpbWUpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlRGVsYXlOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBjcmVhdGVEZWxheU5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlRGVsYXlOb2RlLCBuYXRpdmVEZWxheU5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZURlbGF5Tm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7IC8vIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVEZWxheU5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICBuYXRpdmVEZWxheU5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVEZWxheU5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVEZWxheU5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVEZWxheU5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZURlbGF5Tm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlRGVsYXlOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBkZWxheVRpbWU6IG5hdGl2ZURlbGF5Tm9kZS5kZWxheVRpbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgbWF4RGVsYXlUaW1lOiBtYXhEZWxheVRpbWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGVsYXlOb2RlID0gY3JlYXRlTmF0aXZlRGVsYXlOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVEZWxheU5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVEZWxheU5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZURlbGF5Tm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5kZWxheVRpbWUsIG5hdGl2ZURlbGF5Tm9kZS5kZWxheVRpbWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5kZWxheVRpbWUsIG5hdGl2ZURlbGF5Tm9kZS5kZWxheVRpbWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZURlbGF5Tm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlRGVsYXlOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlRGVsYXlOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVEZWxheU5vZGUgPSByZW5kZXJlZE5hdGl2ZURlbGF5Tm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlRGVsYXlOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZURlbGF5Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRGVsYXlOb2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBmdW5jdGlvbiBjcmVhdGVEZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShwaWNrRWxlbWVudEZyb21TZXQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aXZlSW5wdXRzLCBzb3VyY2UsIG91dHB1dCwgaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHBpY2tFbGVtZW50RnJvbVNldChhY3RpdmVJbnB1dHNbaW5wdXRdLCBmdW5jdGlvbiAoYWN0aXZlSW5wdXRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZUlucHV0Q29ubmVjdGlvblswXSA9PT0gc291cmNlICYmIGFjdGl2ZUlucHV0Q29ubmVjdGlvblsxXSA9PT0gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEZWxldGVVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZURlbGV0ZVVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlKGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2Rlcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBhdWRpb1dvcmtsZXROb2RlKSB7XG4gICAgICAgIGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlcyhuYXRpdmVDb250ZXh0KVtcImRlbGV0ZVwiXShhdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpc0RlbGF5Tm9kZSA9IGZ1bmN0aW9uIGlzRGVsYXlOb2RlKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuICdkZWxheVRpbWUnIGluIGF1ZGlvTm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURldGVjdEN5Y2xlcyA9IGZ1bmN0aW9uIGNyZWF0ZURldGVjdEN5Y2xlcyhhdWRpb1BhcmFtQXVkaW9Ob2RlU3RvcmUsIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXRWYWx1ZUZvcktleSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRldGVjdEN5Y2xlcyhjaGFpbiwgbmV4dExpbmspIHtcbiAgICAgICAgdmFyIGF1ZGlvTm9kZSA9IGlzQXVkaW9Ob2RlKG5leHRMaW5rKSA/IG5leHRMaW5rIDogZ2V0VmFsdWVGb3JLZXkoYXVkaW9QYXJhbUF1ZGlvTm9kZVN0b3JlLCBuZXh0TGluayk7XG4gICAgICAgIGlmIChpc0RlbGF5Tm9kZShhdWRpb05vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFpblswXSA9PT0gYXVkaW9Ob2RlKSB7XG4gICAgICAgICAgcmV0dXJuIFtjaGFpbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYWluLmluY2x1ZGVzKGF1ZGlvTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9nZXRBdWRpb05vZGVDb25uZWN0aSA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKGF1ZGlvTm9kZSksXG4gICAgICAgICAgb3V0cHV0cyA9IF9nZXRBdWRpb05vZGVDb25uZWN0aS5vdXRwdXRzO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShvdXRwdXRzKS5tYXAoZnVuY3Rpb24gKG91dHB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZGV0ZWN0Q3ljbGVzKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2hhaW4pLCBbYXVkaW9Ob2RlXSksIG91dHB1dENvbm5lY3Rpb25bMF0pO1xuICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZEN5Y2xlcywgbmVzdGVkQ3ljbGVzKSB7XG4gICAgICAgICAgcmV0dXJuIG1lcmdlZEN5Y2xlcy5jb25jYXQobmVzdGVkQ3ljbGVzKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE91dHB1dEF1ZGlvTm9kZUF0SW5kZXggPSBmdW5jdGlvbiBnZXRPdXRwdXRBdWRpb05vZGVBdEluZGV4KGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBvdXRwdXRBdWRpb05vZGVzLCBvdXRwdXQpIHtcbiAgICAgIHZhciBvdXRwdXRBdWRpb05vZGUgPSBvdXRwdXRBdWRpb05vZGVzW291dHB1dF07XG4gICAgICBpZiAob3V0cHV0QXVkaW9Ob2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlSW5kZXhTaXplRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXRBdWRpb05vZGU7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlRGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cyA9IGZ1bmN0aW9uIGNyZWF0ZURpc2Nvbm5lY3RNdWx0aXBsZU91dHB1dHMoY3JlYXRlSW5kZXhTaXplRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAob3V0cHV0QXVkaW9Ob2Rlcykge1xuICAgICAgICB2YXIgZGVzdGluYXRpb25Pck91dHB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpbnB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXRBdWRpb05vZGVzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dEF1ZGlvTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEF1ZGlvTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yT3V0cHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRBdWRpb05vZGVBdEluZGV4KGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBvdXRwdXRBdWRpb05vZGVzLCBkZXN0aW5hdGlvbk9yT3V0cHV0KS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmF0aXZlQXVkaW9Ob2RlJDEoZGVzdGluYXRpb25Pck91dHB1dCkpIHtcbiAgICAgICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBdWRpb05vZGVzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dEF1ZGlvTm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0QXVkaW9Ob2RlLmRpc2Nvbm5lY3QoZGVzdGluYXRpb25Pck91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRBdWRpb05vZGVBdEluZGV4KGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBvdXRwdXRBdWRpb05vZGVzLCBvdXRwdXQpLmRpc2Nvbm5lY3QoZGVzdGluYXRpb25Pck91dHB1dCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRBdWRpb05vZGVBdEluZGV4KGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBvdXRwdXRBdWRpb05vZGVzLCBvdXRwdXQpLmRpc2Nvbm5lY3QoZGVzdGluYXRpb25Pck91dHB1dCwgMCwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXRBdWRpb05vZGVzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dEF1ZGlvTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEF1ZGlvTm9kZS5kaXNjb25uZWN0KGRlc3RpbmF0aW9uT3JPdXRwdXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRPdXRwdXRBdWRpb05vZGVBdEluZGV4KGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBvdXRwdXRBdWRpb05vZGVzLCBvdXRwdXQpLmRpc2Nvbm5lY3QoZGVzdGluYXRpb25Pck91dHB1dCwgMCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJGsoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkayhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGsoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGsoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGUodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRlKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRhID0ge1xuICAgICAgYXR0YWNrOiAwLjAwMyxcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdjbGFtcGVkLW1heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBrbmVlOiAzMCxcbiAgICAgIHJhdGlvOiAxMixcbiAgICAgIHJlbGVhc2U6IDAuMjUsXG4gICAgICB0aHJlc2hvbGQ6IC0yNFxuICAgIH07XG4gICAgdmFyIGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIER5bmFtaWNzQ29tcHJlc3Nvck5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHluYW1pY3NDb21wcmVzc29yTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRrKF9vYmplY3RTcHJlYWQkayh7fSwgREVGQVVMVF9PUFRJT05TJGEpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSA9IGNyZWF0ZU5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgZHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRlKHRoaXMsIER5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSwgZHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgX3RoaXMuX2F0dGFjayA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5hdHRhY2spO1xuICAgICAgICAgIF90aGlzLl9rbmVlID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmtuZWUpO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlID0gbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZTtcbiAgICAgICAgICBfdGhpcy5fcmF0aW8gPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmF0aW8pO1xuICAgICAgICAgIF90aGlzLl9yZWxlYXNlID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJlbGVhc2UpO1xuICAgICAgICAgIF90aGlzLl90aHJlc2hvbGQgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUudGhyZXNob2xkKTtcbiAgICAgICAgICBzZXRBdWRpb05vZGVUYWlsVGltZShfdGhpcywgMC4wMDYpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoRHluYW1pY3NDb21wcmVzc29yTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJhdHRhY2tcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEJ1ZyAjMTA4OiBTYWZhcmkgYWxsb3dzIGEgY2hhbm5lbENvdW50IG9mIHRocmVlIGFuZCBhYm92ZSB3aGljaCBpcyB3aHkgdGhlIGdldHRlciBhbmQgc2V0dGVyIG5lZWRzIHRvIGJlIG92ZXJ3cml0dGVuIGhlcmUuXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY2hhbm5lbENvdW50XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzQ2hhbm5lbENvdW50ID0gdGhpcy5fbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gMikge1xuICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudCA9IHByZXZpb3VzQ2hhbm5lbENvdW50O1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEJ1ZyAjMTA5OiBPbmx5IENocm9tZSBhbmQgRmlyZWZveCBkaXNhbGxvdyBhIGNoYW5uZWxDb3VudE1vZGUgb2YgJ21heCcgeWV0IHdoaWNoIGlzIHdoeSB0aGUgZ2V0dGVyIGFuZCBzZXR0ZXIgbmVlZHMgdG8gYmVcbiAgICAgICAgICAgKiBvdmVyd3JpdHRlbiBoZXJlLlxuICAgICAgICAgICAqL1xuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNoYW5uZWxDb3VudE1vZGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzQ2hhbm5lbENvdW50ID0gdGhpcy5fbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsQ291bnRNb2RlO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuY2hhbm5lbENvdW50TW9kZSA9IHByZXZpb3VzQ2hhbm5lbENvdW50O1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJrbmVlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa25lZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicmF0aW9cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYXRpbztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicmVkdWN0aW9uXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzExMTogU2FmYXJpIHJldHVybnMgYW4gQXVkaW9QYXJhbSBpbnN0ZWFkIG9mIGEgbnVtYmVyLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJlZHVjdGlvbi52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmVkdWN0aW9uLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmVkdWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZWxlYXNlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVsZWFzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidGhyZXNob2xkXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyZXNob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JOb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTtcbiAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAqIGNyZWF0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRhY2s6IG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuYXR0YWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAga25lZTogbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5rbmVlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHJhdGlvOiBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJhdGlvLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2U6IG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmVsZWFzZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUudGhyZXNob2xkLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSBjcmVhdGVOYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuYXR0YWNrLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmF0dGFjayk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5rbmVlLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmtuZWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnJhdGlvLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJhdGlvKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucmVsZWFzZSwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5yZWxlYXNlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkudGhyZXNob2xkLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuYXR0YWNrLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmF0dGFjayk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5rbmVlLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmtuZWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucmF0aW8sIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmF0aW8pO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucmVsZWFzZSwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5yZWxlYXNlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnRocmVzaG9sZCwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS50aHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlID0gcmVuZGVyZWROYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVFbmNvZGluZ0Vycm9yID0gZnVuY3Rpb24gY3JlYXRlRW5jb2RpbmdFcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnRW5jb2RpbmdFcnJvcicpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRXZhbHVhdGVTb3VyY2UgPSBmdW5jdGlvbiBjcmVhdGVFdmFsdWF0ZVNvdXJjZSh3aW5kb3cpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQnVnICMxODIgQ2hyb21lIGFuZCBFZGdlIGRvIHRocm93IGFuIGluc3RhbmNlIG9mIGEgU3ludGF4RXJyb3IgaW5zdGVhZCBvZiBhIERPTUV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJlamVjdChuZXcgU3ludGF4RXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoZWFkID0gd2luZG93LmRvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgaWYgKGhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTgyIENocm9tZSBhbmQgRWRnZSBkbyB0aHJvdyBhbiBpbnN0YW5jZSBvZiBhIFN5bnRheEVycm9yIGluc3RlYWQgb2YgYSBET01FeGNlcHRpb24uXG4gICAgICAgICAgICByZWplY3QobmV3IFN5bnRheEVycm9yKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgLy8gQHRvZG8gU2FmYXJpIGRvZXNuJ3QgbGlrZSBVUkxzIHdpdGggYSB0eXBlIG9mICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0OyBjaGFyc2V0PXV0Zi04Jy5cbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3NvdXJjZV0sIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsT25FcnJvckhhbmRsZXIgPSB3aW5kb3cub25lcnJvcjtcbiAgICAgICAgICAgIHZhciByZW1vdmVFcnJvckV2ZW50TGlzdGVuZXJBbmRSZXZva2VVcmwgPSBmdW5jdGlvbiByZW1vdmVFcnJvckV2ZW50TGlzdGVuZXJBbmRSZXZva2VVcmwoKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5vbmVycm9yID0gb3JpZ2luYWxPbkVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNyYywgbGluZW5vLCBjb2xubywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gQHRvZG8gRWRnZSB0aGlua3MgdGhlIHNvdXJjZSBpcyB0aGUgb25lIG9mIHRoZSBodG1sIGRvY3VtZW50LlxuICAgICAgICAgICAgICBpZiAoc3JjID09PSB1cmwgfHwgc3JjID09PSB3aW5kb3cubG9jYXRpb24uaHJlZiAmJiBsaW5lbm8gPT09IDEgJiYgY29sbm8gPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFcnJvckV2ZW50TGlzdGVuZXJBbmRSZXZva2VVcmwoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3JpZ2luYWxPbkVycm9ySGFuZGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9uRXJyb3JIYW5kbGVyKG1lc3NhZ2UsIHNyYywgbGluZW5vLCBjb2xubywgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUVycm9yRXZlbnRMaXN0ZW5lckFuZFJldm9rZVVybCgpO1xuICAgICAgICAgICAgICAvLyBCdWcgIzE4MiBDaHJvbWUgYW5kIEVkZ2UgZG8gdGhyb3cgYW4gaW5zdGFuY2Ugb2YgYSBTeW50YXhFcnJvciBpbnN0ZWFkIG9mIGEgRE9NRXhjZXB0aW9uLlxuICAgICAgICAgICAgICByZWplY3QobmV3IFN5bnRheEVycm9yKCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUVycm9yRXZlbnRMaXN0ZW5lckFuZFJldm9rZVVybCgpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgICAgIHNjcmlwdC50eXBlID0gJ21vZHVsZSc7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVFdmVudFRhcmdldENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlRXZlbnRUYXJnZXRDb25zdHJ1Y3Rvcih3cmFwRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KF9uYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudFRhcmdldCk7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlRXZlbnRUYXJnZXQgPSBfbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV2ZW50VGFyZ2V0LCBbe1xuICAgICAgICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgd3JhcHBlZEV2ZW50TGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgaWYgKHdyYXBwZWRFdmVudExpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXZlbnRMaXN0ZW5lciA9IHdyYXBFdmVudExpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCB3cmFwcGVkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgd3JhcHBlZEV2ZW50TGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVFdmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZEV2ZW50TGlzdGVuZXIgPSBsaXN0ZW5lciA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMuX2xpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB3cmFwcGVkRXZlbnRMaXN0ZW5lciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHdyYXBwZWRFdmVudExpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gY3JlYXRlRXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUod2luZG93KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzYW1wbGVSYXRlLCBmbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3aW5kb3csIHtcbiAgICAgICAgICBjdXJyZW50RnJhbWU6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChjdXJyZW50VGltZSAqIHNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRpbWU6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAod2luZG93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgd2luZG93LmN1cnJlbnRGcmFtZTtcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuY3VycmVudFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRmV0Y2hTb3VyY2UgPSBmdW5jdGlvbiBjcmVhdGVGZXRjaFNvdXJjZShjcmVhdGVBYm9ydEVycm9yKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodXJsKSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsKTtcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MSA9IHJlc3BvbnNlLnVybDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIFtfY29udGV4dC50MCwgX2NvbnRleHQudDFdKTtcbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVBYm9ydEVycm9yKCk7XG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgMTJdXSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCkge1xuICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkaihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRqKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkaihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkaihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkZCh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGQoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJDkgPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIGdhaW46IDFcbiAgICB9O1xuICAgIHZhciBjcmVhdGVHYWluTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlR2Fpbk5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlR2Fpbk5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIEdhaW5Ob2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdhaW5Ob2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJGooX29iamVjdFNwcmVhZCRqKHt9LCBERUZBVUxUX09QVElPTlMkOSksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIGdhaW5Ob2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVHYWluTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRkKHRoaXMsIEdhaW5Ob2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZUdhaW5Ob2RlLCBnYWluTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgLy8gQnVnICM3NDogU2FmYXJpIGRvZXMgbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZCBtaW5WYWx1ZS5cbiAgICAgICAgICBfdGhpcy5fZ2FpbiA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlR2Fpbk5vZGUuZ2FpbiwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKEdhaW5Ob2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEdhaW5Ob2RlLCBbe1xuICAgICAgICAgIGtleTogXCJnYWluXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2FpbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2Fpbk5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVHYWluTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUdhaW5Ob2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBjcmVhdGVHYWluTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVHYWluTm9kZSwgbmF0aXZlR2Fpbk5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUdhaW5Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTsgLy8gSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZUdhaW5Ob2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlR2Fpbk5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVHYWluTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZUdhaW5Ob2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlR2Fpbk5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZUdhaW5Ob2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVHYWluTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgZ2FpbjogbmF0aXZlR2Fpbk5vZGUuZ2Fpbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVHYWluTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUdhaW5Ob2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVHYWluTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5nYWluLCBuYXRpdmVHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZ2FpbiwgbmF0aXZlR2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUdhaW5Ob2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlR2Fpbk5vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUdhaW5Ob2RlID0gcmVuZGVyZWROYXRpdmVHYWluTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlR2Fpbk5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUdhaW5Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyA9IGZ1bmN0aW9uIGNyZWF0ZUdldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMoYWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0c1N0b3JlLCBnZXRWYWx1ZUZvcktleSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVBdWRpb1dvcmtsZXROb2RlKSB7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZUZvcktleShhY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzU3RvcmUsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUdldEF1ZGlvTm9kZVJlbmRlcmVyID0gZnVuY3Rpb24gY3JlYXRlR2V0QXVkaW9Ob2RlUmVuZGVyZXIoZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9Ob2RlKSB7XG4gICAgICAgIHZhciBhdWRpb05vZGVDb25uZWN0aW9ucyA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKGF1ZGlvTm9kZSk7XG4gICAgICAgIGlmIChhdWRpb05vZGVDb25uZWN0aW9ucy5yZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgcmVuZGVyZXIgb2YgdGhlIGdpdmVuIEF1ZGlvTm9kZSBpbiB0aGUgYXVkaW8gZ3JhcGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1ZGlvTm9kZUNvbm5lY3Rpb25zLnJlbmRlcmVyO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUdldEF1ZGlvTm9kZVRhaWxUaW1lID0gZnVuY3Rpb24gY3JlYXRlR2V0QXVkaW9Ob2RlVGFpbFRpbWUoYXVkaW9Ob2RlVGFpbFRpbWVTdG9yZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdWRpb05vZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gYXVkaW9Ob2RlVGFpbFRpbWVTdG9yZS5nZXQoYXVkaW9Ob2RlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVHZXRBdWRpb1BhcmFtUmVuZGVyZXIgPSBmdW5jdGlvbiBjcmVhdGVHZXRBdWRpb1BhcmFtUmVuZGVyZXIoZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvUGFyYW0pIHtcbiAgICAgICAgdmFyIGF1ZGlvUGFyYW1Db25uZWN0aW9ucyA9IGdldEF1ZGlvUGFyYW1Db25uZWN0aW9ucyhhdWRpb1BhcmFtKTtcbiAgICAgICAgaWYgKGF1ZGlvUGFyYW1Db25uZWN0aW9ucy5yZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgcmVuZGVyZXIgb2YgdGhlIGdpdmVuIEF1ZGlvUGFyYW0gaW4gdGhlIGF1ZGlvIGdyYXBoLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdWRpb1BhcmFtQ29ubmVjdGlvbnMucmVuZGVyZXI7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2V0QmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUdldEJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQoYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dFN0b3JlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHRTdG9yZS5nZXQobmF0aXZlQ29udGV4dCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUdldE5hdGl2ZUNvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVHZXROYXRpdmVDb250ZXh0KGNvbnRleHRTdG9yZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gY29udGV4dFN0b3JlLmdldChjb250ZXh0KTtcbiAgICAgICAgaWYgKG5hdGl2ZUNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUNvbnRleHQ7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2V0T3JDcmVhdGVCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlR2V0T3JDcmVhdGVCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0KGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHRTdG9yZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgICAgdmFyIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQgPSBiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0U3RvcmUuZ2V0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICBpZiAoYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgbmF0aXZlIE9mZmxpbmVBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxNDE6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IGNyZWF0aW5nIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQgd2l0aCBsZXNzIHRoYW4gNDQxMDAgSHouXG4gICAgICAgIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dFN0b3JlLnNldChuYXRpdmVDb250ZXh0LCBiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzID0gZnVuY3Rpb24gY3JlYXRlR2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzKHVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlU3RvcmUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCkge1xuICAgICAgICB2YXIgdW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzID0gdW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVTdG9yZS5nZXQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIGlmICh1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRleHQgaGFzIG5vIHNldCBvZiBBdWRpb1dvcmtsZXROb2Rlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfTtcblxuICAgIHZhciB3cmFwSUlSRmlsdGVyTm9kZUdldEZyZXF1ZW5jeVJlc3BvbnNlTWV0aG9kID0gZnVuY3Rpb24gd3JhcElJUkZpbHRlck5vZGVHZXRGcmVxdWVuY3lSZXNwb25zZU1ldGhvZChuYXRpdmVJSVJGaWx0ZXJOb2RlKSB7XG4gICAgICBuYXRpdmVJSVJGaWx0ZXJOb2RlLmdldEZyZXF1ZW5jeVJlc3BvbnNlID0gZnVuY3Rpb24gKGdldEZyZXF1ZW5jeVJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZnJlcXVlbmN5SHosIG1hZ1Jlc3BvbnNlLCBwaGFzZVJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKGZyZXF1ZW5jeUh6Lmxlbmd0aCAhPT0gbWFnUmVzcG9uc2UubGVuZ3RoIHx8IG1hZ1Jlc3BvbnNlLmxlbmd0aCAhPT0gcGhhc2VSZXNwb25zZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0RnJlcXVlbmN5UmVzcG9uc2UuY2FsbChuYXRpdmVJSVJGaWx0ZXJOb2RlLCBmcmVxdWVuY3lIeiwgbWFnUmVzcG9uc2UsIHBoYXNlUmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgfShuYXRpdmVJSVJGaWx0ZXJOb2RlLmdldEZyZXF1ZW5jeVJlc3BvbnNlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRpKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGkoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRpKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRpKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRjKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYygpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkOCA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlSUlSRmlsdGVyTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlSUlSRmlsdGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlLCBjcmVhdGVJSVJGaWx0ZXJOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBJSVJGaWx0ZXJOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElJUkZpbHRlck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRpKF9vYmplY3RTcHJlYWQkaSh7fSwgREVGQVVMVF9PUFRJT05TJDgpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlSUlSRmlsdGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGUobmF0aXZlQ29udGV4dCwgaXNPZmZsaW5lID8gbnVsbCA6IGNvbnRleHQuYmFzZUxhdGVuY3ksIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpaXJGaWx0ZXJOb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVJSVJGaWx0ZXJOb2RlUmVuZGVyZXIobWVyZ2VkT3B0aW9ucy5mZWVkYmFjaywgbWVyZ2VkT3B0aW9ucy5mZWVkZm9yd2FyZCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRjKHRoaXMsIElJUkZpbHRlck5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlSUlSRmlsdGVyTm9kZSwgaWlyRmlsdGVyTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgLy8gQnVnICMyMyAmICMyNDogRmlyZWZveERldmVsb3BlciBkb2VzIG5vdCB0aHJvdyBhbiBJbnZhbGlkQWNjZXNzRXJyb3IuXG4gICAgICAgICAgLy8gQHRvZG8gV3JpdGUgYSB0ZXN0IHdoaWNoIGFsbG93cyBvdGhlciBicm93c2VycyB0byByZW1haW4gdW5wYXRjaGVkLlxuICAgICAgICAgIHdyYXBJSVJGaWx0ZXJOb2RlR2V0RnJlcXVlbmN5UmVzcG9uc2VNZXRob2QobmF0aXZlSUlSRmlsdGVyTm9kZSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUlJUkZpbHRlck5vZGUgPSBuYXRpdmVJSVJGaWx0ZXJOb2RlO1xuICAgICAgICAgIC8vIEB0b2RvIERldGVybWluZSBhIG1lYW5pbmdmdWwgdGFpbC10aW1lIGluc3RlYWQgb2YganVzdCB1c2luZyBvbmUgc2Vjb25kLlxuICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKF90aGlzLCAxKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKElJUkZpbHRlck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoSUlSRmlsdGVyTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwiZ2V0RnJlcXVlbmN5UmVzcG9uc2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnJlcXVlbmN5UmVzcG9uc2UoZnJlcXVlbmN5SHosIG1hZ1Jlc3BvbnNlLCBwaGFzZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlSUlSRmlsdGVyTm9kZS5nZXRGcmVxdWVuY3lSZXNwb25zZShmcmVxdWVuY3lIeiwgbWFnUmVzcG9uc2UsIHBoYXNlUmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gYXMgc2hhbWVsZXNzbHkgaW5zcGlyZWQgYnkgc291cmNlIGNvZGUgb2ZcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgLy8ge0BsaW5rIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMuZ2l0LysvbWFzdGVyL3RoaXJkX3BhcnR5L1dlYktpdC9Tb3VyY2UvcGxhdGZvcm0vYXVkaW8vSUlSRmlsdGVyLmNwcHxDaHJvbWl1bSdzIElJUkZpbHRlcn0uXG4gICAgdmFyIGZpbHRlckJ1ZmZlciA9IGZ1bmN0aW9uIGZpbHRlckJ1ZmZlcihmZWVkYmFjaywgZmVlZGJhY2tMZW5ndGgsIGZlZWRmb3J3YXJkLCBmZWVkZm9yd2FyZExlbmd0aCwgbWluTGVuZ3RoLCB4QnVmZmVyLCB5QnVmZmVyLCBidWZmZXJJbmRleCwgYnVmZmVyTGVuZ3RoLCBpbnB1dCwgb3V0cHV0KSB7XG4gICAgICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB2YXIgaSA9IGJ1ZmZlckluZGV4O1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIHZhciB5ID0gZmVlZGZvcndhcmRbMF0gKiBpbnB1dFtqXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBtaW5MZW5ndGg7IGsgKz0gMSkge1xuICAgICAgICAgIHZhciB4ID0gaSAtIGsgJiBidWZmZXJMZW5ndGggLSAxOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgICB5ICs9IGZlZWRmb3J3YXJkW2tdICogeEJ1ZmZlclt4XTtcbiAgICAgICAgICB5IC09IGZlZWRiYWNrW2tdICogeUJ1ZmZlclt4XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfayA9IG1pbkxlbmd0aDsgX2sgPCBmZWVkZm9yd2FyZExlbmd0aDsgX2sgKz0gMSkge1xuICAgICAgICAgIHkgKz0gZmVlZGZvcndhcmRbX2tdICogeEJ1ZmZlcltpIC0gX2sgJiBidWZmZXJMZW5ndGggLSAxXTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2syID0gbWluTGVuZ3RoOyBfazIgPCBmZWVkYmFja0xlbmd0aDsgX2syICs9IDEpIHtcbiAgICAgICAgICB5IC09IGZlZWRiYWNrW19rMl0gKiB5QnVmZmVyW2kgLSBfazIgJiBidWZmZXJMZW5ndGggLSAxXTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIH1cbiAgICAgICAgeEJ1ZmZlcltpXSA9IGlucHV0W2pdO1xuICAgICAgICB5QnVmZmVyW2ldID0geTtcbiAgICAgICAgaSA9IGkgKyAxICYgYnVmZmVyTGVuZ3RoIC0gMTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIG91dHB1dFtqXSA9IHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuXG4gICAgdmFyIGZpbHRlckZ1bGxCdWZmZXIgPSBmdW5jdGlvbiBmaWx0ZXJGdWxsQnVmZmVyKHJlbmRlcmVkQnVmZmVyLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBmZWVkYmFjaywgZmVlZGZvcndhcmQpIHtcbiAgICAgIHZhciBjb252ZXJ0ZWRGZWVkYmFjayA9IGZlZWRiYWNrIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ID8gZmVlZGJhY2sgOiBuZXcgRmxvYXQ2NEFycmF5KGZlZWRiYWNrKTtcbiAgICAgIHZhciBjb252ZXJ0ZWRGZWVkZm9yd2FyZCA9IGZlZWRmb3J3YXJkIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ID8gZmVlZGZvcndhcmQgOiBuZXcgRmxvYXQ2NEFycmF5KGZlZWRmb3J3YXJkKTtcbiAgICAgIHZhciBmZWVkYmFja0xlbmd0aCA9IGNvbnZlcnRlZEZlZWRiYWNrLmxlbmd0aDtcbiAgICAgIHZhciBmZWVkZm9yd2FyZExlbmd0aCA9IGNvbnZlcnRlZEZlZWRmb3J3YXJkLmxlbmd0aDtcbiAgICAgIHZhciBtaW5MZW5ndGggPSBNYXRoLm1pbihmZWVkYmFja0xlbmd0aCwgZmVlZGZvcndhcmRMZW5ndGgpO1xuICAgICAgaWYgKGNvbnZlcnRlZEZlZWRiYWNrWzBdICE9PSAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVlZGJhY2tMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnZlcnRlZEZlZWRmb3J3YXJkW2ldIC89IGNvbnZlcnRlZEZlZWRiYWNrWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBmZWVkZm9yd2FyZExlbmd0aDsgX2kgKz0gMSkge1xuICAgICAgICAgIGNvbnZlcnRlZEZlZWRiYWNrW19pXSAvPSBjb252ZXJ0ZWRGZWVkYmFja1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IDMyO1xuICAgICAgdmFyIHhCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgICB2YXIgeUJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgIHZhciBmaWx0ZXJlZEJ1ZmZlciA9IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKHJlbmRlcmVkQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMsIHJlbmRlcmVkQnVmZmVyLmxlbmd0aCwgcmVuZGVyZWRCdWZmZXIuc2FtcGxlUmF0ZSk7XG4gICAgICB2YXIgbnVtYmVyT2ZDaGFubmVscyA9IHJlbmRlcmVkQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBudW1iZXJPZkNoYW5uZWxzOyBfaTIgKz0gMSkge1xuICAgICAgICB2YXIgaW5wdXQgPSByZW5kZXJlZEJ1ZmZlci5nZXRDaGFubmVsRGF0YShfaTIpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gZmlsdGVyZWRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoX2kyKTtcbiAgICAgICAgeEJ1ZmZlci5maWxsKDApO1xuICAgICAgICB5QnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIGZpbHRlckJ1ZmZlcihjb252ZXJ0ZWRGZWVkYmFjaywgZmVlZGJhY2tMZW5ndGgsIGNvbnZlcnRlZEZlZWRmb3J3YXJkLCBmZWVkZm9yd2FyZExlbmd0aCwgbWluTGVuZ3RoLCB4QnVmZmVyLCB5QnVmZmVyLCAwLCBidWZmZXJMZW5ndGgsIGlucHV0LCBvdXRwdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlcmVkQnVmZmVyO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZUlJUkZpbHRlck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVJSVJGaWx0ZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlLCByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZlZWRiYWNrLCBmZWVkZm9yd2FyZCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGZpbHRlcmVkQnVmZmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHZhciBjcmVhdGVBdWRpb05vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgbmF0aXZlSUlSRmlsdGVyTm9kZSwgbmF0aXZlSUlSRmlsdGVyTm9kZUlzT3duZWRCeUNvbnRleHQsIHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LCBmaWx0ZXJlZEJ1ZmZlcjtcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUlJUkZpbHRlck5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlSUlSRmlsdGVyTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUlJUkZpbHRlck5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVJSVJGaWx0ZXJOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTsgLy8gQnVnICM5OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBJSVJGaWx0ZXJOb2Rlcy5cbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUlJUkZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgbG9vcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgbG9vcEVuZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICBsb29wU3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgcGxheWJhY2tSYXRlOiAxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbmF0aXZlSUlSRmlsdGVyTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gVHlwZVNjcmlwdCBkZWZpbmVzIHRoZSBwYXJhbWV0ZXJzIG9mIGNyZWF0ZUlJUkZpbHRlcigpIGFzIGFycmF5cyBvZiBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVJSVJGaWx0ZXJOb2RlID0gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVJSVJGaWx0ZXIoZmVlZGZvcndhcmQsIGZlZWRiYWNrKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID09PSBudWxsID8gbmF0aXZlSUlSRmlsdGVyTm9kZSA6IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCEoZmlsdGVyZWRCdWZmZXJQcm9taXNlID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgbmF0aXZlIE9mZmxpbmVBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKFxuICAgICAgICAgICAgICAgICAgLy8gQnVnICM0NzogVGhlIEF1ZGlvRGVzdGluYXRpb25Ob2RlIGluIFNhZmFyaSBnZXRzIG5vdCBpbml0aWFsaXplZCBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICBwcm94eS5jb250ZXh0LmRlc3RpbmF0aW9uLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTc6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgZXhwb3NlIHRoZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgICBwcm94eS5jb250ZXh0Lmxlbmd0aCwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQnVmZmVyUHJvbWlzZSA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVkQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRCdWZmZXIgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZpbHRlckZ1bGxCdWZmZXIocmVuZGVyZWRCdWZmZXIsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIGZlZWRiYWNrLCBmZWVkZm9yd2FyZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgICAgICAgICB9KSkoKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEJ1ZmZlclByb21pc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQnVmZmVyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID0gZmlsdGVyZWRCdWZmZXI7XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoMCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVJSVJGaWx0ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlSUlSRmlsdGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXVkaW9Ob2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBdWRpb05vZGUgPSByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHIsIGUpIHsgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIXQpIHsgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihyKSkgfHwgZSkgeyB0ICYmIChyID0gdCk7IHZhciBfbiA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbiA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB0aHJvdyByOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBvLCBhID0gITAsIHUgPSAhMTsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgdCA9IHQuY2FsbChyKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHIgPSB0Lm5leHQoKTsgcmV0dXJuIGEgPSByLmRvbmUsIHI7IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB1ID0gITAsIG8gPSByOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmICh1KSB0aHJvdyBvOyB9IH0gfTsgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheSQyKHIsIGEpIDogdm9pZCAwOyB9IH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQyKHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbiAgICB2YXIgY3JlYXRlSW5jcmVtZW50Q3ljbGVDb3VudGVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUluY3JlbWVudEN5Y2xlQ291bnRlckZhY3RvcnkoY3ljbGVDb3VudGVycywgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZUZyb21OYXRpdmVBdWRpb05vZGUsIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXROYXRpdmVBdWRpb05vZGUsIGdldE5hdGl2ZUF1ZGlvUGFyYW0sIGlzQWN0aXZlQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGlzT2ZmbGluZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvTm9kZSwgY291bnQpIHtcbiAgICAgICAgICB2YXIgY3ljbGVDb3VudGVyID0gY3ljbGVDb3VudGVycy5nZXQoYXVkaW9Ob2RlKTtcbiAgICAgICAgICBpZiAoY3ljbGVDb3VudGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNPZmZsaW5lICYmIGlzQWN0aXZlQXVkaW9Ob2RlKGF1ZGlvTm9kZSkpIHtcbiAgICAgICAgICAgICAgdmFyIG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShhdWRpb05vZGUpO1xuICAgICAgICAgICAgICB2YXIgX2dldEF1ZGlvTm9kZUNvbm5lY3RpID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoYXVkaW9Ob2RlKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpLm91dHB1dHM7XG4gICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKG91dHB1dHMpLFxuICAgICAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNBdWRpb05vZGVPdXRwdXRDb25uZWN0aW9uKG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKG91dHB1dFswXSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlKG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZSwgbmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dFsxXSwgb3V0cHV0WzJdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvUGFyYW0gPSBnZXROYXRpdmVBdWRpb1BhcmFtKG91dHB1dFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZS5kaXNjb25uZWN0KG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9QYXJhbSwgb3V0cHV0WzFdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3ljbGVDb3VudGVycy5zZXQoYXVkaW9Ob2RlLCBjb3VudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5Y2xlQ291bnRlcnMuc2V0KGF1ZGlvTm9kZSwgY3ljbGVDb3VudGVyICsgY291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc0FueUF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUlzQW55QXVkaW9Db250ZXh0KGNvbnRleHRTdG9yZSwgaXNOYXRpdmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW55dGhpbmcpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBjb250ZXh0U3RvcmUuZ2V0KGFueXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIGlzTmF0aXZlQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpIHx8IGlzTmF0aXZlQXVkaW9Db250ZXh0KGFueXRoaW5nKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc0FueUF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZUlzQW55QXVkaW9Ob2RlKGF1ZGlvTm9kZVN0b3JlLCBpc05hdGl2ZUF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnl0aGluZykge1xuICAgICAgICByZXR1cm4gYXVkaW9Ob2RlU3RvcmUuaGFzKGFueXRoaW5nKSB8fCBpc05hdGl2ZUF1ZGlvTm9kZShhbnl0aGluZyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSXNBbnlBdWRpb1BhcmFtID0gZnVuY3Rpb24gY3JlYXRlSXNBbnlBdWRpb1BhcmFtKGF1ZGlvUGFyYW1TdG9yZSwgaXNOYXRpdmVBdWRpb1BhcmFtKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFueXRoaW5nKSB7XG4gICAgICAgIHJldHVybiBhdWRpb1BhcmFtU3RvcmUuaGFzKGFueXRoaW5nKSB8fCBpc05hdGl2ZUF1ZGlvUGFyYW0oYW55dGhpbmcpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzQW55T2ZmbGluZUF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUlzQW55T2ZmbGluZUF1ZGlvQ29udGV4dChjb250ZXh0U3RvcmUsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnl0aGluZykge1xuICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGNvbnRleHRTdG9yZS5nZXQoYW55dGhpbmcpO1xuICAgICAgICByZXR1cm4gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpIHx8IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChhbnl0aGluZyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSXNOYXRpdmVBdWRpb0NvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVJc05hdGl2ZUF1ZGlvQ29udGV4dChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnl0aGluZykge1xuICAgICAgICByZXR1cm4gbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgIT09IG51bGwgJiYgYW55dGhpbmcgaW5zdGFuY2VvZiBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcjtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc05hdGl2ZUF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZUlzTmF0aXZlQXVkaW9Ob2RlKHdpbmRvdykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnl0aGluZykge1xuICAgICAgICByZXR1cm4gd2luZG93ICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3cuQXVkaW9Ob2RlID09PSAnZnVuY3Rpb24nICYmIGFueXRoaW5nIGluc3RhbmNlb2Ygd2luZG93LkF1ZGlvTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc05hdGl2ZUF1ZGlvUGFyYW0gPSBmdW5jdGlvbiBjcmVhdGVJc05hdGl2ZUF1ZGlvUGFyYW0od2luZG93KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFueXRoaW5nKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cgIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5BdWRpb1BhcmFtID09PSAnZnVuY3Rpb24nICYmIGFueXRoaW5nIGluc3RhbmNlb2Ygd2luZG93LkF1ZGlvUGFyYW07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSXNOYXRpdmVDb250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlSXNOYXRpdmVDb250ZXh0KGlzTmF0aXZlQXVkaW9Db250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW55dGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlzTmF0aXZlQXVkaW9Db250ZXh0KGFueXRoaW5nKSB8fCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQoYW55dGhpbmcpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW55dGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiBhbnl0aGluZyBpbnN0YW5jZW9mIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcjtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc1NlY3VyZUNvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVJc1NlY3VyZUNvbnRleHQod2luZG93KSB7XG4gICAgICByZXR1cm4gd2luZG93ICE9PSBudWxsICYmIHdpbmRvdy5pc1NlY3VyZUNvbnRleHQ7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc1N1cHBvcnRlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoY2FjaGVUZXN0UmVzdWx0LCB0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNTdWJhcnJheVN1cHBvcnQsIHRlc3RBdWRpb0NvbnRleHRDbG9zZU1ldGhvZFN1cHBvcnQsIHRlc3RBdWRpb0NvbnRleHREZWNvZGVBdWRpb0RhdGFNZXRob2RUeXBlRXJyb3JTdXBwb3J0LCB0ZXN0QXVkaW9Db250ZXh0T3B0aW9uc1N1cHBvcnQsIHRlc3RBdWRpb05vZGVDb25uZWN0TWV0aG9kU3VwcG9ydCwgdGVzdEF1ZGlvV29ya2xldFByb2Nlc3Nvck5vT3V0cHV0c1N1cHBvcnQsIHRlc3RDaGFubmVsTWVyZ2VyTm9kZUNoYW5uZWxDb3VudFN1cHBvcnQsIHRlc3RDb25zdGFudFNvdXJjZU5vZGVBY2N1cmF0ZVNjaGVkdWxpbmdTdXBwb3J0LCB0ZXN0Q29udm9sdmVyTm9kZUJ1ZmZlclJlYXNzaWduYWJpbGl0eVN1cHBvcnQsIHRlc3RDb252b2x2ZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydCwgdGVzdERvbUV4Y2VwdGlvbkNvbnRydWNvclN1cHBvcnQsIHRlc3RJc1NlY3VyZUNvbnRleHRTdXBwb3J0LCB0ZXN0TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVNZWRpYVN0cmVhbVdpdGhvdXRBdWRpb1RyYWNrU3VwcG9ydCwgdGVzdFN0ZXJlb1Bhbm5lck5vZGVEZWZhdWx0VmFsdWVTdXBwb3J0LCB0ZXN0VHJhbnNmZXJhYmxlc1N1cHBvcnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIShjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzU3ViYXJyYXlTdXBwb3J0LCB0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNTdWJhcnJheVN1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9Db250ZXh0Q2xvc2VNZXRob2RTdXBwb3J0LCB0ZXN0QXVkaW9Db250ZXh0Q2xvc2VNZXRob2RTdXBwb3J0KSAmJiBjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvQ29udGV4dE9wdGlvbnNTdXBwb3J0LCB0ZXN0QXVkaW9Db250ZXh0T3B0aW9uc1N1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9Ob2RlQ29ubmVjdE1ldGhvZFN1cHBvcnQsIHRlc3RBdWRpb05vZGVDb25uZWN0TWV0aG9kU3VwcG9ydCkgJiYgY2FjaGVUZXN0UmVzdWx0KHRlc3RDaGFubmVsTWVyZ2VyTm9kZUNoYW5uZWxDb3VudFN1cHBvcnQsIHRlc3RDaGFubmVsTWVyZ2VyTm9kZUNoYW5uZWxDb3VudFN1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0Q29uc3RhbnRTb3VyY2VOb2RlQWNjdXJhdGVTY2hlZHVsaW5nU3VwcG9ydCwgdGVzdENvbnN0YW50U291cmNlTm9kZUFjY3VyYXRlU2NoZWR1bGluZ1N1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0Q29udm9sdmVyTm9kZUJ1ZmZlclJlYXNzaWduYWJpbGl0eVN1cHBvcnQsIHRlc3RDb252b2x2ZXJOb2RlQnVmZmVyUmVhc3NpZ25hYmlsaXR5U3VwcG9ydCkgJiYgY2FjaGVUZXN0UmVzdWx0KHRlc3RDb252b2x2ZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydCwgdGVzdENvbnZvbHZlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0KSAmJiBjYWNoZVRlc3RSZXN1bHQodGVzdERvbUV4Y2VwdGlvbkNvbnRydWNvclN1cHBvcnQsIHRlc3REb21FeGNlcHRpb25Db250cnVjb3JTdXBwb3J0KSAmJiBjYWNoZVRlc3RSZXN1bHQodGVzdElzU2VjdXJlQ29udGV4dFN1cHBvcnQsIHRlc3RJc1NlY3VyZUNvbnRleHRTdXBwb3J0KSAmJiBjYWNoZVRlc3RSZXN1bHQodGVzdE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlTWVkaWFTdHJlYW1XaXRob3V0QXVkaW9UcmFja1N1cHBvcnQsIHRlc3RNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZU1lZGlhU3RyZWFtV2l0aG91dEF1ZGlvVHJhY2tTdXBwb3J0KSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvQ29udGV4dERlY29kZUF1ZGlvRGF0YU1ldGhvZFR5cGVFcnJvclN1cHBvcnQsIHRlc3RBdWRpb0NvbnRleHREZWNvZGVBdWRpb0RhdGFNZXRob2RUeXBlRXJyb3JTdXBwb3J0KSwgY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JOb091dHB1dHNTdXBwb3J0LCB0ZXN0QXVkaW9Xb3JrbGV0UHJvY2Vzc29yTm9PdXRwdXRzU3VwcG9ydCksIGNhY2hlVGVzdFJlc3VsdCh0ZXN0U3RlcmVvUGFubmVyTm9kZURlZmF1bHRWYWx1ZVN1cHBvcnQsIHRlc3RTdGVyZW9QYW5uZXJOb2RlRGVmYXVsdFZhbHVlU3VwcG9ydCksIGNhY2hlVGVzdFJlc3VsdCh0ZXN0VHJhbnNmZXJhYmxlc1N1cHBvcnQsIHRlc3RUcmFuc2ZlcmFibGVzU3VwcG9ydCldKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0cy5ldmVyeShmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUlzU3VwcG9ydGVkUHJvbWlzZShfeCwgX3gyLCBfeDMsIF94NCwgX3g1LCBfeDYsIF94NywgX3g4LCBfeDksIF94MTAsIF94MTEsIF94MTIsIF94MTMsIF94MTQsIF94MTUsIF94MTYpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRiKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYigpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBjcmVhdGVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbmF0aXZlTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgIC8vIEJ1ZyAjMTcxOiBTYWZhcmkgYWxsb3dzIHRvIGNyZWF0ZSBhIE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSB3aXRoIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQuXG4gICAgICAgICAgaWYgKGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRiKHRoaXMsIE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSwgW2NvbnRleHQsIHRydWUsIG5hdGl2ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSwgbnVsbF0pO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUgPSBuYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGU7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJtZWRpYUVsZW1lbnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUubWVkaWFFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkaChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRoKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkaChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkaChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkYSh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJDcgPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICAvLyBCdWcgIzE3MzogU2FmYXJpIGFsbG93cyB0byBjcmVhdGUgYSBNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlIHdpdGggYW4gT2ZmbGluZUF1ZGlvQ29udGV4dC5cbiAgICAgICAgICBpZiAoaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRoKF9vYmplY3RTcHJlYWQkaCh7fSwgREVGQVVMVF9PUFRJT05TJDcpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSA9IGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGEodGhpcywgTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBudWxsXSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBbe1xuICAgICAgICAgIGtleTogXCJzdHJlYW1cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLnN0cmVhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDkodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIGNyZWF0ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZShuYXRpdmVDb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAvLyBCdWcgIzE3MjogU2FmYXJpIGFsbG93cyB0byBjcmVhdGUgYSBNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSB3aXRoIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQuXG4gICAgICAgICAgaWYgKGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkOSh0aGlzLCBNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSwgW2NvbnRleHQsIHRydWUsIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBudWxsXSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlID0gbmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGU7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwibWVkaWFTdHJlYW1cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZS5tZWRpYVN0cmVhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDgodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDggPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIGNyZWF0ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG5hdGl2ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBfY2FsbFN1cGVyJDgodGhpcywgTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSwgW2NvbnRleHQsIHRydWUsIG5hdGl2ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGUsIG51bGxdKTtcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDcodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDcoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDcgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIGNyZWF0ZU1pbmltYWxBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU1pbmltYWxBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGNyZWF0ZVVua25vd25FcnJvciwgbWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taW5pbWFsQmFzZUF1ZGlvQ29udCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5pbWFsQXVkaW9Db250ZXh0KCkge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1pbmltYWxBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSBuYXRpdmUgQXVkaW9Db250ZXh0IGNvbnN0cnVjdG9yLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9Db250ZXh0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3Iob3B0aW9ucyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzE5MiBTYWZhcmkgZG9lcyB0aHJvdyBhIFN5bnRheEVycm9yIGlmIHRoZSBzYW1wbGVSYXRlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDEyICYmIGVyci5tZXNzYWdlID09PSAnc2FtcGxlUmF0ZSBpcyBub3QgaW4gcmFuZ2UnKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEJ1ZyAjMTMxIFNhZmFyaSByZXR1cm5zIG51bGwgd2hlbiB0aGVyZSBhcmUgZm91ciBvdGhlciBBdWRpb0NvbnRleHRzIHJ1bm5pbmcgYWxyZWFkeS5cbiAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVVbmtub3duRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICM1MSBPbmx5IENocm9tZSBhbmQgRWRnZSB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gbGF0ZW5jeUhpbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAoIWlzVmFsaWRMYXRlbmN5SGludChvcHRpb25zLmxhdGVuY3lIaW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBwcm92aWRlZCB2YWx1ZSAnXCIuY29uY2F0KG9wdGlvbnMubGF0ZW5jeUhpbnQsIFwiJyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgQXVkaW9Db250ZXh0TGF0ZW5jeUNhdGVnb3J5LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEJ1ZyAjMTUwIFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgdGhlIHNhbXBsZVJhdGUuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2FtcGxlUmF0ZSAhPT0gdW5kZWZpbmVkICYmIG5hdGl2ZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlICE9PSBvcHRpb25zLnNhbXBsZVJhdGUpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciQ3KHRoaXMsIE1pbmltYWxBdWRpb0NvbnRleHQsIFtuYXRpdmVBdWRpb0NvbnRleHQsIDJdKTtcbiAgICAgICAgICB2YXIgbGF0ZW5jeUhpbnQgPSBvcHRpb25zLmxhdGVuY3lIaW50O1xuICAgICAgICAgIHZhciBfbmF0aXZlQXVkaW9Db250ZXh0ID0gbmF0aXZlQXVkaW9Db250ZXh0LFxuICAgICAgICAgICAgc2FtcGxlUmF0ZSA9IF9uYXRpdmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAvLyBAdG9kbyBUaGUgdmFsdWVzIGZvciAnYmFsYW5jZWQnLCAnaW50ZXJhY3RpdmUnIGFuZCAncGxheWJhY2snIGFyZSBqdXN0IGNvcGllZCBmcm9tIENocm9tZSdzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIF90aGlzLl9iYXNlTGF0ZW5jeSA9IHR5cGVvZiBuYXRpdmVBdWRpb0NvbnRleHQuYmFzZUxhdGVuY3kgPT09ICdudW1iZXInID8gbmF0aXZlQXVkaW9Db250ZXh0LmJhc2VMYXRlbmN5IDogbGF0ZW5jeUhpbnQgPT09ICdiYWxhbmNlZCcgPyA1MTIgLyBzYW1wbGVSYXRlIDogbGF0ZW5jeUhpbnQgPT09ICdpbnRlcmFjdGl2ZScgfHwgbGF0ZW5jeUhpbnQgPT09IHVuZGVmaW5lZCA/IDI1NiAvIHNhbXBsZVJhdGUgOiBsYXRlbmN5SGludCA9PT0gJ3BsYXliYWNrJyA/IDEwMjQgLyBzYW1wbGVSYXRlIDpcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEB0b2RvIFRoZSBtaW4gKDI1NikgYW5kIG1heCAoMTYzODQpIHZhbHVlcyBhcmUgdGFrZW4gZnJvbSB0aGUgYWxsb3dlZCBidWZmZXJTaXplIHZhbHVlcyBvZiBhXG4gICAgICAgICAgICogU2NyaXB0UHJvY2Vzc29yTm9kZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBNYXRoLm1heCgyLCBNYXRoLm1pbigxMjgsIE1hdGgucm91bmQobGF0ZW5jeUhpbnQgKiBzYW1wbGVSYXRlIC8gMTI4KSkpICogMTI4IC8gc2FtcGxlUmF0ZTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0ID0gbmF0aXZlQXVkaW9Db250ZXh0O1xuICAgICAgICAgIC8vIEJ1ZyAjMTg4OiBTYWZhcmkgd2lsbCBzZXQgdGhlIGNvbnRleHQncyBzdGF0ZSB0byAnaW50ZXJydXB0ZWQnIGluIGNhc2UgdGhlIHVzZXIgc3dpdGNoZXMgdGFicy5cbiAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IubmFtZSA9PT0gJ3dlYmtpdEF1ZGlvQ29udGV4dCcpIHtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVHYWluTm9kZSA9IG5hdGl2ZUF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZUdhaW5Ob2RlLmdhaW4udmFsdWUgPSAxZS0zNztcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5jb25uZWN0KF90aGlzLl9uYXRpdmVHYWluTm9kZSkuY29ubmVjdChuYXRpdmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVHYWluTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQnVnICMzNDogQ2hyb21lIGFuZCBFZGdlIHByZXRlbmQgdG8gYmUgcnVubmluZyByaWdodCBhd2F5LCBidXQgZmlyZSBhbiBvbnN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gdGhlIHN0YXRlIGFjdHVhbGx5IGNoYW5nZXNcbiAgICAgICAgICAgKiB0byAncnVubmluZycuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgICBfdGhpcy5fc3RhdGUgPSAnc3VzcGVuZGVkJztcbiAgICAgICAgICAgIHZhciBfcmV2b2tlU3RhdGUgPSBmdW5jdGlvbiByZXZva2VTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQ29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIF9yZXZva2VTdGF0ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9Db250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgX3Jldm9rZVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhNaW5pbWFsQXVkaW9Db250ZXh0LCBfbWluaW1hbEJhc2VBdWRpb0NvbnQpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1pbmltYWxBdWRpb0NvbnRleHQsIFt7XG4gICAgICAgICAga2V5OiBcImJhc2VMYXRlbmN5XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUxhdGVuY3k7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXRlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgIT09IG51bGwgPyB0aGlzLl9zdGF0ZSA6IHRoaXMuX25hdGl2ZUF1ZGlvQ29udGV4dC5zdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgIC8vIEJ1ZyAjMzU6IEZpcmVmb3ggZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIEF1ZGlvQ29udGV4dCB3YXMgY2xvc2VkIGJlZm9yZS5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWcgIzM0OiBJZiB0aGUgc3RhdGUgd2FzIHNldCB0byBzdXNwZW5kZWQgYmVmb3JlIGl0IHNob3VsZCBiZSByZXZva2VkIG5vdy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQ29udGV4dC5jbG9zZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLl9uYXRpdmVHYWluTm9kZSAhPT0gbnVsbCAmJiBfdGhpczIuX25hdGl2ZU9zY2lsbGF0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9uYXRpdmVHYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVhY3RpdmF0ZUF1ZGlvR3JhcGgoX3RoaXMyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZXN1bWVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLl9uYXRpdmVBdWRpb0NvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBfcmVzb2x2ZVByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMy5fbmF0aXZlQXVkaW9Db250ZXh0LnN0YXRlID09PSAncnVubmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzLnJlc3VtZSgpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzMy5fbmF0aXZlQXVkaW9Db250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgX3Jlc29sdmVQcm9taXNlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LnJlc3VtZSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAvLyBCdWcgIzU1OiBDaHJvbWUgYW5kIEVkZ2UgZG8gdGhyb3cgYW4gSW52YWxpZEFjY2Vzc0Vycm9yIGluc3RlYWQgb2YgYW4gSW52YWxpZFN0YXRlRXJyb3IuXG4gICAgICAgICAgICAgIC8vIEJ1ZyAjNTY6IFNhZmFyaSBpbnZva2VzIHRoZSBjYXRjaCBoYW5kbGVyIGJ1dCB3aXRob3V0IGFuIGVycm9yLlxuICAgICAgICAgICAgICBpZiAoZXJyID09PSB1bmRlZmluZWQgfHwgZXJyLmNvZGUgPT09IDE1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3VzcGVuZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdXNwZW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQ29udGV4dC5zdXNwZW5kKClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjNTY6IFNhZmFyaSBpbnZva2VzIHRoZSBjYXRjaCBoYW5kbGVyIGJ1dCB3aXRob3V0IGFuIGVycm9yLlxuICAgICAgICAgICAgICBpZiAoZXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciQ2KHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNigpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBjcmVhdGVNaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihhdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb0xpc3RlbmVyLCBldmVudFRhcmdldENvbnN0cnVjdG9yLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlU3RvcmUsIHdyYXBFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfZXZlbnRUYXJnZXRDb25zdHJ1Y3QpIHtcbiAgICAgICAgZnVuY3Rpb24gTWluaW1hbEJhc2VBdWRpb0NvbnRleHQoX25hdGl2ZUNvbnRleHQsIG51bWJlck9mQ2hhbm5lbHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1pbmltYWxCYXNlQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkNih0aGlzLCBNaW5pbWFsQmFzZUF1ZGlvQ29udGV4dCwgW19uYXRpdmVDb250ZXh0XSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUNvbnRleHQgPSBfbmF0aXZlQ29udGV4dDtcbiAgICAgICAgICBDT05URVhUX1NUT1JFLnNldChfdGhpcywgX25hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIGlmIChpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQoX25hdGl2ZUNvbnRleHQpKSB7XG4gICAgICAgICAgICB1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZVN0b3JlLnNldChfbmF0aXZlQ29udGV4dCwgbmV3IFNldCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuX2Rlc3RpbmF0aW9uID0gbmV3IGF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IoX3RoaXMsIG51bWJlck9mQ2hhbm5lbHMpO1xuICAgICAgICAgIF90aGlzLl9saXN0ZW5lciA9IGNyZWF0ZUF1ZGlvTGlzdGVuZXIoX3RoaXMsIF9uYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICBfdGhpcy5fb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhNaW5pbWFsQmFzZUF1ZGlvQ29udGV4dCwgX2V2ZW50VGFyZ2V0Q29uc3RydWN0KTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNaW5pbWFsQmFzZUF1ZGlvQ29udGV4dCwgW3tcbiAgICAgICAgICBrZXk6IFwiY3VycmVudFRpbWVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVDb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJkZXN0aW5hdGlvblwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3RpbmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJsaXN0ZW5lclwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvbnN0YXRlY2hhbmdlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25zdGF0ZWNoYW5nZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcEV2ZW50TGlzdGVuZXIodGhpcywgdmFsdWUpIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUNvbnRleHQub25zdGF0ZWNoYW5nZSA9IHdyYXBwZWRMaXN0ZW5lcjtcbiAgICAgICAgICAgIHZhciBuYXRpdmVPblN0YXRlQ2hhbmdlID0gdGhpcy5fbmF0aXZlQ29udGV4dC5vbnN0YXRlY2hhbmdlO1xuICAgICAgICAgICAgdGhpcy5fb25zdGF0ZWNoYW5nZSA9IG5hdGl2ZU9uU3RhdGVDaGFuZ2UgIT09IG51bGwgJiYgbmF0aXZlT25TdGF0ZUNoYW5nZSA9PT0gd3JhcHBlZExpc3RlbmVyID8gdmFsdWUgOiBuYXRpdmVPblN0YXRlQ2hhbmdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzYW1wbGVSYXRlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQ29udGV4dC5zYW1wbGVSYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGF0ZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUNvbnRleHQuc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGV2ZW50VGFyZ2V0Q29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdFByb21pc2VTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdFByb21pc2VTdXBwb3J0KG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgIC8vIFRoaXMgMTIgbnVtYmVycyByZXByZXNlbnQgdGhlIDQ4IGJ5dGVzIG9mIGFuIGVtcHR5IFdBVkUgZmlsZSB3aXRoIGEgc2luZ2xlIHNhbXBsZS5cbiAgICAgIHZhciB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheShbMTE3OTAxMTQxMCwgNDAsIDExNjMyODA3MjcsIDU0NDUwMTA5NCwgMTYsIDEzMTA3MywgNDQxMDAsIDE3NjQwMCwgMTA0ODU4MCwgMTYzNTAxNzA2MCwgNCwgMF0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQnVnICMxOiBTYWZhcmkgcmVxdWlyZXMgYSBzdWNjZXNzQ2FsbGJhY2suXG4gICAgICAgIHZhciBwcm9taXNlID0gbmF0aXZlQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEodWludDMyQXJyYXkuYnVmZmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gSWdub3JlIHRoZSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIElnbm9yZSByZWplY3RlZCBlcnJvcnMuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRnKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGcoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRnKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRnKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciQ1KHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNSgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkNiA9IHtcbiAgICAgIG51bWJlck9mQ2hhbm5lbHM6IDFcbiAgICB9O1xuICAgIHZhciBjcmVhdGVNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTWluaW1hbE9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBfc3RhcnRSZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9taW5pbWFsQmFzZUF1ZGlvQ29udCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dChvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgdmFyIF9ERUZBVUxUX09QVElPTlMkb3B0aSA9IF9vYmplY3RTcHJlYWQkZyhfb2JqZWN0U3ByZWFkJGcoe30sIERFRkFVTFRfT1BUSU9OUyQ2KSwgb3B0aW9ucyksXG4gICAgICAgICAgICBsZW5ndGggPSBfREVGQVVMVF9PUFRJT05TJG9wdGkubGVuZ3RoLFxuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IF9ERUZBVUxUX09QVElPTlMkb3B0aS5udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZSA9IF9ERUZBVUxUX09QVElPTlMkb3B0aS5zYW1wbGVSYXRlO1xuICAgICAgICAgIHZhciBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChudW1iZXJPZkNoYW5uZWxzLCBsZW5ndGgsIHNhbXBsZVJhdGUpO1xuICAgICAgICAgIC8vICMyMSBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBwcm9taXNlcyBhbmQgdGhlcmVmb3JlIHdvdWxkIGZpcmUgdGhlIHN0YXRlY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgcHJvbWlzZSBjYW4gYmUgcmVzb2x2ZWQuXG4gICAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdFByb21pc2VTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdFByb21pc2VTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgIHZhciBfZGVsYXlTdGF0ZUNoYW5nZUV2ZW50ID0gZnVuY3Rpb24gZGVsYXlTdGF0ZUNoYW5nZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIF9kZWxheVN0YXRlQ2hhbmdlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhaXRGb3JUaGVQcm9taXNlVG9TZXR0bGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9kZWxheVN0YXRlQ2hhbmdlRXZlbnQ7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkNSh0aGlzLCBNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwgW25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG51bWJlck9mQ2hhbm5lbHNdKTtcbiAgICAgICAgICBfdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgICBfdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoTWluaW1hbE9mZmxpbmVBdWRpb0NvbnRleHQsIF9taW5pbWFsQmFzZUF1ZGlvQ29udCk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoTWluaW1hbE9mZmxpbmVBdWRpb0NvbnRleHQsIFt7XG4gICAgICAgICAga2V5OiBcImxlbmd0aFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgLy8gQnVnICMxNzogU2FmYXJpIGRvZXMgbm90IHlldCBleHBvc2UgdGhlIGxlbmd0aC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXRlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IG51bGwgPyB0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnN0YXRlIDogdGhpcy5fc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXJ0UmVuZGVyaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0UmVuZGVyaW5nKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQnVnICM5ICYgIzU5OiBJdCBpcyB0aGVvcmV0aWNhbGx5IHBvc3NpYmxlIHRoYXQgc3RhcnRSZW5kZXJpbmcoKSB3aWxsIGZpcnN0IHJlbmRlciBhIHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LiBUaGVyZWZvcmVcbiAgICAgICAgICAgICAqIHRoZSBzdGF0ZSBvZiB0aGUgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCBtaWdodCBubyB0cmFuc2l0aW9uIHRvIHJ1bm5pbmcgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gJ3J1bm5pbmcnO1xuICAgICAgICAgICAgcmV0dXJuIF9zdGFydFJlbmRlcmluZyh0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVhY3RpdmF0ZUF1ZGlvR3JhcGgoX3RoaXMyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJfd2FpdEZvclRoZVByb21pc2VUb1NldHRsZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2FpdEZvclRoZVByb21pc2VUb1NldHRsZShldmVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3dhaXRGb3JUaGVQcm9taXNlVG9TZXR0bGUoZXZlbnQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0obWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDEociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDEociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciBjcmVhdGVNb25pdG9yQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiBjcmVhdGVNb25pdG9yQ29ubmVjdGlvbnMoaW5zZXJ0RWxlbWVudEluU2V0LCBpc05hdGl2ZUF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVBdWRpb05vZGUsIHdoZW5Db25uZWN0ZWQsIHdoZW5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25zID0gbmV3IFNldCgpO1xuICAgICAgICBuYXRpdmVBdWRpb05vZGUuY29ubmVjdCA9IGZ1bmN0aW9uIChjb25uZWN0KSB7XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmludmFsaWQtdm9pZCBuby1pbmZlcnJhYmxlLXR5cGVzXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgICAgIHZhciB3YXNEaXNjb25uZWN0ZWQgPSBjb25uZWN0aW9ucy5zaXplID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzTmF0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAvLyBAdG9kbyBUeXBlU2NyaXB0IGNhbm5vdCBpbmZlciB0aGUgb3ZlcmxvYWRlZCBzaWduYXR1cmUgd2l0aCAzIGFyZ3VtZW50cyB5ZXQuXG4gICAgICAgICAgICAgIGNvbm5lY3QuY2FsbChuYXRpdmVBdWRpb05vZGUsIGRlc3RpbmF0aW9uLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgaW5zZXJ0RWxlbWVudEluU2V0KGNvbm5lY3Rpb25zLCBbZGVzdGluYXRpb24sIG91dHB1dCwgaW5wdXRdLCBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uWzBdID09PSBkZXN0aW5hdGlvbiAmJiBjb25uZWN0aW9uWzFdID09PSBvdXRwdXQgJiYgY29ubmVjdGlvblsyXSA9PT0gaW5wdXQ7XG4gICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICBpZiAod2FzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgd2hlbkNvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3QuY2FsbChuYXRpdmVBdWRpb05vZGUsIGRlc3RpbmF0aW9uLCBvdXRwdXQpO1xuICAgICAgICAgICAgaW5zZXJ0RWxlbWVudEluU2V0KGNvbm5lY3Rpb25zLCBbZGVzdGluYXRpb24sIG91dHB1dF0sIGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uWzBdID09PSBkZXN0aW5hdGlvbiAmJiBjb25uZWN0aW9uWzFdID09PSBvdXRwdXQ7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh3YXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgd2hlbkNvbm5lY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH07XG4gICAgICAgIH0obmF0aXZlQXVkaW9Ob2RlLmNvbm5lY3QpO1xuICAgICAgICBuYXRpdmVBdWRpb05vZGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChkaXNjb25uZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZXN0aW5hdGlvbk9yT3V0cHV0LCBvdXRwdXQsIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgd2FzQ29ubmVjdGVkID0gY29ubmVjdGlvbnMuc2l6ZSA+IDA7XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3QuYXBwbHkobmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JPdXRwdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgY2Fubm90IGluZmVyIHRoZSBvdmVybG9hZGVkIHNpZ25hdHVyZSB3aXRoIDEgYXJndW1lbnQgeWV0LlxuICAgICAgICAgICAgICBkaXNjb25uZWN0LmNhbGwobmF0aXZlQXVkaW9Ob2RlLCBkZXN0aW5hdGlvbk9yT3V0cHV0KTtcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoY29ubmVjdGlvbnMpLFxuICAgICAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25bMV0gPT09IGRlc3RpbmF0aW9uT3JPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNbXCJkZWxldGVcIl0oY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpc05hdGl2ZUF1ZGlvTm9kZShkZXN0aW5hdGlvbk9yT3V0cHV0KSkge1xuICAgICAgICAgICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgY2Fubm90IGluZmVyIHRoZSBvdmVybG9hZGVkIHNpZ25hdHVyZSB3aXRoIDMgYXJndW1lbnRzIHlldC5cbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0LmNhbGwobmF0aXZlQXVkaW9Ob2RlLCBkZXN0aW5hdGlvbk9yT3V0cHV0LCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdG9kbyBUeXBlU2NyaXB0IGNhbm5vdCBpbmZlciB0aGUgb3ZlcmxvYWRlZCBzaWduYXR1cmUgd2l0aCAyIGFyZ3VtZW50cyB5ZXQuXG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdC5jYWxsKG5hdGl2ZUF1ZGlvTm9kZSwgZGVzdGluYXRpb25Pck91dHB1dCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoY29ubmVjdGlvbnMpLFxuICAgICAgICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgICAgdmFyIF9jb25uZWN0aW9uID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKF9jb25uZWN0aW9uWzBdID09PSBkZXN0aW5hdGlvbk9yT3V0cHV0ICYmIChvdXRwdXQgPT09IHVuZGVmaW5lZCB8fCBfY29ubmVjdGlvblsxXSA9PT0gb3V0cHV0KSAmJiAoaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBfY29ubmVjdGlvblsyXSA9PT0gaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zW1wiZGVsZXRlXCJdKF9jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNEaXNjb25uZWN0ZWQgPSBjb25uZWN0aW9ucy5zaXplID09PSAwO1xuICAgICAgICAgICAgaWYgKHdhc0Nvbm5lY3RlZCAmJiBpc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICB3aGVuRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfShuYXRpdmVBdWRpb05vZGUuZGlzY29ubmVjdCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVBdWRpb05vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uID0gZnVuY3Rpb24gYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZUF1ZGlvTm9kZSwgb3B0aW9ucywgb3B0aW9uKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbmF0aXZlQXVkaW9Ob2RlW29wdGlvbl0pIHtcbiAgICAgICAgbmF0aXZlQXVkaW9Ob2RlW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMgPSBmdW5jdGlvbiBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZUF1ZGlvTm9kZSwgb3B0aW9ucykge1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZUF1ZGlvTm9kZSwgb3B0aW9ucywgJ2NoYW5uZWxDb3VudCcpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZUF1ZGlvTm9kZSwgb3B0aW9ucywgJ2NoYW5uZWxDb3VudE1vZGUnKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBdWRpb05vZGUsIG9wdGlvbnMsICdjaGFubmVsSW50ZXJwcmV0YXRpb24nKTtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RBbmFseXNlck5vZGVHZXRGbG9hdFRpbWVEb21haW5EYXRhTWV0aG9kU3VwcG9ydCA9IGZ1bmN0aW9uIHRlc3RBbmFseXNlck5vZGVHZXRGbG9hdFRpbWVEb21haW5EYXRhTWV0aG9kU3VwcG9ydChuYXRpdmVBbmFseXNlck5vZGUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF0aXZlQW5hbHlzZXJOb2RlLmdldEZsb2F0VGltZURvbWFpbkRhdGEgPT09ICdmdW5jdGlvbic7XG4gICAgfTtcblxuICAgIHZhciB3cmFwQW5hbHlzZXJOb2RlR2V0RmxvYXRUaW1lRG9tYWluRGF0YU1ldGhvZCA9IGZ1bmN0aW9uIHdyYXBBbmFseXNlck5vZGVHZXRGbG9hdFRpbWVEb21haW5EYXRhTWV0aG9kKG5hdGl2ZUFuYWx5c2VyTm9kZSkge1xuICAgICAgbmF0aXZlQW5hbHlzZXJOb2RlLmdldEZsb2F0VGltZURvbWFpbkRhdGEgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGJ5dGVUaW1lRG9tYWluRGF0YSA9IG5ldyBVaW50OEFycmF5KGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIG5hdGl2ZUFuYWx5c2VyTm9kZS5nZXRCeXRlVGltZURvbWFpbkRhdGEoYnl0ZVRpbWVEb21haW5EYXRhKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGJ5dGVUaW1lRG9tYWluRGF0YS5sZW5ndGgsIG5hdGl2ZUFuYWx5c2VyTm9kZS5mZnRTaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGFycmF5W2ldID0gKGJ5dGVUaW1lRG9tYWluRGF0YVtpXSAtIDEyOCkgKiAwLjAwNzgxMjU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUFuYWx5c2VyTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVBbmFseXNlck5vZGVGYWN0b3J5KGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW5kZXhTaXplRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlQW5hbHlzZXJOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICAvLyBCdWcgIzM3OiBGaXJlZm94IGRvZXMgbm90IGNyZWF0ZSBhbiBBbmFseXNlck5vZGUgd2l0aCB0aGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZUFuYWx5c2VyTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEJ1ZyAjMTE4OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgbWF4RGVjaWJlbHMgaXMgbm90IG1vcmUgdGhhbiBtaW5EZWNpYmVscy5cbiAgICAgICAgaWYgKCEob3B0aW9ucy5tYXhEZWNpYmVscyA+IG9wdGlvbnMubWluRGVjaWJlbHMpKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW5kZXhTaXplRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQW5hbHlzZXJOb2RlLCBvcHRpb25zLCAnZmZ0U2l6ZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQW5hbHlzZXJOb2RlLCBvcHRpb25zLCAnbWF4RGVjaWJlbHMnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZUFuYWx5c2VyTm9kZSwgb3B0aW9ucywgJ21pbkRlY2liZWxzJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBbmFseXNlck5vZGUsIG9wdGlvbnMsICdzbW9vdGhpbmdUaW1lQ29uc3RhbnQnKTtcbiAgICAgICAgLy8gQnVnICMzNjogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSgpIHlldC5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEFuYWx5c2VyTm9kZUdldEZsb2F0VGltZURvbWFpbkRhdGFNZXRob2RTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBbmFseXNlck5vZGVHZXRGbG9hdFRpbWVEb21haW5EYXRhTWV0aG9kU3VwcG9ydChuYXRpdmVBbmFseXNlck5vZGUpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBbmFseXNlck5vZGVHZXRGbG9hdFRpbWVEb21haW5EYXRhTWV0aG9kKG5hdGl2ZUFuYWx5c2VyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUFuYWx5c2VyTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3Rvcih3aW5kb3cpIHtcbiAgICAgIGlmICh3aW5kb3cgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KCdBdWRpb0J1ZmZlcicpKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuQXVkaW9CdWZmZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZSA9IGZ1bmN0aW9uIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVBdWRpb05vZGUsIG9wdGlvbnMsIGF1ZGlvUGFyYW0pIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbYXVkaW9QYXJhbV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbmF0aXZlQXVkaW9Ob2RlW2F1ZGlvUGFyYW1dLnZhbHVlKSB7XG4gICAgICAgIG5hdGl2ZUF1ZGlvTm9kZVthdWRpb1BhcmFtXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kQ29uc2VjdXRpdmVDYWxscyA9IGZ1bmN0aW9uIHdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0LmNhbGwobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCB3aGVuLCBvZmZzZXQsIGR1cmF0aW9uKTtcbiAgICAgICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICB9KG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCk7XG4gICAgfTtcblxuICAgIHZhciB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlKSB7XG4gICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInICYmIGR1cmF0aW9uIDwgMCB8fCBvZmZzZXQgPCAwIHx8IHdoZW4gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBwYXJhbWV0ZXJzIGNhbid0IGJlIG5lZ2F0aXZlLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQHRvZG8gVHlwZVNjcmlwdCBjYW5ub3QgaW5mZXIgdGhlIG92ZXJsb2FkZWQgc2lnbmF0dXJlIHdpdGggMyBhcmd1bWVudHMgeWV0LlxuICAgICAgICAgIHN0YXJ0LmNhbGwobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLCB3aGVuLCBvZmZzZXQsIGR1cmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgIH0obmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLnN0YXJ0KTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlKSB7XG4gICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuc3RvcCA9IGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgaWYgKHdoZW4gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBwYXJhbWV0ZXIgY2FuJ3QgYmUgbmVnYXRpdmUuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdG9wLmNhbGwobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLCB3aGVuKTtcbiAgICAgICAgfTtcbiAgICAgIH0obmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLnN0b3ApO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZUZhY3RvcnkoYWRkU2lsZW50Q29ubmVjdGlvbiwgY2FjaGVUZXN0UmVzdWx0LCB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmdTdXBwb3J0LCB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RvcE1ldGhvZE51bGxpZmllZEJ1ZmZlclN1cHBvcnQsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxsc1N1cHBvcnQsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgd3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBsaW5nLCB3cmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RvcE1ldGhvZE51bGxpZmllZEJ1ZmZlciwgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgb3B0aW9ucywgJ3BsYXliYWNrUmF0ZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBvcHRpb25zLCAnYnVmZmVyJyk7XG4gICAgICAgIC8vIEJ1ZyAjMTQ5OiBTYWZhcmkgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIGRldHVuZSBBdWRpb1BhcmFtLlxuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBvcHRpb25zLCAnbG9vcCcpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBvcHRpb25zLCAnbG9vcEVuZCcpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBvcHRpb25zLCAnbG9vcFN0YXJ0Jyk7XG4gICAgICAgIC8vIEJ1ZyAjNjk6IFNhZmFyaSBkb2VzIGFsbG93IGNhbGxzIHRvIHN0YXJ0KCkgb2YgYW4gYWxyZWFkeSBzY2hlZHVsZWQgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxNTQgJiAjMTU1OiBTYWZhcmkgZG9lcyBub3QgaGFuZGxlIG9mZnNldHMgd2hpY2ggYXJlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZHVyYXRpb24gb2YgdGhlIGJ1ZmZlci5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmdTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZE9mZnNldENsYW1waW5nU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGxpbmcobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE2MjogU2FmYXJpIGRvZXMgdGhyb3cgYW4gZXJyb3Igd2hlbiBzdG9wKCkgaXMgY2FsbGVkIG9uIGFuIEF1ZGlvQnVmZmVyU291cmNlTm9kZSB3aGljaCBoYXMgbm8gYnVmZmVyIGFzc2lnbmVkIHRvIGl0LlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RvcE1ldGhvZE51bGxpZmllZEJ1ZmZlclN1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0b3BNZXRob2ROdWxsaWZpZWRCdWZmZXJTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgbmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM0NDogU2FmYXJpIGRvZXMgbm90IHRocm93IGEgUmFuZ2VFcnJvciB5ZXQuXG4gICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE5OiBTYWZhcmkgZG9lcyBub3QgaWdub3JlIGNhbGxzIHRvIHN0b3AoKSBvZiBhbiBhbHJlYWR5IHN0b3BwZWQgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxsc1N1cHBvcnQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgbmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM0NDogT25seSBGaXJlZm94IGRvZXMgbm90IHRocm93IGEgUmFuZ2VFcnJvciB5ZXQuXG4gICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE3NTogU2FmYXJpIHdpbGwgbm90IGZpcmUgYW4gZW5kZWQgZXZlbnQgaWYgdGhlIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBpcyB1bmNvbm5lY3RlZC5cbiAgICAgICAgYWRkU2lsZW50Q29ubmVjdGlvbihuYXRpdmVDb250ZXh0LCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICByZXR1cm4gbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3Iod2luZG93KSB7XG4gICAgICBpZiAod2luZG93ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnQXVkaW9Db250ZXh0JykpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5BdWRpb0NvbnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lmhhc093blByb3BlcnR5KCd3ZWJraXRBdWRpb0NvbnRleHQnKSA/IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBvdmVyd3JpdGVBY2Nlc3NvcnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgY2hhbm5lbENvdW50LCBpc05vZGVPZk5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlID0gbmF0aXZlQ29udGV4dC5kZXN0aW5hdGlvbjtcbiAgICAgICAgLy8gQnVnICMxMzI6IFNhZmFyaSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IGNoYW5uZWxDb3VudC5cbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudCAhPT0gY2hhbm5lbENvdW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudCA9IGNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzE2OTogU2FmYXJpIHRocm93cyBhbiBlcnJvciBvbiBlYWNoIGF0dGVtcHQgdG8gY2hhbmdlIHRoZSBjaGFubmVsQ291bnQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjODM6IFNhZmFyaSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IGNoYW5uZWxDb3VudE1vZGUuXG4gICAgICAgIGlmIChpc05vZGVPZk5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgJiYgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbENvdW50TW9kZSAhPT0gJ2V4cGxpY2l0Jykge1xuICAgICAgICAgIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjNDc6IFRoZSBBdWRpb0Rlc3RpbmF0aW9uTm9kZSBpbiBTYWZhcmkgZG9lcyBub3QgaW5pdGlhbGl6ZSB0aGUgbWF4Q2hhbm5lbENvdW50IHByb3BlcnR5IGNvcnJlY3RseS5cbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLm1heENoYW5uZWxDb3VudCA9PT0gMCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZSwgJ21heENoYW5uZWxDb3VudCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiBjaGFubmVsQ291bnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE2ODogTm8gYnJvd3NlciBkb2VzIHlldCBoYXZlIGFuIEF1ZGlvRGVzdGluYXRpb25Ob2RlIHdpdGggYW4gb3V0cHV0LlxuICAgICAgICB2YXIgZ2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiBjaGFubmVsQ291bnQsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICBnYWluOiAxXG4gICAgICAgIH0pO1xuICAgICAgICBvdmVyd3JpdGVBY2Nlc3NvcnMoZ2Fpbk5vZGUsICdjaGFubmVsQ291bnQnLCBmdW5jdGlvbiAoZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbChnYWluTm9kZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNldC5jYWxsKGdhaW5Ob2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAvLyBCdWcgIzE2OTogU2FmYXJpIHRocm93cyBhbiBlcnJvciBvbiBlYWNoIGF0dGVtcHQgdG8gY2hhbmdlIHRoZSBjaGFubmVsQ291bnQuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLm1heENoYW5uZWxDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBvdmVyd3JpdGVBY2Nlc3NvcnMoZ2Fpbk5vZGUsICdjaGFubmVsQ291bnRNb2RlJywgZnVuY3Rpb24gKGdldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwoZ2Fpbk5vZGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzZXQuY2FsbChnYWluTm9kZSwgdmFsdWUpO1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbENvdW50TW9kZSA9IHZhbHVlO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBvdmVyd3JpdGVBY2Nlc3NvcnMoZ2Fpbk5vZGUsICdjaGFubmVsSW50ZXJwcmV0YXRpb24nLCBmdW5jdGlvbiAoZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbChnYWluTm9kZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNldC5jYWxsKGdhaW5Ob2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdhaW5Ob2RlLCAnbWF4Q2hhbm5lbENvdW50Jywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLm1heENoYW5uZWxDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdG9kbyBUaGlzIHNob3VsZCBiZSBkaXNjb25uZWN0ZWQgd2hlbiB0aGUgY29udGV4dCBpcyBjbG9zZWQuXG4gICAgICAgIGdhaW5Ob2RlLmNvbm5lY3QobmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUpO1xuICAgICAgICByZXR1cm4gZ2Fpbk5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKHdpbmRvdykge1xuICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvV29ya2xldE5vZGUnKSA/IHdpbmRvdy5BdWRpb1dvcmtsZXROb2RlIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RDbG9uYWJpbGl0eU9mQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMgPSBmdW5jdGlvbiB0ZXN0Q2xvbmFiaWxpdHlPZkF1ZGlvV29ya2xldE5vZGVPcHRpb25zKGF1ZGlvV29ya2xldE5vZGVPcHRpb25zKSB7XG4gICAgICB2YXIgX01lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgICAgIHBvcnQxID0gX01lc3NhZ2VDaGFubmVsLnBvcnQxO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyBhcmUgbm90IGNsb25hYmxlLlxuICAgICAgICBwb3J0MS5wb3N0TWVzc2FnZShhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJGYoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGYoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGYoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFjdG9yeShjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIG1vbml0b3JDb25uZWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBiYXNlTGF0ZW5jeSwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yLCBuYW1lLCBwcm9jZXNzb3JDb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVBdWRpb1dvcmtsZXROb2RlID0gbmV3IG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvcihuYXRpdmVDb250ZXh0LCBuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBwYXRjaGVkRXZlbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB2YXIgb25wcm9jZXNzb3JlcnJvciA9IG51bGw7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCB7XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAqIEJ1ZyAjNjE6IE92ZXJ3cml0aW5nIHRoZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIGNoYW5uZWxDb3VudCBhbmQgY2hhbm5lbENvdW50TW9kZSBpcyBuZWNlc3NhcnkgYXMgbG9uZyBhcyBzb21lXG4gICAgICAgICAgICAgICAqIGJyb3dzZXJzIGhhdmUgbm8gbmF0aXZlIGltcGxlbWVudGF0aW9uIHRvIGFjaGlldmUgYSBjb25zaXN0ZW50IGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ2V4cGxpY2l0JztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTU2OiBDaHJvbWUgYW5kIEVkZ2UgZG8gbm90IHlldCBmaXJlIGFuIEVycm9yRXZlbnQuXG4gICAgICAgICAgICAgIG9ucHJvY2Vzc29yZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvbnByb2Nlc3NvcmVycm9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25wcm9jZXNzb3JlcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb1dvcmtsZXROb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2Nlc3NvcmVycm9yJywgb25wcm9jZXNzb3JlcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvbnByb2Nlc3NvcmVycm9yID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbnByb2Nlc3NvcmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigncHJvY2Vzc29yZXJyb3InLCBvbnByb2Nlc3NvcmVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSAncHJvY2Vzc29yZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdW5wYXRjaGVkRXZlbnRMaXN0ZW5lciA9IHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nID8gYXJnc1sxXSA6IF90eXBlb2YoYXJnc1sxXSkgPT09ICdvYmplY3QnICYmIGFyZ3NbMV0gIT09IG51bGwgJiYgdHlwZW9mIGFyZ3NbMV0uaGFuZGxlRXZlbnQgPT09ICdmdW5jdGlvbicgPyBhcmdzWzFdLmhhbmRsZUV2ZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmICh1bnBhdGNoZWRFdmVudExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRjaGVkRXZlbnRMaXN0ZW5lciA9IHBhdGNoZWRFdmVudExpc3RlbmVycy5nZXQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IHBhdGNoZWRFdmVudExpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTc4OiBDaHJvbWUgYW5kIEVkZ2UgZG8gZmlyZSBhbiBldmVudCBvZiB0eXBlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3Byb2Nlc3NvcmVycm9yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVucGF0Y2hlZEV2ZW50TGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5wYXRjaGVkRXZlbnRMaXN0ZW5lcihuZXcgRXJyb3JFdmVudChhcmdzWzBdLCBfb2JqZWN0U3ByZWFkJGYoe30sIGV2ZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgcGF0Y2hlZEV2ZW50TGlzdGVuZXJzLnNldCh1bnBhdGNoZWRFdmVudExpc3RlbmVyLCBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCdWcgIzE3ODogQ2hyb21lIGFuZCBFZGdlIGRvIGZpcmUgYW4gZXZlbnQgb2YgdHlwZSBlcnJvci5cbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgJ2Vycm9yJywgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIuY2FsbC5hcHBseShhZGRFdmVudExpc3RlbmVyLCBbbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0obmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5hZGRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSAncHJvY2Vzc29yZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSBwYXRjaGVkRXZlbnRMaXN0ZW5lcnMuZ2V0KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgaWYgKHBhdGNoZWRFdmVudExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlZEV2ZW50TGlzdGVuZXJzW1wiZGVsZXRlXCJdKGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzFdID0gcGF0Y2hlZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTc4OiBDaHJvbWUgYW5kIEVkZ2UgZG8gZmlyZSBhbiBldmVudCBvZiB0eXBlIGVycm9yLlxuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbChuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCAnZXJyb3InLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShuYXRpdmVBdWRpb1dvcmtsZXROb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEJ1ZyAjODY6IENocm9tZSBhbmQgRWRnZSBkbyBub3QgaW52b2tlIHRoZSBwcm9jZXNzKCkgZnVuY3Rpb24gaWYgdGhlIGNvcnJlc3BvbmRpbmcgQXVkaW9Xb3JrbGV0Tm9kZSBpcyB1bmNvbm5lY3RlZCBidXRcbiAgICAgICAgICAgICAqIGhhcyBhbiBvdXRwdXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm51bWJlck9mT3V0cHV0cyAhPT0gMCkge1xuICAgICAgICAgICAgICB2YXIgbmF0aXZlR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUuY29ubmVjdChuYXRpdmVHYWluTm9kZSkuY29ubmVjdChuYXRpdmVDb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgdmFyIHdoZW5Db25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuQ29ubmVjdGVkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVHYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZhciB3aGVuRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlR2Fpbk5vZGUuY29ubmVjdChuYXRpdmVDb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLy8gQHRvZG8gRGlzY29ubmVjdCB0aGUgY29ubmVjdGlvbiB3aGVuIHRoZSBwcm9jZXNzKCkgZnVuY3Rpb24gb2YgdGhlIEF1ZGlvV29ya2xldE5vZGUgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICAgICAgcmV0dXJuIG1vbml0b3JDb25uZWN0aW9ucyhuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCB3aGVuQ29ubmVjdGVkLCB3aGVuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVBdWRpb1dvcmtsZXROb2RlO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQnVnICM2MDogQ2hyb21lICYgRWRnZSB0aHJvdyBhbiBJbnZhbGlkU3RhdGVFcnJvciBpbnN0ZWFkIG9mIGEgTm90U3VwcG9ydGVkRXJyb3IuXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDExKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjNjE6IE9ubHkgQ2hyb21lICYgRWRnZSBoYXZlIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBdWRpb1dvcmtsZXROb2RlIHlldC5cbiAgICAgICAgaWYgKHByb2Nlc3NvckNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRlc3RDbG9uYWJpbGl0eU9mQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXIobmF0aXZlQ29udGV4dCwgYmFzZUxhdGVuY3ksIHByb2Nlc3NvckNvbnN0cnVjdG9yLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjb21wdXRlQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uIGNvbXB1dGVCdWZmZXJTaXplKGJhc2VMYXRlbmN5LCBzYW1wbGVSYXRlKSB7XG4gICAgICBpZiAoYmFzZUxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDUxMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLm1heCg1MTIsIE1hdGgubWluKDE2Mzg0LCBNYXRoLnBvdygyLCBNYXRoLnJvdW5kKE1hdGgubG9nMihiYXNlTGF0ZW5jeSAqIHNhbXBsZVJhdGUpKSkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNsb25lQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMgPSBmdW5jdGlvbiBjbG9uZUF1ZGlvV29ya2xldE5vZGVPcHRpb25zKGF1ZGlvV29ya2xldE5vZGVPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgX01lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgICAgICAgcG9ydDEgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDEsXG4gICAgICAgICAgcG9ydDIgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDI7XG4gICAgICAgIHBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgICBwb3J0Mi5jbG9zZSgpO1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQxLm9ubWVzc2FnZWVycm9yID0gZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xuICAgICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICAgICAgcG9ydDIuY2xvc2UoKTtcbiAgICAgICAgICByZWplY3QoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMgYXJlIG5vdCBjbG9uYWJsZS5cbiAgICAgICAgcG9ydDIucG9zdE1lc3NhZ2UoYXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBdWRpb1dvcmtsZXRQcm9jZXNzb3JQcm9taXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb2Nlc3NvckNvbnN0cnVjdG9yLCBhdWRpb1dvcmtsZXROb2RlT3B0aW9ucykge1xuICAgICAgICB2YXIgY2xvbmVkQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIGNsb25lQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMoYXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjbG9uZWRBdWRpb1dvcmtsZXROb2RlT3B0aW9ucyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IHByb2Nlc3NvckNvbnN0cnVjdG9yKGNsb25lZEF1ZGlvV29ya2xldE5vZGVPcHRpb25zKSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBdWRpb1dvcmtsZXRQcm9jZXNzb3JQcm9taXNlKF94LCBfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgdmFyIGNyZWF0ZUF1ZGlvV29ya2xldFByb2Nlc3NvciA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvV29ya2xldFByb2Nlc3NvcihuYXRpdmVDb250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCBwcm9jZXNzb3JDb25zdHJ1Y3RvciwgYXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMpIHtcbiAgICAgIHZhciBub2RlVG9Qcm9jZXNzb3JNYXAgPSBOT0RFX1RPX1BST0NFU1NPUl9NQVBTLmdldChuYXRpdmVDb250ZXh0KTtcbiAgICAgIGlmIChub2RlVG9Qcm9jZXNzb3JNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlVG9Qcm9jZXNzb3JNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICBOT0RFX1RPX1BST0NFU1NPUl9NQVBTLnNldChuYXRpdmVDb250ZXh0LCBub2RlVG9Qcm9jZXNzb3JNYXApO1xuICAgICAgfVxuICAgICAgdmFyIGF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2UgPSBjcmVhdGVBdWRpb1dvcmtsZXRQcm9jZXNzb3JQcm9taXNlKHByb2Nlc3NvckNvbnN0cnVjdG9yLCBhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyk7XG4gICAgICBub2RlVG9Qcm9jZXNzb3JNYXAuc2V0KG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIGF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2UpO1xuICAgICAgcmV0dXJuIGF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkZShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRlKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkZShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkZShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHIsIGUpIHsgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIXQpIHsgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyRmFjdG9yeShjb25uZWN0TXVsdGlwbGVPdXRwdXRzLCBjcmVhdGVJbmRleFNpemVFcnJvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgZGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cywgZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUsIGdldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMsIG1vbml0b3JDb25uZWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBiYXNlTGF0ZW5jeSwgcHJvY2Vzc29yQ29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubnVtYmVyT2ZJbnB1dHMgPT09IDAgJiYgb3B0aW9ucy5udW1iZXJPZk91dHB1dHMgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRDaGFubmVsQ291bnQgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50KSA/IG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50IDogQXJyYXkuZnJvbShvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudCk7XG4gICAgICAgIC8vIEB0b2RvIENoZWNrIGlmIGFueSBvZiB0aGUgY2hhbm5lbENvdW50IHZhbHVlcyBpcyBncmVhdGVyIHRoYW4gdGhlIGltcGxlbWVudGF0aW9uJ3MgbWF4aW11bSBudW1iZXIgb2YgY2hhbm5lbHMuXG4gICAgICAgIGlmIChvdXRwdXRDaGFubmVsQ291bnQuc29tZShmdW5jdGlvbiAoY2hhbm5lbENvdW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNoYW5uZWxDb3VudCA8IDE7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0Q2hhbm5lbENvdW50Lmxlbmd0aCAhPT0gb3B0aW9ucy5udW1iZXJPZk91dHB1dHMpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjNjE6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHN0YW5kYXJkIGJ1dCByZXF1aXJlZCBmb3IgdGhlIGZha2VyIHRvIHdvcmsuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW5uZWxDb3VudE1vZGUgIT09ICdleHBsaWNpdCcpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1iZXJPZklucHV0Q2hhbm5lbHMgPSBvcHRpb25zLmNoYW5uZWxDb3VudCAqIG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgIHZhciBudW1iZXJPZk91dHB1dENoYW5uZWxzID0gb3V0cHV0Q2hhbm5lbENvdW50LnJlZHVjZShmdW5jdGlvbiAoc3VtLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzdW0gKyB2YWx1ZTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHZhciBudW1iZXJPZlBhcmFtZXRlcnMgPSBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyA9PT0gdW5kZWZpbmVkID8gMCA6IHByb2Nlc3NvckNvbnN0cnVjdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzLmxlbmd0aDtcbiAgICAgICAgLy8gQnVnICM2MTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3RhbmRhcmQgYnV0IHJlcXVpcmVkIGZvciB0aGUgZmFrZXIgdG8gd29yay5cbiAgICAgICAgaWYgKG51bWJlck9mSW5wdXRDaGFubmVscyArIG51bWJlck9mUGFyYW1ldGVycyA+IDYgfHwgbnVtYmVyT2ZPdXRwdXRDaGFubmVscyA+IDYpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlQ2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICB2YXIgZ2Fpbk5vZGVzID0gW107XG4gICAgICAgIHZhciBpbnB1dENoYW5uZWxTcGxpdHRlck5vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5udW1iZXJPZklucHV0czsgaSArPSAxKSB7XG4gICAgICAgICAgZ2Fpbk5vZGVzLnB1c2goY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgICAgY2hhbm5lbENvdW50OiBvcHRpb25zLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG9wdGlvbnMuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogb3B0aW9ucy5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICBnYWluOiAxXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGlucHV0Q2hhbm5lbFNwbGl0dGVyTm9kZXMucHVzaChjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogb3B0aW9ucy5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgICAgbnVtYmVyT2ZPdXRwdXRzOiBvcHRpb25zLmNoYW5uZWxDb3VudFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uc3RhbnRTb3VyY2VOb2RlcyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyksXG4gICAgICAgICAgICBfc3RlcDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9zdGVwJHZhbHVlLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IF9zdGVwJHZhbHVlLm1heFZhbHVlLFxuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gX3N0ZXAkdmFsdWUubWluVmFsdWUsXG4gICAgICAgICAgICAgICAgbmFtZSA9IF9zdGVwJHZhbHVlLm5hbWU7XG4gICAgICAgICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnMucGFyYW1ldGVyRGF0YVtuYW1lXSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYXJhbWV0ZXJEYXRhW25hbWVdIDogZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQgPyAwIDogZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0LCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkID8gMCA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1heFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heFZhbHVlID09PSB1bmRlZmluZWQgPyBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCA6IG1heFZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWluVmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWluVmFsdWUgPT09IHVuZGVmaW5lZCA/IE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUIDogbWluVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2Rlcy5wdXNoKGNvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dENoYW5uZWxNZXJnZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgICAgICBudW1iZXJPZklucHV0czogTWF0aC5tYXgoMSwgbnVtYmVyT2ZJbnB1dENoYW5uZWxzICsgbnVtYmVyT2ZQYXJhbWV0ZXJzKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJ1ZmZlclNpemUgPSBjb21wdXRlQnVmZmVyU2l6ZShiYXNlTGF0ZW5jeSwgbmF0aXZlQ29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICAgICAgdmFyIHNjcmlwdFByb2Nlc3Nvck5vZGUgPSBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlKG5hdGl2ZUNvbnRleHQsIGJ1ZmZlclNpemUsIG51bWJlck9mSW5wdXRDaGFubmVscyArIG51bWJlck9mUGFyYW1ldGVycyxcbiAgICAgICAgLy8gQnVnICM4NzogT25seSBGaXJlZm94IHdpbGwgZmlyZSBhbiBBdWRpb1Byb2Nlc3NpbmdFdmVudCBpZiB0aGVyZSBpcyBubyBjb25uZWN0ZWQgb3V0cHV0LlxuICAgICAgICBNYXRoLm1heCgxLCBudW1iZXJPZk91dHB1dENoYW5uZWxzKSk7XG4gICAgICAgIHZhciBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiBNYXRoLm1heCgxLCBudW1iZXJPZk91dHB1dENoYW5uZWxzKSxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IE1hdGgubWF4KDEsIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLm51bWJlck9mT3V0cHV0czsgX2kgKz0gMSkge1xuICAgICAgICAgIG91dHB1dENoYW5uZWxNZXJnZXJOb2Rlcy5wdXNoKGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgICBudW1iZXJPZklucHV0czogb3V0cHV0Q2hhbm5lbENvdW50W19pXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLm51bWJlck9mSW5wdXRzOyBfaTIgKz0gMSkge1xuICAgICAgICAgIGdhaW5Ob2Rlc1tfaTJdLmNvbm5lY3QoaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2Rlc1tfaTJdKTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wdGlvbnMuY2hhbm5lbENvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICAgIGlucHV0Q2hhbm5lbFNwbGl0dGVyTm9kZXNbX2kyXS5jb25uZWN0KGlucHV0Q2hhbm5lbE1lcmdlck5vZGUsIGosIF9pMiAqIG9wdGlvbnMuY2hhbm5lbENvdW50ICsgaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbWV0ZXJNYXAgPSBuZXcgUmVhZE9ubHlNYXAocHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMgPT09IHVuZGVmaW5lZCA/IFtdIDogcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMubWFwKGZ1bmN0aW9uIChfcmVmLCBpbmRleCkge1xuICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGUgPSBjb25zdGFudFNvdXJjZU5vZGVzW2luZGV4XTtcbiAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuY29ubmVjdChpbnB1dENoYW5uZWxNZXJnZXJOb2RlLCAwLCBudW1iZXJPZklucHV0Q2hhbm5lbHMgKyBpbmRleCk7XG4gICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlLnN0YXJ0KDApO1xuICAgICAgICAgIHJldHVybiBbbmFtZSwgY29uc3RhbnRTb3VyY2VOb2RlLm9mZnNldF07XG4gICAgICAgIH0pKTtcbiAgICAgICAgaW5wdXRDaGFubmVsTWVyZ2VyTm9kZS5jb25uZWN0KHNjcmlwdFByb2Nlc3Nvck5vZGUpO1xuICAgICAgICB2YXIgY2hhbm5lbEludGVycHJldGF0aW9uID0gb3B0aW9ucy5jaGFubmVsSW50ZXJwcmV0YXRpb247XG4gICAgICAgIHZhciBvbnByb2Nlc3NvcmVycm9yID0gbnVsbDtcbiAgICAgICAgLy8gQnVnICM4NzogRXhwb3NlIGF0IGxlYXN0IG9uZSBvdXRwdXQgdG8gbWFrZSB0aGlzIG5vZGUgY29ubmVjdGFibGUuXG4gICAgICAgIHZhciBvdXRwdXRBdWRpb05vZGVzID0gb3B0aW9ucy5udW1iZXJPZk91dHB1dHMgPT09IDAgPyBbc2NyaXB0UHJvY2Vzc29yTm9kZV0gOiBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXM7XG4gICAgICAgIHZhciBuYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXIgPSB7XG4gICAgICAgICAgZ2V0IGJ1ZmZlclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyU2l6ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50KF8pIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjNjE6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHN0YW5kYXJkIGJ1dCByZXF1aXJlZCBmb3IgdGhlIGZha2VyIHRvIHdvcmsuXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jaGFubmVsQ291bnRNb2RlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudE1vZGUoXykge1xuICAgICAgICAgICAgLy8gQnVnICM2MTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3RhbmRhcmQgYnV0IHJlcXVpcmVkIGZvciB0aGUgZmFrZXIgdG8gd29yay5cbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbEludGVycHJldGF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxJbnRlcnByZXRhdGlvbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsSW50ZXJwcmV0YXRpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9nYWluTm9kZXMgPSBnYWluTm9kZXM7IF9pMyA8IF9nYWluTm9kZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgICB2YXIgZ2Fpbk5vZGUgPSBfZ2Fpbk5vZGVzW19pM107XG4gICAgICAgICAgICAgIGdhaW5Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLmNvbnRleHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgaW5wdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdhaW5Ob2RlcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZklucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG51bWJlck9mT3V0cHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm51bWJlck9mT3V0cHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBvbnByb2Nlc3NvcmVycm9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ucHJvY2Vzc29yZXJyb3I7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgb25wcm9jZXNzb3JlcnJvcih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbnByb2Nlc3NvcmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9jZXNzb3JlcnJvcicsIG9ucHJvY2Vzc29yZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25wcm9jZXNzb3JlcnJvciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25wcm9jZXNzb3JlcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBuYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXIuYWRkRXZlbnRMaXN0ZW5lcigncHJvY2Vzc29yZXJyb3InLCBvbnByb2Nlc3NvcmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwYXJhbWV0ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlck1hcDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwb3J0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VDaGFubmVsLnBvcnQyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLmFkZEV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25uZWN0OiBjb25uZWN0TXVsdGlwbGVPdXRwdXRzLmJpbmQobnVsbCwgb3V0cHV0QXVkaW9Ob2RlcyksXG4gICAgICAgICAgZGlzY29ubmVjdDogZGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cy5iaW5kKG51bGwsIG91dHB1dEF1ZGlvTm9kZXMpLFxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5kaXNwYXRjaEV2ZW50KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXRjaGVkRXZlbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgICAgdmFyIHVucGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSB0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3NbMV0gOiBfdHlwZW9mKGFyZ3NbMV0pID09PSAnb2JqZWN0JyAmJiBhcmdzWzFdICE9PSBudWxsICYmIHR5cGVvZiBhcmdzWzFdLmhhbmRsZUV2ZW50ID09PSAnZnVuY3Rpb24nID8gYXJnc1sxXS5oYW5kbGVFdmVudCA6IG51bGw7XG4gICAgICAgICAgICAgIGlmICh1bnBhdGNoZWRFdmVudExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGNoZWRFdmVudExpc3RlbmVyID0gcGF0Y2hlZEV2ZW50TGlzdGVuZXJzLmdldChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IHBhdGNoZWRFdmVudExpc3RlbmVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhcmdzWzFdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lKG5hdGl2ZUNvbnRleHQuY3VycmVudFRpbWUsIG5hdGl2ZUNvbnRleHQuc2FtcGxlUmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bnBhdGNoZWRFdmVudExpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcGF0Y2hlZEV2ZW50TGlzdGVuZXJzLnNldCh1bnBhdGNoZWRFdmVudExpc3RlbmVyLCBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyLmNhbGwobWVzc2FnZUNoYW5uZWwucG9ydDEsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0obWVzc2FnZUNoYW5uZWwucG9ydDEuYWRkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdtZXNzYWdlJykge1xuICAgICAgICAgICAgICB2YXIgcGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSBwYXRjaGVkRXZlbnRMaXN0ZW5lcnMuZ2V0KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICBpZiAocGF0Y2hlZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhdGNoZWRFdmVudExpc3RlbmVyc1tcImRlbGV0ZVwiXShhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICBhcmdzWzFdID0gcGF0Y2hlZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW1vdmVFdmVudExpc3RlbmVyLmNhbGwobWVzc2FnZUNoYW5uZWwucG9ydDEsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0obWVzc2FnZUNoYW5uZWwucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHZhciBvbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZUNoYW5uZWwucG9ydDEsICdvbm1lc3NhZ2UnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gb25tZXNzYWdlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25tZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25tZXNzYWdlID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbm1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvY2Vzc29yQ29uc3RydWN0b3IucHJvdG90eXBlLnBvcnQgPSBtZXNzYWdlQ2hhbm5lbC5wb3J0MTtcbiAgICAgICAgdmFyIGF1ZGlvV29ya2xldFByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgIHZhciBhdWRpb1dvcmtsZXRQcm9jZXNzb3JQcm9taXNlID0gY3JlYXRlQXVkaW9Xb3JrbGV0UHJvY2Vzc29yKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlciwgcHJvY2Vzc29yQ29uc3RydWN0b3IsIG9wdGlvbnMpO1xuICAgICAgICBhdWRpb1dvcmtsZXRQcm9jZXNzb3JQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRXcmtsdFByY3Nzcikge1xuICAgICAgICAgIHJldHVybiBhdWRpb1dvcmtsZXRQcm9jZXNzb3IgPSBkV3JrbHRQcmNzc3I7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW5wdXRzID0gY3JlYXRlTmVzdGVkQXJyYXlzKG9wdGlvbnMubnVtYmVyT2ZJbnB1dHMsIG9wdGlvbnMuY2hhbm5lbENvdW50KTtcbiAgICAgICAgdmFyIG91dHB1dHMgPSBjcmVhdGVOZXN0ZWRBcnJheXMob3B0aW9ucy5udW1iZXJPZk91dHB1dHMsIG91dHB1dENoYW5uZWxDb3VudCk7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMgPT09IHVuZGVmaW5lZCA/IFtdIDogcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMucmVkdWNlKGZ1bmN0aW9uIChwcm10cnMsIF9yZWYyKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBwcm10cnMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCBuZXcgRmxvYXQzMkFycmF5KDEyOCkpKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzY29ubmVjdE91dHB1dHNHcmFwaCA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3RPdXRwdXRzR3JhcGgoKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzID4gMCkge1xuICAgICAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5kaXNjb25uZWN0KG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ID0gMDsgX2k0IDwgb3B0aW9ucy5udW1iZXJPZk91dHB1dHM7IF9pNCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGUgPSBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXNbX2k0XTtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBvdXRwdXRDaGFubmVsQ291bnRbX2k0XTsgX2ogKz0gMSkge1xuICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlLmRpc2Nvbm5lY3Qob3V0cHV0Q2hhbm5lbE1lcmdlck5vZGUsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgKyBfaiwgX2opO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArPSBvdXRwdXRDaGFubmVsQ291bnRbX2k0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhY3RpdmVJbnB1dEluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkZXByZWNhdGlvblxuICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgdmFyIGlucHV0QnVmZmVyID0gX3JlZjMuaW5wdXRCdWZmZXIsXG4gICAgICAgICAgICBvdXRwdXRCdWZmZXIgPSBfcmVmMy5vdXRwdXRCdWZmZXI7XG4gICAgICAgICAgaWYgKGF1ZGlvV29ya2xldFByb2Nlc3NvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUlucHV0cyA9IGdldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyKTtcbiAgICAgICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoX2k1KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7IF9qMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvcHRpb25zLmNoYW5uZWxDb3VudDsgayArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBjb3B5RnJvbUNoYW5uZWwoaW5wdXRCdWZmZXIsIGlucHV0c1tfajJdLCBrLCBrLCBfaTUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NvckNvbnN0cnVjdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzLmZvckVhY2goZnVuY3Rpb24gKF9yZWY0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmNC5uYW1lO1xuICAgICAgICAgICAgICAgICAgY29weUZyb21DaGFubmVsKGlucHV0QnVmZmVyLCBwYXJhbWV0ZXJzLCBuYW1lLCBudW1iZXJPZklucHV0Q2hhbm5lbHMgKyBpbmRleCwgX2k1KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBvcHRpb25zLm51bWJlck9mSW5wdXRzOyBfajMgKz0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBvdXRwdXRDaGFubmVsQ291bnRbX2ozXTsgX2sgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGJ5dGVMZW5ndGggd2lsbCBiZSAwIHdoZW4gdGhlIEFycmF5QnVmZmVyIHdhcyB0cmFuc2ZlcnJlZC5cbiAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzW19qM11bX2tdLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0c1tfajNdW19rXSA9IG5ldyBGbG9hdDMyQXJyYXkoMTI4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcG90ZW50aWFsbHlFbXB0eUlucHV0cyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUlucHV0ID0gYWN0aXZlSW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVJbnB1dC5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVJbnB1dEluZGV4ZXMuc2V0KGluZGV4LCBidWZmZXJTaXplIC8gMTI4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gYWN0aXZlSW5wdXRJbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZXZlcnkoZnVuY3Rpb24gKGNoYW5uZWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsRGF0YS5ldmVyeShmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhbXBsZSA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVJbnB1dEluZGV4ZXNbXCJkZWxldGVcIl0oaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUlucHV0SW5kZXhlcy5zZXQoaW5kZXgsIGNvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlU291cmNlRmxhZyA9IGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lKG5hdGl2ZUNvbnRleHQuY3VycmVudFRpbWUgKyBfaTUgLyBuYXRpdmVDb250ZXh0LnNhbXBsZVJhdGUsIG5hdGl2ZUNvbnRleHQuc2FtcGxlUmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvV29ya2xldFByb2Nlc3Nvci5wcm9jZXNzKHBvdGVudGlhbGx5RW1wdHlJbnB1dHMsIG91dHB1dHMsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlzQWN0aXZlID0gYWN0aXZlU291cmNlRmxhZztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfajQgPSAwLCBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ID0gMDsgX2o0IDwgb3B0aW9ucy5udW1iZXJPZk91dHB1dHM7IF9qNCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfazIgPSAwOyBfazIgPCBvdXRwdXRDaGFubmVsQ291bnRbX2o0XTsgX2syICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVRvQ2hhbm5lbChvdXRwdXRCdWZmZXIsIG91dHB1dHNbX2o0XSwgX2syLCBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ICsgX2syLCBfaTUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArPSBvdXRwdXRDaGFubmVsQ291bnRbX2o0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXIuZGlzcGF0Y2hFdmVudChuZXcgRXJyb3JFdmVudCgncHJvY2Vzc29yZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICBjb2xubzogZXJyb3IuY29sbm8sXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZXJyb3IuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICBsaW5lbm86IGVycm9yLmxpbmVubyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qNSA9IDA7IF9qNSA8IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7IF9qNSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBnYWluTm9kZXNbX2o1XS5kaXNjb25uZWN0KGlucHV0Q2hhbm5lbFNwbGl0dGVyTm9kZXNbX2o1XSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfazMgPSAwOyBfazMgPCBvcHRpb25zLmNoYW5uZWxDb3VudDsgX2szICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2Rlc1tfaTVdLmRpc2Nvbm5lY3QoaW5wdXRDaGFubmVsTWVyZ2VyTm9kZSwgX2szLCBfajUgKiBvcHRpb25zLmNoYW5uZWxDb3VudCArIF9rMyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2o2ID0gMDsgX2o2IDwgbGVuZ3RoOyBfajYgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RhbnRTb3VyY2VOb2RlID0gY29uc3RhbnRTb3VyY2VOb2Rlc1tfajZdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuZGlzY29ubmVjdChpbnB1dENoYW5uZWxNZXJnZXJOb2RlLCAwLCBudW1iZXJPZklucHV0Q2hhbm5lbHMgKyBfajYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxNZXJnZXJOb2RlLmRpc2Nvbm5lY3Qoc2NyaXB0UHJvY2Vzc29yTm9kZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5vbmF1ZGlvcHJvY2VzcyA9IG51bGw7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RPdXRwdXRzR3JhcGgoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdEZha2VHcmFwaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMTsgLy8gYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGJ1ZmZlclNpemU7IF9pNSArPSAxMjgpIHtcbiAgICAgICAgICAgICAgaWYgKF9sb29wMihfaTUpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAvLyBCdWcgIzg3OiBPbmx5IEZpcmVmb3ggd2lsbCBmaXJlIGFuIEF1ZGlvUHJvY2Vzc2luZ0V2ZW50IGlmIHRoZXJlIGlzIG5vIGNvbm5lY3RlZCBvdXRwdXQuXG4gICAgICAgIHZhciBuYXRpdmVHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbm5lY3RGYWtlR3JhcGggPSBmdW5jdGlvbiBjb25uZWN0RmFrZUdyYXBoKCkge1xuICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLmNvbm5lY3QobmF0aXZlR2Fpbk5vZGUpLmNvbm5lY3QobmF0aXZlQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkaXNjb25uZWN0RmFrZUdyYXBoID0gZnVuY3Rpb24gZGlzY29ubmVjdEZha2VHcmFwaCgpIHtcbiAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLmRpc2Nvbm5lY3QobmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgIG5hdGl2ZUdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdoZW5Db25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuQ29ubmVjdGVkKCkge1xuICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgZGlzY29ubmVjdEZha2VHcmFwaCgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzID4gMCkge1xuICAgICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLmNvbm5lY3Qob3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaTYgPSAwLCBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ID0gMDsgX2k2IDwgb3B0aW9ucy5udW1iZXJPZk91dHB1dHM7IF9pNiArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZSA9IG91dHB1dENoYW5uZWxNZXJnZXJOb2Rlc1tfaTZdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfajcgPSAwOyBfajcgPCBvdXRwdXRDaGFubmVsQ291bnRbX2k2XTsgX2o3ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlLmNvbm5lY3Qob3V0cHV0Q2hhbm5lbE1lcmdlck5vZGUsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgKyBfajcsIF9qNyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArPSBvdXRwdXRDaGFubmVsQ291bnRbX2k2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2hlbkRpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5EaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICBjb25uZWN0RmFrZUdyYXBoKCk7XG4gICAgICAgICAgICBkaXNjb25uZWN0T3V0cHV0c0dyYXBoKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3RGYWtlR3JhcGgoKTtcbiAgICAgICAgcmV0dXJuIG1vbml0b3JDb25uZWN0aW9ucyhuYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXIsIHdoZW5Db25uZWN0ZWQsIHdoZW5EaXNjb25uZWN0ZWQpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUJpcXVhZEZpbHRlck5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVCaXF1YWRGaWx0ZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgb3B0aW9ucyk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgb3B0aW9ucywgJ1EnKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLCBvcHRpb25zLCAnZGV0dW5lJyk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgb3B0aW9ucywgJ2ZyZXF1ZW5jeScpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIG9wdGlvbnMsICdnYWluJyk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgb3B0aW9ucywgJ3R5cGUnKTtcbiAgICAgIHJldHVybiBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGVGYWN0b3J5KG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCB3cmFwQ2hhbm5lbE1lcmdlck5vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIob3B0aW9ucy5udW1iZXJPZklucHV0cyk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEJ1ZyAjMjA6IFNhZmFyaSByZXF1aXJlcyBhIGNvbm5lY3Rpb24gb2YgYW55IGtpbmQgdG8gdHJlYXQgdGhlIGlucHV0IHNpZ25hbCBjb3JyZWN0bHkuXG4gICAgICAgICAqIEB0b2RvIFVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm8gd2F5IHRvIHRlc3QgZm9yIHRoaXMgYmVoYXZpb3IgaW4gYSBzeW5jaHJvbm91cyBmYXNoaW9uIHdoaWNoIGlzIHdoeSB0ZXN0aW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mXG4gICAgICAgICAqIHRoZSB3ZWJraXRBdWRpb0NvbnRleHQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgaGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvci5uYW1lID09PSAnd2Via2l0QXVkaW9Db250ZXh0Jykge1xuICAgICAgICAgIHdyYXBDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVDb250ZXh0LCBuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB3cmFwQ2hhbm5lbFNwbGl0dGVyTm9kZSA9IGZ1bmN0aW9uIHdyYXBDaGFubmVsU3BsaXR0ZXJOb2RlKGNoYW5uZWxTcGxpdHRlck5vZGUpIHtcbiAgICAgIHZhciBjaGFubmVsQ291bnQgPSBjaGFubmVsU3BsaXR0ZXJOb2RlLm51bWJlck9mT3V0cHV0cztcbiAgICAgIC8vIEJ1ZyAjOTc6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gY2hhbmdlIHRoZSBjaGFubmVsQ291bnQgdG8gc29tZXRoaW5nIG90aGVyIHRoYW4gaXRzIGluaXRpYWwgdmFsdWUuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhbm5lbFNwbGl0dGVyTm9kZSwgJ2NoYW5uZWxDb3VudCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYW5uZWxDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGNoYW5uZWxDb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnVnICMzMDogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBjaGFuZ2UgdGhlIGNoYW5uZWxDb3VudE1vZGUgdG8gc29tZXRoaW5nIG90aGVyIHRoYW4gZXhwbGljaXQuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhbm5lbFNwbGl0dGVyTm9kZSwgJ2NoYW5uZWxDb3VudE1vZGUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAnZXhwbGljaXQnO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ2V4cGxpY2l0Jykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnVnICMzMjogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBjaGFuZ2UgdGhlIGNoYW5uZWxJbnRlcnByZXRhdGlvbiB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBkaXNjcmV0ZS5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFubmVsU3BsaXR0ZXJOb2RlLCAnY2hhbm5lbEludGVycHJldGF0aW9uJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gJ2Rpc2NyZXRlJztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09ICdkaXNjcmV0ZScpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIob3B0aW9ucy5udW1iZXJPZk91dHB1dHMpO1xuICAgICAgLy8gQnVnICM5NjogU2FmYXJpIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgY2hhbm5lbENvdW50LlxuICAgICAgLy8gQnVnICMyOTogU2FmYXJpIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgY2hhbm5lbENvdW50TW9kZS5cbiAgICAgIC8vIEJ1ZyAjMzE6IFNhZmFyaSBkb2VzIG5vdCBoYXZlIHRoZSBjb3JyZWN0IGNoYW5uZWxJbnRlcnByZXRhdGlvbi5cbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgb3B0aW9ucyk7XG4gICAgICAvLyBCdWcgIzI5LCAjMzAsICMzMSwgIzMyLCAjOTYgJiAjOTc6IE9ubHkgQ2hyb21lLCBFZGdlICYgRmlyZWZveCBwYXJ0aWFsbHkgc3VwcG9ydCB0aGUgc3BlYyB5ZXQuXG4gICAgICB3cmFwQ2hhbm5lbFNwbGl0dGVyTm9kZShuYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlKTtcbiAgICAgIHJldHVybiBuYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUZhY3RvcnkoYWRkU2lsZW50Q29ubmVjdGlvbiwgY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlciwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQnVnICM2MjogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgQ29uc3RhbnRTb3VyY2VOb2Rlcy5cbiAgICAgICAgaWYgKG5hdGl2ZUNvbnRleHQuY3JlYXRlQ29uc3RhbnRTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlcihuYXRpdmVDb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVDb25zdGFudFNvdXJjZSgpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIG9wdGlvbnMsICdvZmZzZXQnKTtcbiAgICAgICAgLy8gQnVnICM0NDogU2FmYXJpIGRvZXMgbm90IHRocm93IGEgUmFuZ2VFcnJvciB5ZXQuXG4gICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMobmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzQ0OiBPbmx5IEZpcmVmb3ggZG9lcyBub3QgdGhyb3cgYSBSYW5nZUVycm9yIHlldC5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjMTc1OiBTYWZhcmkgd2lsbCBub3QgZmlyZSBhbiBlbmRlZCBldmVudCBpZiB0aGUgQ29uc3RhbnRTb3VyY2VOb2RlIGlzIHVuY29ubmVjdGVkLlxuICAgICAgICBhZGRTaWxlbnRDb25uZWN0aW9uKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgIHJldHVybiBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgaW50ZXJjZXB0Q29ubmVjdGlvbnMgPSBmdW5jdGlvbiBpbnRlcmNlcHRDb25uZWN0aW9ucyhvcmlnaW5hbCwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIG9yaWdpbmFsLmNvbm5lY3QgPSBpbnRlcmNlcHRvci5jb25uZWN0LmJpbmQoaW50ZXJjZXB0b3IpO1xuICAgICAgb3JpZ2luYWwuZGlzY29ubmVjdCA9IGludGVyY2VwdG9yLmRpc2Nvbm5lY3QuYmluZChpbnRlcmNlcHRvcik7XG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgfTtcblxuICAgIHZhciBfZXhjbHVkZWQkMyA9IFtcIm9mZnNldFwiXTtcbiAgICBmdW5jdGlvbiBvd25LZXlzJGQoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFrZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFrZXJGYWN0b3J5KGFkZFNpbGVudENvbm5lY3Rpb24sIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIG1vbml0b3JDb25uZWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBfcmVmKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgICAgICBhdWRpb05vZGVPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQzKTtcbiAgICAgICAgdmFyIGF1ZGlvQnVmZmVyID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMiwgNDQxMDApO1xuICAgICAgICB2YXIgYXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICBsb29wRW5kOiAwLFxuICAgICAgICAgIGxvb3BTdGFydDogMCxcbiAgICAgICAgICBwbGF5YmFja1JhdGU6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBnYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkZChfb2JqZWN0U3ByZWFkJGQoe30sIGF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IG9mZnNldFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEJ1ZyAjNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY29weUZyb21DaGFubmVsKCkgYW5kIGNvcHlUb0NoYW5uZWwoKS5cbiAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgIC8vIEJ1ZyAjOTU6IFNhZmFyaSBkb2VzIG5vdCBwbGF5IG9yIGxvb3Agb25lIHNhbXBsZSBidWZmZXJzLlxuICAgICAgICBjaGFubmVsRGF0YVswXSA9IDE7XG4gICAgICAgIGNoYW5uZWxEYXRhWzFdID0gMTtcbiAgICAgICAgYXVkaW9CdWZmZXJTb3VyY2VOb2RlLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUubG9vcCA9IHRydWU7XG4gICAgICAgIHZhciBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlciA9IHtcbiAgICAgICAgICBnZXQgYnVmZmVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGdhaW5Ob2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnQodmFsdWUpIHtcbiAgICAgICAgICAgIGdhaW5Ob2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2Fpbk5vZGUuY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnRNb2RlKHZhbHVlKSB7XG4gICAgICAgICAgICBnYWluTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbEludGVycHJldGF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdhaW5Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsSW50ZXJwcmV0YXRpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGdhaW5Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2Fpbk5vZGUuY29udGV4dDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBpbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZJbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXJTb3VyY2VOb2RlLm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG51bWJlck9mT3V0cHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBnYWluTm9kZS5udW1iZXJPZk91dHB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGdhaW5Ob2RlLmdhaW47XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgb25lbmRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlclNvdXJjZU5vZGUub25lbmRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBvbmVuZGVkKHZhbHVlKSB7XG4gICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUub25lbmRlZCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXJTb3VyY2VOb2RlLmRpc3BhdGNoRXZlbnQoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXJTb3VyY2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydC5jYWxsKGF1ZGlvQnVmZmVyU291cmNlTm9kZSwgd2hlbik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcC5jYWxsKGF1ZGlvQnVmZmVyU291cmNlTm9kZSwgd2hlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgd2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5jb25uZWN0KGdhaW5Ob2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdoZW5EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuRGlzY29ubmVjdGVkKCkge1xuICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuZGlzY29ubmVjdChnYWluTm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEJ1ZyAjMTc1OiBTYWZhcmkgd2lsbCBub3QgZmlyZSBhbiBlbmRlZCBldmVudCBpZiB0aGUgQXVkaW9CdWZmZXJTb3VyY2VOb2RlIGlzIHVuY29ubmVjdGVkLlxuICAgICAgICBhZGRTaWxlbnRDb25uZWN0aW9uKG5hdGl2ZUNvbnRleHQsIGF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgIHJldHVybiBtb25pdG9yQ29ubmVjdGlvbnMoaW50ZXJjZXB0Q29ubmVjdGlvbnMobmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFrZXIsIGdhaW5Ob2RlKSwgd2hlbkNvbm5lY3RlZCwgd2hlbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQ29udm9sdmVyTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVDb252b2x2ZXJOb2RlRmFjdG9yeShjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgb3ZlcndyaXRlQWNjZXNzb3JzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUNvbnZvbHZlck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZUNvbnZvbHZlck5vZGUsIG9wdGlvbnMpO1xuICAgICAgICAvLyBUaGUgbm9ybWFsaXplIHByb3BlcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgc2V0dGluZyB0aGUgYnVmZmVyLlxuICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlTm9ybWFsaXphdGlvbiA9PT0gbmF0aXZlQ29udm9sdmVyTm9kZS5ub3JtYWxpemUpIHtcbiAgICAgICAgICBuYXRpdmVDb252b2x2ZXJOb2RlLm5vcm1hbGl6ZSA9ICFvcHRpb25zLmRpc2FibGVOb3JtYWxpemF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVDb252b2x2ZXJOb2RlLCBvcHRpb25zLCAnYnVmZmVyJyk7XG4gICAgICAgIC8vIEJ1ZyAjMTEzOiBTYWZhcmkgZG9lcyBhbGxvdyB0byBzZXQgdGhlIGNoYW5uZWxDb3VudCB0byBhIHZhbHVlIGxhcmdlciB0aGFuIDIuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW5uZWxDb3VudCA+IDIpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIG92ZXJ3cml0ZUFjY2Vzc29ycyhuYXRpdmVDb252b2x2ZXJOb2RlLCAnY2hhbm5lbENvdW50JywgZnVuY3Rpb24gKGdldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwobmF0aXZlQ29udm9sdmVyTm9kZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXQuY2FsbChuYXRpdmVDb252b2x2ZXJOb2RlLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJ1ZyAjMTE0OiBTYWZhcmkgYWxsb3dzIHRvIHNldCB0aGUgY2hhbm5lbENvdW50TW9kZSB0byAnbWF4Jy5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbENvdW50TW9kZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIG92ZXJ3cml0ZUFjY2Vzc29ycyhuYXRpdmVDb252b2x2ZXJOb2RlLCAnY2hhbm5lbENvdW50TW9kZScsIGZ1bmN0aW9uIChnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKG5hdGl2ZUNvbnZvbHZlck5vZGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0LmNhbGwobmF0aXZlQ29udm9sdmVyTm9kZSwgdmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmF0aXZlQ29udm9sdmVyTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVEZWxheU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVEZWxheU5vZGUobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgdmFyIG5hdGl2ZURlbGF5Tm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlRGVsYXkob3B0aW9ucy5tYXhEZWxheVRpbWUpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVEZWxheU5vZGUsIG9wdGlvbnMpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZURlbGF5Tm9kZSwgb3B0aW9ucywgJ2RlbGF5VGltZScpO1xuICAgICAgcmV0dXJuIG5hdGl2ZURlbGF5Tm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZUZhY3RvcnkoY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEJ1ZyAjMTA4OiBTYWZhcmkgYWxsb3dzIGEgY2hhbm5lbENvdW50IG9mIHRocmVlIGFuZCBhYm92ZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbENvdW50ID4gMikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxMDk6IE9ubHkgQ2hyb21lIGFuZCBGaXJlZm94IGRpc2FsbG93IGEgY2hhbm5lbENvdW50TW9kZSBvZiAnbWF4Jy5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbENvdW50TW9kZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBvcHRpb25zLCAnYXR0YWNrJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBvcHRpb25zLCAna25lZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSwgb3B0aW9ucywgJ3JhdGlvJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBvcHRpb25zLCAncmVsZWFzZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSwgb3B0aW9ucywgJ3RocmVzaG9sZCcpO1xuICAgICAgICByZXR1cm4gbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVHYWluTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuYXRpdmVHYWluTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVHYWluTm9kZSwgb3B0aW9ucyk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlR2Fpbk5vZGUsIG9wdGlvbnMsICdnYWluJyk7XG4gICAgICByZXR1cm4gbmF0aXZlR2Fpbk5vZGU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWtlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBiYXNlTGF0ZW5jeSwgb3B0aW9ucykge1xuICAgICAgICAvLyBCdWcgIzk6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IElJUkZpbHRlck5vZGVzLlxuICAgICAgICBpZiAobmF0aXZlQ29udGV4dC5jcmVhdGVJSVJGaWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlRmFrZXIobmF0aXZlQ29udGV4dCwgYmFzZUxhdGVuY3ksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgZGVmaW5lcyB0aGUgcGFyYW1ldGVycyBvZiBjcmVhdGVJSVJGaWx0ZXIoKSBhcyBhcnJheXMgb2YgbnVtYmVycy5cbiAgICAgICAgdmFyIG5hdGl2ZUlJUkZpbHRlck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUlJUkZpbHRlcihvcHRpb25zLmZlZWRmb3J3YXJkLCBvcHRpb25zLmZlZWRiYWNrKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVJSVJGaWx0ZXJOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUlJUkZpbHRlck5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkaXZpZGUoYSwgYikge1xuICAgICAgdmFyIGRlbm9taW5hdG9yID0gYlswXSAqIGJbMF0gKyBiWzFdICogYlsxXTtcbiAgICAgIHJldHVybiBbKGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0pIC8gZGVub21pbmF0b3IsIChhWzFdICogYlswXSAtIGFbMF0gKiBiWzFdKSAvIGRlbm9taW5hdG9yXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgICAgcmV0dXJuIFthWzBdICogYlswXSAtIGFbMV0gKiBiWzFdLCBhWzBdICogYlsxXSArIGFbMV0gKiBiWzBdXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXZhbHVhdGVQb2x5bm9taWFsKGNvZWZmaWNpZW50LCB6KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gWzAsIDBdO1xuICAgICAgZm9yICh2YXIgaSA9IGNvZWZmaWNpZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IG11bHRpcGx5KHJlc3VsdCwgeik7XG4gICAgICAgIHJlc3VsdFswXSArPSBjb2VmZmljaWVudFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlRmFrZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZUZha2VyRmFjdG9yeShjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBiYXNlTGF0ZW5jeSwgX3JlZikge1xuICAgICAgICB2YXIgY2hhbm5lbENvdW50ID0gX3JlZi5jaGFubmVsQ291bnQsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZSA9IF9yZWYuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb24gPSBfcmVmLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICBmZWVkYmFjayA9IF9yZWYuZmVlZGJhY2ssXG4gICAgICAgICAgZmVlZGZvcndhcmQgPSBfcmVmLmZlZWRmb3J3YXJkO1xuICAgICAgICB2YXIgYnVmZmVyU2l6ZSA9IGNvbXB1dGVCdWZmZXJTaXplKGJhc2VMYXRlbmN5LCBuYXRpdmVDb250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICB2YXIgY29udmVydGVkRmVlZGJhY2sgPSBmZWVkYmFjayBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSA/IGZlZWRiYWNrIDogbmV3IEZsb2F0NjRBcnJheShmZWVkYmFjayk7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRGZWVkZm9yd2FyZCA9IGZlZWRmb3J3YXJkIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ID8gZmVlZGZvcndhcmQgOiBuZXcgRmxvYXQ2NEFycmF5KGZlZWRmb3J3YXJkKTtcbiAgICAgICAgdmFyIGZlZWRiYWNrTGVuZ3RoID0gY29udmVydGVkRmVlZGJhY2subGVuZ3RoO1xuICAgICAgICB2YXIgZmVlZGZvcndhcmRMZW5ndGggPSBjb252ZXJ0ZWRGZWVkZm9yd2FyZC5sZW5ndGg7XG4gICAgICAgIHZhciBtaW5MZW5ndGggPSBNYXRoLm1pbihmZWVkYmFja0xlbmd0aCwgZmVlZGZvcndhcmRMZW5ndGgpO1xuICAgICAgICBpZiAoZmVlZGJhY2tMZW5ndGggPT09IDAgfHwgZmVlZGJhY2tMZW5ndGggPiAyMCkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnZlcnRlZEZlZWRiYWNrWzBdID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGZvcndhcmRMZW5ndGggPT09IDAgfHwgZmVlZGZvcndhcmRMZW5ndGggPiAyMCkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnZlcnRlZEZlZWRmb3J3YXJkWzBdID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkRmVlZGJhY2tbMF0gIT09IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlZWRmb3J3YXJkTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnZlcnRlZEZlZWRmb3J3YXJkW2ldIC89IGNvbnZlcnRlZEZlZWRiYWNrWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgZmVlZGJhY2tMZW5ndGg7IF9pICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnZlcnRlZEZlZWRiYWNrW19pXSAvPSBjb252ZXJ0ZWRGZWVkYmFja1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdFByb2Nlc3Nvck5vZGUgPSBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlKG5hdGl2ZUNvbnRleHQsIGJ1ZmZlclNpemUsIGNoYW5uZWxDb3VudCwgY2hhbm5lbENvdW50KTtcbiAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5jaGFubmVsQ291bnQgPSBjaGFubmVsQ291bnQ7XG4gICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuY2hhbm5lbENvdW50TW9kZSA9IGNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gY2hhbm5lbEludGVycHJldGF0aW9uO1xuICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gMzI7XG4gICAgICAgIHZhciBidWZmZXJJbmRleGVzID0gW107XG4gICAgICAgIHZhciB4QnVmZmVycyA9IFtdO1xuICAgICAgICB2YXIgeUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2hhbm5lbENvdW50OyBfaTIgKz0gMSkge1xuICAgICAgICAgIGJ1ZmZlckluZGV4ZXMucHVzaCgwKTtcbiAgICAgICAgICB2YXIgeEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICB2YXIgeUJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICB4QnVmZmVyLmZpbGwoMCk7XG4gICAgICAgICAgeUJ1ZmZlci5maWxsKDApO1xuICAgICAgICAgIHhCdWZmZXJzLnB1c2goeEJ1ZmZlcik7XG4gICAgICAgICAgeUJ1ZmZlcnMucHVzaCh5QnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHZhciBpbnB1dEJ1ZmZlciA9IGV2ZW50LmlucHV0QnVmZmVyO1xuICAgICAgICAgIHZhciBvdXRwdXRCdWZmZXIgPSBldmVudC5vdXRwdXRCdWZmZXI7XG4gICAgICAgICAgdmFyIG51bWJlck9mQ2hhbm5lbHMgPSBpbnB1dEJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bWJlck9mQ2hhbm5lbHM7IF9pMyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShfaTMpO1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IG91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShfaTMpO1xuICAgICAgICAgICAgYnVmZmVySW5kZXhlc1tfaTNdID0gZmlsdGVyQnVmZmVyKGNvbnZlcnRlZEZlZWRiYWNrLCBmZWVkYmFja0xlbmd0aCwgY29udmVydGVkRmVlZGZvcndhcmQsIGZlZWRmb3J3YXJkTGVuZ3RoLCBtaW5MZW5ndGgsIHhCdWZmZXJzW19pM10sIHlCdWZmZXJzW19pM10sIGJ1ZmZlckluZGV4ZXNbX2kzXSwgYnVmZmVyTGVuZ3RoLCBpbnB1dCwgb3V0cHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBueXF1aXN0ID0gbmF0aXZlQ29udGV4dC5zYW1wbGVSYXRlIC8gMjtcbiAgICAgICAgdmFyIG5hdGl2ZUlJUkZpbHRlck5vZGVGYWtlciA9IHtcbiAgICAgICAgICBnZXQgYnVmZmVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJTaXplO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnQodmFsdWUpIHtcbiAgICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50TW9kZSh2YWx1ZSkge1xuICAgICAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbEludGVycHJldGF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxJbnRlcnByZXRhdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuY29udGV4dDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBpbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NjcmlwdFByb2Nlc3Nvck5vZGVdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG51bWJlck9mSW5wdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZPdXRwdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUubnVtYmVyT2ZPdXRwdXRzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIERpc3NhbGxvdyBhZGRpbmcgYW4gYXVkaW9wcm9jZXNzIGxpc3RlbmVyLlxuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5kaXNwYXRjaEV2ZW50KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRGcmVxdWVuY3lSZXNwb25zZTogZnVuY3Rpb24gZ2V0RnJlcXVlbmN5UmVzcG9uc2UoZnJlcXVlbmN5SHosIG1hZ1Jlc3BvbnNlLCBwaGFzZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoZnJlcXVlbmN5SHoubGVuZ3RoICE9PSBtYWdSZXNwb25zZS5sZW5ndGggfHwgbWFnUmVzcG9uc2UubGVuZ3RoICE9PSBwaGFzZVJlc3BvbnNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBmcmVxdWVuY3lIei5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBsZW5ndGg7IF9pNCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBvbWVnYSA9IC1NYXRoLlBJICogKGZyZXF1ZW5jeUh6W19pNF0gLyBueXF1aXN0KTtcbiAgICAgICAgICAgICAgdmFyIHogPSBbTWF0aC5jb3Mob21lZ2EpLCBNYXRoLnNpbihvbWVnYSldO1xuICAgICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gZXZhbHVhdGVQb2x5bm9taWFsKGNvbnZlcnRlZEZlZWRmb3J3YXJkLCB6KTtcbiAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gZXZhbHVhdGVQb2x5bm9taWFsKGNvbnZlcnRlZEZlZWRiYWNrLCB6KTtcbiAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gZGl2aWRlKG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICAgICAgICAgICAgICBtYWdSZXNwb25zZVtfaTRdID0gTWF0aC5zcXJ0KHJlc3BvbnNlWzBdICogcmVzcG9uc2VbMF0gKyByZXNwb25zZVsxXSAqIHJlc3BvbnNlWzFdKTtcbiAgICAgICAgICAgICAgcGhhc2VSZXNwb25zZVtfaTRdID0gTWF0aC5hdGFuMihyZXNwb25zZVsxXSwgcmVzcG9uc2VbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW50ZXJjZXB0Q29ubmVjdGlvbnMobmF0aXZlSUlSRmlsdGVyTm9kZUZha2VyLCBzY3JpcHRQcm9jZXNzb3JOb2RlKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUobmF0aXZlQXVkaW9Db250ZXh0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShvcHRpb25zLm1lZGlhRWxlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZShuYXRpdmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSwgb3B0aW9ucyk7XG4gICAgICAvLyBCdWcgIzE3NDogU2FmYXJpIGRvZXMgZXhwb3NlIGEgd3JvbmcgbnVtYmVyT2ZPdXRwdXRzLlxuICAgICAgaWYgKG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUubnVtYmVyT2ZPdXRwdXRzID09PSAxKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCAnbnVtYmVyT2ZPdXRwdXRzJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZShuYXRpdmVBdWRpb0NvbnRleHQsIF9yZWYpIHtcbiAgICAgIHZhciBtZWRpYVN0cmVhbSA9IF9yZWYubWVkaWFTdHJlYW07XG4gICAgICB2YXIgYXVkaW9TdHJlYW1UcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgLypcbiAgICAgICAqIEJ1ZyAjMTUxOiBTYWZhcmkgZG9lcyBub3QgdXNlIHRoZSBhdWRpbyB0cmFjayBhcyBpbnB1dCBhbnltb3JlIGlmIGl0IGdldHMgcmVtb3ZlZCBmcm9tIHRoZSBtZWRpYVN0cmVhbSBhZnRlciBjb25zdHJ1Y3Rpb24uXG4gICAgICAgKiBCdWcgIzE1OTogU2FmYXJpIHBpY2tzIHRoZSBmaXJzdCBhdWRpbyB0cmFjayBpZiB0aGUgTWVkaWFTdHJlYW0gaGFzIG1vcmUgdGhhbiBvbmUgYXVkaW8gdHJhY2suXG4gICAgICAgKi9cbiAgICAgIGF1ZGlvU3RyZWFtVHJhY2tzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuaWQgPCBiLmlkID8gLTEgOiBhLmlkID4gYi5pZCA/IDEgOiAwO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlsdGVyZWRBdWRpb1N0cmVhbVRyYWNrcyA9IGF1ZGlvU3RyZWFtVHJhY2tzLnNsaWNlKDAsIDEpO1xuICAgICAgdmFyIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShmaWx0ZXJlZEF1ZGlvU3RyZWFtVHJhY2tzKSk7XG4gICAgICAvKlxuICAgICAgICogQnVnICMxNTEgJiAjMTU5OiBUaGUgZ2l2ZW4gbWVkaWFTdHJlYW0gZ2V0cyByZWNvbnN0cnVjdGVkIGJlZm9yZSBpdCBnZXRzIHBhc3NlZCB0byB0aGUgbmF0aXZlIG5vZGUgd2hpY2ggaXMgd2h5IHRoZSBhY2Nlc3NvciBuZWVkc1xuICAgICAgICogdG8gYmUgb3ZlcndyaXR0ZW4gYXMgaXQgd291bGQgb3RoZXJ3aXNlIGV4cG9zZSB0aGUgcmVjb25zdHJ1Y3RlZCB2ZXJzaW9uLlxuICAgICAgICovXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUsICdtZWRpYVN0cmVhbScsIHtcbiAgICAgICAgdmFsdWU6IG1lZGlhU3RyZWFtXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUZhY3RvcnkoY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVBdWRpb0NvbnRleHQsIF9yZWYpIHtcbiAgICAgICAgdmFyIG1lZGlhU3RyZWFtVHJhY2sgPSBfcmVmLm1lZGlhU3RyZWFtVHJhY2s7XG4gICAgICAgIC8vIEJ1ZyAjMTIxOiBPbmx5IEZpcmVmb3ggZG9lcyB5ZXQgc3VwcG9ydCB0aGUgTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZS5cbiAgICAgICAgaWYgKHR5cGVvZiBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1UcmFja1NvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1UcmFja1NvdXJjZShtZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVkaWFTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW21lZGlhU3RyZWFtVHJhY2tdKTtcbiAgICAgICAgdmFyIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1lZGlhU3RyZWFtKTtcbiAgICAgICAgLy8gQnVnICMxMjA6IEZpcmVmb3ggZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG1lZGlhU3RyZWFtIGhhcyBubyBhdWRpbyB0cmFjay5cbiAgICAgICAgaWYgKG1lZGlhU3RyZWFtVHJhY2sua2luZCAhPT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxNzI6IFNhZmFyaSBhbGxvd3MgdG8gY3JlYXRlIGEgTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgd2l0aCBhbiBPZmZsaW5lQXVkaW9Db250ZXh0LlxuICAgICAgICBpZiAoaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUF1ZGlvQ29udGV4dCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcih3aW5kb3cpIHtcbiAgICAgIGlmICh3aW5kb3cgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCcpID8gd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGVGYWN0b3J5KGFkZFNpbGVudENvbm5lY3Rpb24sIGNhY2hlVGVzdFJlc3VsdCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlT3NjaWxsYXRvck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVPc2NpbGxhdG9yTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVPc2NpbGxhdG9yTm9kZSwgb3B0aW9ucywgJ2RldHVuZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlT3NjaWxsYXRvck5vZGUsIG9wdGlvbnMsICdmcmVxdWVuY3knKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucGVyaW9kaWNXYXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuYXRpdmVPc2NpbGxhdG9yTm9kZS5zZXRQZXJpb2RpY1dhdmUob3B0aW9ucy5wZXJpb2RpY1dhdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVPc2NpbGxhdG9yTm9kZSwgb3B0aW9ucywgJ3R5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzQ0OiBPbmx5IENocm9tZSAmIEVkZ2UgdGhyb3cgYSBSYW5nZUVycm9yIHlldC5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVPc2NpbGxhdG9yTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxOTogU2FmYXJpIGRvZXMgbm90IGlnbm9yZSBjYWxscyB0byBzdG9wKCkgb2YgYW4gYWxyZWFkeSBzdG9wcGVkIEF1ZGlvQnVmZmVyU291cmNlTm9kZS5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxscyhuYXRpdmVPc2NpbGxhdG9yTm9kZSwgbmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM0NDogT25seSBGaXJlZm94IGRvZXMgbm90IHRocm93IGEgUmFuZ2VFcnJvciB5ZXQuXG4gICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMobmF0aXZlT3NjaWxsYXRvck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjMTc1OiBTYWZhcmkgd2lsbCBub3QgZmlyZSBhbiBlbmRlZCBldmVudCBpZiB0aGUgT3NjaWxsYXRvck5vZGUgaXMgdW5jb25uZWN0ZWQuXG4gICAgICAgIGFkZFNpbGVudENvbm5lY3Rpb24obmF0aXZlQ29udGV4dCwgbmF0aXZlT3NjaWxsYXRvck5vZGUpO1xuICAgICAgICByZXR1cm4gbmF0aXZlT3NjaWxsYXRvck5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlUGFubmVyTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFjdG9yeShjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFrZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlUGFubmVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG4gICAgICAgIC8vIEJ1ZyAjMTI0OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZnlpbmcgdGhlIG9yaWVudGF0aW9uIGFuZCB0aGUgcG9zaXRpb24gd2l0aCBBdWRpb1BhcmFtcy5cbiAgICAgICAgaWYgKG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25YID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmF0aXZlUGFubmVyTm9kZUZha2VyKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlUGFubmVyTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAnb3JpZW50YXRpb25YJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAnb3JpZW50YXRpb25ZJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAnb3JpZW50YXRpb25aJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAncG9zaXRpb25YJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAncG9zaXRpb25ZJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAncG9zaXRpb25aJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAnY29uZUlubmVyQW5nbGUnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdjb25lT3V0ZXJBbmdsZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlUGFubmVyTm9kZSwgb3B0aW9ucywgJ2NvbmVPdXRlckdhaW4nKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdkaXN0YW5jZU1vZGVsJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAnbWF4RGlzdGFuY2UnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdwYW5uaW5nTW9kZWwnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdyZWZEaXN0YW5jZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlUGFubmVyTm9kZSwgb3B0aW9ucywgJ3JvbGxvZmZGYWN0b3InKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVBhbm5lck5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2V4Y2x1ZGVkJDIgPSBbXCJjb25lSW5uZXJBbmdsZVwiLCBcImNvbmVPdXRlckFuZ2xlXCIsIFwiY29uZU91dGVyR2FpblwiLCBcImRpc3RhbmNlTW9kZWxcIiwgXCJtYXhEaXN0YW5jZVwiLCBcIm9yaWVudGF0aW9uWFwiLCBcIm9yaWVudGF0aW9uWVwiLCBcIm9yaWVudGF0aW9uWlwiLCBcInBhbm5pbmdNb2RlbFwiLCBcInBvc2l0aW9uWFwiLCBcInBvc2l0aW9uWVwiLCBcInBvc2l0aW9uWlwiLCBcInJlZkRpc3RhbmNlXCIsIFwicm9sbG9mZkZhY3RvclwiXTtcbiAgICBmdW5jdGlvbiBvd25LZXlzJGMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgY3JlYXRlTmF0aXZlUGFubmVyTm9kZUZha2VyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGVGYWtlckZhY3RvcnkoY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlLCBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlLCBnZXRGaXJzdFNhbXBsZSwgbW9uaXRvckNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIF9yZWYpIHtcbiAgICAgICAgdmFyIGNvbmVJbm5lckFuZ2xlID0gX3JlZi5jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICBjb25lT3V0ZXJBbmdsZSA9IF9yZWYuY29uZU91dGVyQW5nbGUsXG4gICAgICAgICAgY29uZU91dGVyR2FpbiA9IF9yZWYuY29uZU91dGVyR2FpbixcbiAgICAgICAgICBkaXN0YW5jZU1vZGVsID0gX3JlZi5kaXN0YW5jZU1vZGVsLFxuICAgICAgICAgIG1heERpc3RhbmNlID0gX3JlZi5tYXhEaXN0YW5jZSxcbiAgICAgICAgICBvcmllbnRhdGlvblggPSBfcmVmLm9yaWVudGF0aW9uWCxcbiAgICAgICAgICBvcmllbnRhdGlvblkgPSBfcmVmLm9yaWVudGF0aW9uWSxcbiAgICAgICAgICBvcmllbnRhdGlvblogPSBfcmVmLm9yaWVudGF0aW9uWixcbiAgICAgICAgICBwYW5uaW5nTW9kZWwgPSBfcmVmLnBhbm5pbmdNb2RlbCxcbiAgICAgICAgICBwb3NpdGlvblggPSBfcmVmLnBvc2l0aW9uWCxcbiAgICAgICAgICBwb3NpdGlvblkgPSBfcmVmLnBvc2l0aW9uWSxcbiAgICAgICAgICBwb3NpdGlvblogPSBfcmVmLnBvc2l0aW9uWixcbiAgICAgICAgICByZWZEaXN0YW5jZSA9IF9yZWYucmVmRGlzdGFuY2UsXG4gICAgICAgICAgcm9sbG9mZkZhY3RvciA9IF9yZWYucm9sbG9mZkZhY3RvcixcbiAgICAgICAgICBhdWRpb05vZGVPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQyKTtcbiAgICAgICAgdmFyIHBhbm5lck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuICAgICAgICAvLyBCdWcgIzEyNTogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHlldC5cbiAgICAgICAgaWYgKGF1ZGlvTm9kZU9wdGlvbnMuY2hhbm5lbENvdW50ID4gMikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxMjY6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB5ZXQuXG4gICAgICAgIGlmIChhdWRpb05vZGVPcHRpb25zLmNoYW5uZWxDb3VudE1vZGUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKHBhbm5lck5vZGUsIGF1ZGlvTm9kZU9wdGlvbnMpO1xuICAgICAgICB2YXIgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyA9IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZSdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoYW5uZWxNZXJnZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgICAgIG51bWJlck9mSW5wdXRzOiA2XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGlucHV0R2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBhdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICBnYWluOiAxXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uWEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBvcmllbnRhdGlvbllHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgb3JpZW50YXRpb25aR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uWEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBwb3NpdGlvbllHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgcG9zaXRpb25aR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHNjcmlwdFByb2Nlc3Nvck5vZGUgPSBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlKG5hdGl2ZUNvbnRleHQsIDI1NiwgNiwgMSk7XG4gICAgICAgIHZhciB3YXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxXSksXG4gICAgICAgICAgb3ZlcnNhbXBsZTogJ25vbmUnXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGxhc3RPcmllbnRhdGlvbiA9IFtvcmllbnRhdGlvblgsIG9yaWVudGF0aW9uWSwgb3JpZW50YXRpb25aXTtcbiAgICAgICAgdmFyIGxhc3RQb3NpdGlvbiA9IFtwb3NpdGlvblgsIHBvc2l0aW9uWSwgcG9zaXRpb25aXTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkZXByZWNhdGlvblxuICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIGlucHV0QnVmZmVyID0gX3JlZjIuaW5wdXRCdWZmZXI7XG4gICAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gW2dldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDApLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCAxKSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgMildO1xuICAgICAgICAgIGlmIChvcmllbnRhdGlvbi5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbGFzdE9yaWVudGF0aW9uW2luZGV4XTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcGFubmVyTm9kZS5zZXRPcmllbnRhdGlvbi5hcHBseShwYW5uZXJOb2RlLCBvcmllbnRhdGlvbik7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgIGxhc3RPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcG9zaXRvbiA9IFtnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCAzKSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgNCksIGdldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDUpXTtcbiAgICAgICAgICBpZiAocG9zaXRvbi5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbGFzdFBvc2l0aW9uW2luZGV4XTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcGFubmVyTm9kZS5zZXRQb3NpdGlvbi5hcHBseShwYW5uZXJOb2RlLCBwb3NpdG9uKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgICAgbGFzdFBvc2l0aW9uID0gcG9zaXRvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmllbnRhdGlvbllHYWluTm9kZS5nYWluLCAnZGVmYXVsdFZhbHVlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yaWVudGF0aW9uWkdhaW5Ob2RlLmdhaW4sICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocG9zaXRpb25YR2Fpbk5vZGUuZ2FpbiwgJ2RlZmF1bHRWYWx1ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwb3NpdGlvbllHYWluTm9kZS5nYWluLCAnZGVmYXVsdFZhbHVlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvc2l0aW9uWkdhaW5Ob2RlLmdhaW4sICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmF0aXZlUGFubmVyTm9kZUZha2VyID0ge1xuICAgICAgICAgIGdldCBidWZmZXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzEyNTogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHlldC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5jaGFubmVsQ291bnRNb2RlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudE1vZGUodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTI2OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgeWV0LlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnbWF4Jykge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb247XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbEludGVycHJldGF0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgcGFubmVyTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjb25lSW5uZXJBbmdsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmNvbmVJbm5lckFuZ2xlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNvbmVJbm5lckFuZ2xlKHZhbHVlKSB7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLmNvbmVJbm5lckFuZ2xlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY29uZU91dGVyQW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5jb25lT3V0ZXJBbmdsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjb25lT3V0ZXJBbmdsZSh2YWx1ZSkge1xuICAgICAgICAgICAgcGFubmVyTm9kZS5jb25lT3V0ZXJBbmdsZSA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNvbmVPdXRlckdhaW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5jb25lT3V0ZXJHYWluO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNvbmVPdXRlckdhaW4odmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTI3OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gSW52YWxpZFN0YXRlRXJyb3IgeWV0LlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhbm5lck5vZGUuY29uZU91dGVyR2FpbiA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5jb250ZXh0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGRpc3RhbmNlTW9kZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGRpc3RhbmNlTW9kZWwodmFsdWUpIHtcbiAgICAgICAgICAgIHBhbm5lck5vZGUuZGlzdGFuY2VNb2RlbCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGlucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRHYWluTm9kZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbWF4RGlzdGFuY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5tYXhEaXN0YW5jZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBtYXhEaXN0YW5jZSh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQnVnICMxMjg6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB5ZXQuXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYW5uZXJOb2RlLm1heERpc3RhbmNlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZJbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5udW1iZXJPZklucHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZk91dHB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5udW1iZXJPZk91dHB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgb3JpZW50YXRpb25YKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uWEdhaW5Ob2RlLmdhaW47XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgb3JpZW50YXRpb25ZKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uWUdhaW5Ob2RlLmdhaW47XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgb3JpZW50YXRpb25aKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uWkdhaW5Ob2RlLmdhaW47XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgcGFubmluZ01vZGVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhbm5lck5vZGUucGFubmluZ01vZGVsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IHBhbm5pbmdNb2RlbCh2YWx1ZSkge1xuICAgICAgICAgICAgcGFubmVyTm9kZS5wYW5uaW5nTW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwb3NpdGlvblgoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25YR2Fpbk5vZGUuZ2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwb3NpdGlvblkoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25ZR2Fpbk5vZGUuZ2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwb3NpdGlvblooKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25aR2Fpbk5vZGUuZ2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCByZWZEaXN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLnJlZkRpc3RhbmNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IHJlZkRpc3RhbmNlKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzEyOTogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHlldC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhbm5lck5vZGUucmVmRGlzdGFuY2UgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCByb2xsb2ZmRmFjdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhbm5lck5vZGUucm9sbG9mZkZhY3RvcjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCByb2xsb2ZmRmFjdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzEzMDogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHlldC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhbm5lck5vZGUucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuZGlzcGF0Y2hFdmVudChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29uZUlubmVyQW5nbGUgIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5jb25lSW5uZXJBbmdsZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5jb25lSW5uZXJBbmdsZSA9IGNvbmVJbm5lckFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25lT3V0ZXJBbmdsZSAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLmNvbmVPdXRlckFuZ2xlKSB7XG4gICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUZha2VyLmNvbmVPdXRlckFuZ2xlID0gY29uZU91dGVyQW5nbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmVPdXRlckdhaW4gIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5jb25lT3V0ZXJHYWluKSB7XG4gICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUZha2VyLmNvbmVPdXRlckdhaW4gPSBjb25lT3V0ZXJHYWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXN0YW5jZU1vZGVsICE9PSBuYXRpdmVQYW5uZXJOb2RlRmFrZXIuZGlzdGFuY2VNb2RlbCkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5kaXN0YW5jZU1vZGVsID0gZGlzdGFuY2VNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4RGlzdGFuY2UgIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5tYXhEaXN0YW5jZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvblggIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5vcmllbnRhdGlvblgudmFsdWUpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIub3JpZW50YXRpb25YLnZhbHVlID0gb3JpZW50YXRpb25YO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvblkgIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5vcmllbnRhdGlvblkudmFsdWUpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIub3JpZW50YXRpb25ZLnZhbHVlID0gb3JpZW50YXRpb25ZO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvblogIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5vcmllbnRhdGlvbloudmFsdWUpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIub3JpZW50YXRpb25aLnZhbHVlID0gb3JpZW50YXRpb25aO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYW5uaW5nTW9kZWwgIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wYW5uaW5nTW9kZWwpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIucGFubmluZ01vZGVsID0gcGFubmluZ01vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvblggIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wb3NpdGlvblgudmFsdWUpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb25YO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvblkgIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wb3NpdGlvblkudmFsdWUpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIucG9zaXRpb25ZLnZhbHVlID0gcG9zaXRpb25ZO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvblogIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wb3NpdGlvbloudmFsdWUpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIucG9zaXRpb25aLnZhbHVlID0gcG9zaXRpb25aO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZEaXN0YW5jZSAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLnJlZkRpc3RhbmNlKSB7XG4gICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUZha2VyLnJlZkRpc3RhbmNlID0gcmVmRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvbGxvZmZGYWN0b3IgIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5yb2xsb2ZmRmFjdG9yKSB7XG4gICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUZha2VyLnJvbGxvZmZGYWN0b3IgPSByb2xsb2ZmRmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0T3JpZW50YXRpb25bMF0gIT09IDEgfHwgbGFzdE9yaWVudGF0aW9uWzFdICE9PSAwIHx8IGxhc3RPcmllbnRhdGlvblsyXSAhPT0gMCkge1xuICAgICAgICAgIHBhbm5lck5vZGUuc2V0T3JpZW50YXRpb24uYXBwbHkocGFubmVyTm9kZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhc3RPcmllbnRhdGlvbikpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb3NpdGlvblswXSAhPT0gMCB8fCBsYXN0UG9zaXRpb25bMV0gIT09IDAgfHwgbGFzdFBvc2l0aW9uWzJdICE9PSAwKSB7XG4gICAgICAgICAgcGFubmVyTm9kZS5zZXRQb3NpdGlvbi5hcHBseShwYW5uZXJOb2RlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFzdFBvc2l0aW9uKSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgfVxuICAgICAgICB2YXIgd2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KHBhbm5lck5vZGUpO1xuICAgICAgICAgIC8vIEJ1ZyAjMTE5OiBTYWZhcmkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCB0aGUgV2F2ZVNoYXBlck5vZGUuXG4gICAgICAgICAgY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlKGlucHV0R2Fpbk5vZGUsIHdhdmVTaGFwZXJOb2RlLCAwLCAwKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5jb25uZWN0KG9yaWVudGF0aW9uWEdhaW5Ob2RlKS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAwKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5jb25uZWN0KG9yaWVudGF0aW9uWUdhaW5Ob2RlKS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAxKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5jb25uZWN0KG9yaWVudGF0aW9uWkdhaW5Ob2RlKS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAyKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5jb25uZWN0KHBvc2l0aW9uWEdhaW5Ob2RlKS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAzKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5jb25uZWN0KHBvc2l0aW9uWUdhaW5Ob2RlKS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCA0KTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5jb25uZWN0KHBvc2l0aW9uWkdhaW5Ob2RlKS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCA1KTtcbiAgICAgICAgICBjaGFubmVsTWVyZ2VyTm9kZS5jb25uZWN0KHNjcmlwdFByb2Nlc3Nvck5vZGUpLmNvbm5lY3QobmF0aXZlQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3aGVuRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QocGFubmVyTm9kZSk7XG4gICAgICAgICAgLy8gQnVnICMxMTk6IFNhZmFyaSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IHRoZSBXYXZlU2hhcGVyTm9kZS5cbiAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZShpbnB1dEdhaW5Ob2RlLCB3YXZlU2hhcGVyTm9kZSwgMCwgMCk7XG4gICAgICAgICAgd2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChvcmllbnRhdGlvblhHYWluTm9kZSk7XG4gICAgICAgICAgb3JpZW50YXRpb25YR2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgd2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChvcmllbnRhdGlvbllHYWluTm9kZSk7XG4gICAgICAgICAgb3JpZW50YXRpb25ZR2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgd2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChvcmllbnRhdGlvblpHYWluTm9kZSk7XG4gICAgICAgICAgb3JpZW50YXRpb25aR2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgd2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChwb3NpdGlvblhHYWluTm9kZSk7XG4gICAgICAgICAgcG9zaXRpb25YR2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgd2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChwb3NpdGlvbllHYWluTm9kZSk7XG4gICAgICAgICAgcG9zaXRpb25ZR2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgd2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChwb3NpdGlvblpHYWluTm9kZSk7XG4gICAgICAgICAgcG9zaXRpb25aR2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgY2hhbm5lbE1lcmdlck5vZGUuZGlzY29ubmVjdChzY3JpcHRQcm9jZXNzb3JOb2RlKTtcbiAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLmRpc2Nvbm5lY3QobmF0aXZlQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb25pdG9yQ29ubmVjdGlvbnMoaW50ZXJjZXB0Q29ubmVjdGlvbnMobmF0aXZlUGFubmVyTm9kZUZha2VyLCBwYW5uZXJOb2RlKSwgd2hlbkNvbm5lY3RlZCwgd2hlbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlUGVyaW9kaWNXYXZlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVBlcmlvZGljV2F2ZUZhY3RvcnkoY3JlYXRlSW5kZXhTaXplRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgX3JlZikge1xuICAgICAgICB2YXIgZGlzYWJsZU5vcm1hbGl6YXRpb24gPSBfcmVmLmRpc2FibGVOb3JtYWxpemF0aW9uLFxuICAgICAgICAgIGltYWcgPSBfcmVmLmltYWcsXG4gICAgICAgICAgcmVhbCA9IF9yZWYucmVhbDtcbiAgICAgICAgLy8gQnVnICMxODA6IFNhZmFyaSBkb2VzIG5vdCBhbGxvdyB0byB1c2Ugb3JkaW5hcnkgYXJyYXlzLlxuICAgICAgICB2YXIgY29udmVydGVkSW1hZyA9IGltYWcgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBpbWFnIDogbmV3IEZsb2F0MzJBcnJheShpbWFnKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFJlYWwgPSByZWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gcmVhbCA6IG5ldyBGbG9hdDMyQXJyYXkocmVhbCk7XG4gICAgICAgIHZhciBuYXRpdmVQZXJpb2RpY1dhdmUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZVBlcmlvZGljV2F2ZShjb252ZXJ0ZWRSZWFsLCBjb252ZXJ0ZWRJbWFnLCB7XG4gICAgICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCdWcgIzE4MTogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIEluZGV4U2l6ZUVycm9yIHNvIGZhciBpZiB0aGUgZ2l2ZW4gYXJyYXlzIGhhdmUgbGVzcyB0aGFuIHR3byB2YWx1ZXMuXG4gICAgICAgIGlmIChBcnJheS5mcm9tKGltYWcpLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVQZXJpb2RpY1dhdmU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUobmF0aXZlQ29udGV4dCwgYnVmZmVyU2l6ZSwgbnVtYmVyT2ZJbnB1dENoYW5uZWxzLCBudW1iZXJPZk91dHB1dENoYW5uZWxzKSB7XG4gICAgICByZXR1cm4gbmF0aXZlQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoYnVmZmVyU2l6ZSwgbnVtYmVyT2ZJbnB1dENoYW5uZWxzLCBudW1iZXJPZk91dHB1dENoYW5uZWxzKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBkZXByZWNhdGlvblxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlU3RlcmVvUGFubmVyTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFjdG9yeShjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFrZXIsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxDb3VudE1vZGUgPSBvcHRpb25zLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEJ1ZyAjMTA1OiBUaGUgY2hhbm5lbENvdW50TW9kZSBvZiAnY2xhbXBlZC1tYXgnIHNob3VsZCBiZSBzdXBwb3J0ZWQuIEhvd2V2ZXIgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHdyaXRlIGEgcG9seWZpbGwgZm9yIFNhZmFyaVxuICAgICAgICAgKiB3aGljaCBzdXBwb3J0cyBpdCBhbmQgdGhlcmVmb3JlIGl0IGNhbid0IGJlIHN1cHBvcnRlZCBhdCBhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoY2hhbm5lbENvdW50TW9kZSA9PT0gJ2NsYW1wZWQtbWF4Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxMDU6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBTdGVyZW9QYW5uZXJOb2RlLlxuICAgICAgICBpZiAobmF0aXZlQ29udGV4dC5jcmVhdGVTdGVyZW9QYW5uZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFrZXIobmF0aXZlQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZVN0ZXJlb1Bhbm5lcigpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlU3RlcmVvUGFubmVyTm9kZSwgb3B0aW9ucywgJ3BhbicpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBCdWcgIzEwNTogVGhlIGNoYW5uZWxDb3VudE1vZGUgb2YgJ2NsYW1wZWQtbWF4JyBzaG91bGQgYmUgc3VwcG9ydGVkLiBIb3dldmVyIGl0IGlzIG5vdCBwb3NzaWJsZSB0byB3cml0ZSBhIHBvbHlmaWxsIGZvciBTYWZhcmlcbiAgICAgICAgICogd2hpY2ggc3VwcG9ydHMgaXQgYW5kIHRoZXJlZm9yZSBpdCBjYW4ndCBiZSBzdXBwb3J0ZWQgYXQgYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUsICdjaGFubmVsQ291bnRNb2RlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBjaGFubmVsQ291bnRNb2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2V4Y2x1ZGVkJDEgPSBbXCJjaGFubmVsQ291bnRcIiwgXCJjaGFubmVsQ291bnRNb2RlXCIsIFwicGFuXCJdO1xuICAgIGZ1bmN0aW9uIG93bktleXMkYihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRiKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFrZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlU3RlcmVvUGFubmVyTm9kZUZha2VyRmFjdG9yeShjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgbW9uaXRvckNvbm5lY3Rpb25zKSB7XG4gICAgICAvLyBUaGUgY3VydmUgaGFzIGEgc2l6ZSBvZiAxNGJpdCBwbHVzIDEgdmFsdWUgdG8gaGF2ZSBhbiBleGFjdCByZXByZXNlbnRhdGlvbiBmb3IgemVyby4gVGhpcyB2YWx1ZSBoYXMgYmVlbiBkZXRlcm1pbmVkIGV4cGVyaW1lbnRhbGx5LlxuICAgICAgdmFyIENVUlZFX1NJWkUgPSAxNjM4NTtcbiAgICAgIHZhciBEQ19DVVJWRSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDFdKTtcbiAgICAgIHZhciBIQUxGX1BJID0gTWF0aC5QSSAvIDI7XG4gICAgICB2YXIgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyA9IHtcbiAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZSdcbiAgICAgIH07XG4gICAgICB2YXIgU0lOR0xFX0NIQU5ORUxfV0FWRV9TSEFQRVJfT1BUSU9OUyA9IF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICBvdmVyc2FtcGxlOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgdmFyIGJ1aWxkSW50ZXJuYWxHcmFwaEZvck1vbm8gPSBmdW5jdGlvbiBidWlsZEludGVybmFsR3JhcGhGb3JNb25vKG5hdGl2ZUNvbnRleHQsIGlucHV0R2Fpbk5vZGUsIHBhbkdhaW5Ob2RlLCBjaGFubmVsTWVyZ2VyTm9kZSkge1xuICAgICAgICB2YXIgbGVmdFdhdmVTaGFwZXJDdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoQ1VSVkVfU0laRSk7XG4gICAgICAgIHZhciByaWdodFdhdmVTaGFwZXJDdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoQ1VSVkVfU0laRSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ1VSVkVfU0laRTsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHggPSBpIC8gKENVUlZFX1NJWkUgLSAxKSAqIEhBTEZfUEk7XG4gICAgICAgICAgbGVmdFdhdmVTaGFwZXJDdXJ2ZVtpXSA9IE1hdGguY29zKHgpO1xuICAgICAgICAgIHJpZ2h0V2F2ZVNoYXBlckN1cnZlW2ldID0gTWF0aC5zaW4oeCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgbGVmdFdhdmVTaGFwZXJOb2RlID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfV0FWRV9TSEFQRVJfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgY3VydmU6IGxlZnRXYXZlU2hhcGVyQ3VydmVcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgcGFuV2F2ZVNoYXBlck5vZGUgPSBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBTSU5HTEVfQ0hBTk5FTF9XQVZFX1NIQVBFUl9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBjdXJ2ZTogRENfQ1VSVkVcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgcmlnaHRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgcmlnaHRXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX1dBVkVfU0hBUEVSX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiByaWdodFdhdmVTaGFwZXJDdXJ2ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29ubmVjdEdyYXBoOiBmdW5jdGlvbiBjb25uZWN0R3JhcGgoKSB7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNvbm5lY3QobGVmdEdhaW5Ob2RlKTtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY29ubmVjdChwYW5XYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IHBhbldhdmVTaGFwZXJOb2RlIDogcGFuV2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY29ubmVjdChyaWdodEdhaW5Ob2RlKTtcbiAgICAgICAgICAgIHBhbldhdmVTaGFwZXJOb2RlLmNvbm5lY3QocGFuR2Fpbk5vZGUpO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuY29ubmVjdChsZWZ0V2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyBsZWZ0V2F2ZVNoYXBlck5vZGUgOiBsZWZ0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIHBhbkdhaW5Ob2RlLmNvbm5lY3QocmlnaHRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IHJpZ2h0V2F2ZVNoYXBlck5vZGUgOiByaWdodFdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBsZWZ0V2F2ZVNoYXBlck5vZGUuY29ubmVjdChsZWZ0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICByaWdodFdhdmVTaGFwZXJOb2RlLmNvbm5lY3QocmlnaHRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIGxlZnRHYWluTm9kZS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAwKTtcbiAgICAgICAgICAgIHJpZ2h0R2Fpbk5vZGUuY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgMSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNjb25uZWN0R3JhcGg6IGZ1bmN0aW9uIGRpc2Nvbm5lY3RHcmFwaCgpIHtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuZGlzY29ubmVjdChsZWZ0R2Fpbk5vZGUpO1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5kaXNjb25uZWN0KHBhbldhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcGFuV2F2ZVNoYXBlck5vZGUgOiBwYW5XYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5kaXNjb25uZWN0KHJpZ2h0R2Fpbk5vZGUpO1xuICAgICAgICAgICAgcGFuV2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChwYW5HYWluTm9kZSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5kaXNjb25uZWN0KGxlZnRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IGxlZnRXYXZlU2hhcGVyTm9kZSA6IGxlZnRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuZGlzY29ubmVjdChyaWdodFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcmlnaHRXYXZlU2hhcGVyTm9kZSA6IHJpZ2h0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIGxlZnRXYXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KGxlZnRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIHJpZ2h0V2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChyaWdodEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgbGVmdEdhaW5Ob2RlLmRpc2Nvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDApO1xuICAgICAgICAgICAgcmlnaHRHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIGJ1aWxkSW50ZXJuYWxHcmFwaEZvclN0ZXJlbyA9IGZ1bmN0aW9uIGJ1aWxkSW50ZXJuYWxHcmFwaEZvclN0ZXJlbyhuYXRpdmVDb250ZXh0LCBpbnB1dEdhaW5Ob2RlLCBwYW5HYWluTm9kZSwgY2hhbm5lbE1lcmdlck5vZGUpIHtcbiAgICAgICAgdmFyIGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyQ3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KENVUlZFX1NJWkUpO1xuICAgICAgICB2YXIgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyQ3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KENVUlZFX1NJWkUpO1xuICAgICAgICB2YXIgcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyQ3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KENVUlZFX1NJWkUpO1xuICAgICAgICB2YXIgcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlckN1cnZlID0gbmV3IEZsb2F0MzJBcnJheShDVVJWRV9TSVpFKTtcbiAgICAgICAgdmFyIGNlbnRlckluZGV4ID0gTWF0aC5mbG9vcihDVVJWRV9TSVpFIC8gMik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ1VSVkVfU0laRTsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiBjZW50ZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIHggPSAoaSAtIGNlbnRlckluZGV4KSAvIChDVVJWRV9TSVpFIC0gMSAtIGNlbnRlckluZGV4KSAqIEhBTEZfUEk7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlckN1cnZlW2ldID0gTWF0aC5jb3MoeCk7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJDdXJ2ZVtpXSA9IE1hdGguc2luKHgpO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyQ3VydmVbaV0gPSAwO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlckN1cnZlW2ldID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF94ID0gaSAvIChDVVJWRV9TSVpFIC0gMSAtIGNlbnRlckluZGV4KSAqIEhBTEZfUEk7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlckN1cnZlW2ldID0gMTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlckN1cnZlW2ldID0gMDtcbiAgICAgICAgICAgIHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlckN1cnZlW2ldID0gTWF0aC5jb3MoX3gpO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlckN1cnZlW2ldID0gTWF0aC5zaW4oX3gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbFNwbGl0dGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gQnVnICMxMTk6IFNhZmFyaSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IHRoZSBXYXZlU2hhcGVyTm9kZS5cbiAgICAgICAgdmFyIGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX1dBVkVfU0hBUEVSX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlckN1cnZlXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gQnVnICMxMTk6IFNhZmFyaSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IHRoZSBXYXZlU2hhcGVyTm9kZS5cbiAgICAgICAgdmFyIGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUgPSBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBTSU5HTEVfQ0hBTk5FTF9XQVZFX1NIQVBFUl9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBjdXJ2ZTogbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyQ3VydmVcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgcGFuV2F2ZVNoYXBlck5vZGUgPSBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBTSU5HTEVfQ0hBTk5FTF9XQVZFX1NIQVBFUl9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBjdXJ2ZTogRENfQ1VSVkVcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX1dBVkVfU0hBUEVSX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJDdXJ2ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUgPSBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBTSU5HTEVfQ0hBTk5FTF9XQVZFX1NIQVBFUl9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBjdXJ2ZTogcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlckN1cnZlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0R3JhcGg6IGZ1bmN0aW9uIGNvbm5lY3RHcmFwaCgpIHtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY29ubmVjdChjaGFubmVsU3BsaXR0ZXJOb2RlKTtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY29ubmVjdChwYW5XYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IHBhbldhdmVTaGFwZXJOb2RlIDogcGFuV2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIGNoYW5uZWxTcGxpdHRlck5vZGUuY29ubmVjdChsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUsIDApO1xuICAgICAgICAgICAgY2hhbm5lbFNwbGl0dGVyTm9kZS5jb25uZWN0KGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUsIDApO1xuICAgICAgICAgICAgY2hhbm5lbFNwbGl0dGVyTm9kZS5jb25uZWN0KHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUsIDEpO1xuICAgICAgICAgICAgY2hhbm5lbFNwbGl0dGVyTm9kZS5jb25uZWN0KHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlLCAxKTtcbiAgICAgICAgICAgIHBhbldhdmVTaGFwZXJOb2RlLmNvbm5lY3QocGFuR2Fpbk5vZGUpO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuY29ubmVjdChsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUgOiBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIHBhbkdhaW5Ob2RlLmNvbm5lY3QobGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUgOiBsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5jb25uZWN0KHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlIDogcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuY29ubmVjdChyaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlIDogcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5jb25uZWN0KGxlZnRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUuY29ubmVjdChsZWZ0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5jb25uZWN0KHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5jb25uZWN0KHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDApO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAwKTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUuY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgMSk7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAxKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3RHcmFwaDogZnVuY3Rpb24gZGlzY29ubmVjdEdyYXBoKCkge1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxTcGxpdHRlck5vZGUpO1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5kaXNjb25uZWN0KHBhbldhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcGFuV2F2ZVNoYXBlck5vZGUgOiBwYW5XYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgY2hhbm5lbFNwbGl0dGVyTm9kZS5kaXNjb25uZWN0KGxlZnRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZSwgMCk7XG4gICAgICAgICAgICBjaGFubmVsU3BsaXR0ZXJOb2RlLmRpc2Nvbm5lY3QobGVmdElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZSwgMCk7XG4gICAgICAgICAgICBjaGFubmVsU3BsaXR0ZXJOb2RlLmRpc2Nvbm5lY3QocmlnaHRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZSwgMSk7XG4gICAgICAgICAgICBjaGFubmVsU3BsaXR0ZXJOb2RlLmRpc2Nvbm5lY3QocmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUsIDEpO1xuICAgICAgICAgICAgcGFuV2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChwYW5HYWluTm9kZSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5kaXNjb25uZWN0KGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZSA6IGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuZGlzY29ubmVjdChsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZSA6IGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIHBhbkdhaW5Ob2RlLmRpc2Nvbm5lY3QocmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUgOiByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5kaXNjb25uZWN0KHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUgOiByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmRpc2Nvbm5lY3QobGVmdElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmRpc2Nvbm5lY3QocmlnaHRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmRpc2Nvbm5lY3QocmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgMCk7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDApO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAxKTtcbiAgICAgICAgICAgIHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgYnVpbGRJbnRlcm5hbEdyYXBoID0gZnVuY3Rpb24gYnVpbGRJbnRlcm5hbEdyYXBoKG5hdGl2ZUNvbnRleHQsIGNoYW5uZWxDb3VudCwgaW5wdXRHYWluTm9kZSwgcGFuR2Fpbk5vZGUsIGNoYW5uZWxNZXJnZXJOb2RlKSB7XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gYnVpbGRJbnRlcm5hbEdyYXBoRm9yTW9ubyhuYXRpdmVDb250ZXh0LCBpbnB1dEdhaW5Ob2RlLCBwYW5HYWluTm9kZSwgY2hhbm5lbE1lcmdlck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gYnVpbGRJbnRlcm5hbEdyYXBoRm9yU3RlcmVvKG5hdGl2ZUNvbnRleHQsIGlucHV0R2Fpbk5vZGUsIHBhbkdhaW5Ob2RlLCBjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIF9yZWYpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxDb3VudCA9IF9yZWYuY2hhbm5lbENvdW50LFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGUgPSBfcmVmLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgcGFuID0gX3JlZi5wYW4sXG4gICAgICAgICAgYXVkaW9Ob2RlT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQkMSk7XG4gICAgICAgIGlmIChjaGFubmVsQ291bnRNb2RlID09PSAnbWF4Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWxNZXJnZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgYXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IGNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IDJcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgaW5wdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIGF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogY2hhbm5lbENvdW50LFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IGNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgZ2FpbjogMVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBwYW5HYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgZ2FpbjogcGFuXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX2J1aWxkSW50ZXJuYWxHcmFwaCA9IGJ1aWxkSW50ZXJuYWxHcmFwaChuYXRpdmVDb250ZXh0LCBjaGFubmVsQ291bnQsIGlucHV0R2Fpbk5vZGUsIHBhbkdhaW5Ob2RlLCBjaGFubmVsTWVyZ2VyTm9kZSksXG4gICAgICAgICAgY29ubmVjdEdyYXBoID0gX2J1aWxkSW50ZXJuYWxHcmFwaC5jb25uZWN0R3JhcGgsXG4gICAgICAgICAgZGlzY29ubmVjdEdyYXBoID0gX2J1aWxkSW50ZXJuYWxHcmFwaC5kaXNjb25uZWN0R3JhcGg7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYW5HYWluTm9kZS5nYWluLCAnZGVmYXVsdFZhbHVlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhbkdhaW5Ob2RlLmdhaW4sICdtYXhWYWx1ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYW5HYWluTm9kZS5nYWluLCAnbWluVmFsdWUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVGYWtlckZhY3RvcnkgPSB7XG4gICAgICAgICAgZ2V0IGJ1ZmZlclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdEdyYXBoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9idWlsZEludGVybmFsR3JhcGgyID0gYnVpbGRJbnRlcm5hbEdyYXBoKG5hdGl2ZUNvbnRleHQsIHZhbHVlLCBpbnB1dEdhaW5Ob2RlLCBwYW5HYWluTm9kZSwgY2hhbm5lbE1lcmdlck5vZGUpO1xuICAgICAgICAgICAgICBjb25uZWN0R3JhcGggPSBfYnVpbGRJbnRlcm5hbEdyYXBoMi5jb25uZWN0R3JhcGg7XG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3RHcmFwaCA9IF9idWlsZEludGVybmFsR3JhcGgyLmRpc2Nvbm5lY3RHcmFwaDtcbiAgICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdEdyYXBoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50TW9kZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnY2xhbXBlZC1tYXgnIHx8IHZhbHVlID09PSAnbWF4Jykge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbEludGVycHJldGF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxJbnRlcnByZXRhdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuY29udGV4dDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBpbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0R2Fpbk5vZGVdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG51bWJlck9mSW5wdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZPdXRwdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUubnVtYmVyT2ZPdXRwdXRzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBhbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5HYWluTm9kZS5nYWluO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuZGlzcGF0Y2hFdmVudChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHdoZW5Db25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuQ29ubmVjdGVkKCkge1xuICAgICAgICAgIGNvbm5lY3RHcmFwaCgpO1xuICAgICAgICAgIGlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdoZW5EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuRGlzY29ubmVjdGVkKCkge1xuICAgICAgICAgIGRpc2Nvbm5lY3RHcmFwaCgpO1xuICAgICAgICAgIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb25pdG9yQ29ubmVjdGlvbnMoaW50ZXJjZXB0Q29ubmVjdGlvbnMobmF0aXZlU3RlcmVvUGFubmVyTm9kZUZha2VyRmFjdG9yeSwgY2hhbm5lbE1lcmdlck5vZGUpLCB3aGVuQ29ubmVjdGVkLCB3aGVuRGlzY29ubmVjdGVkKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZhY3RvcnkoY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGVGYWtlciwgaXNEQ0N1cnZlLCBtb25pdG9yQ29ubmVjdGlvbnMsIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBvdmVyd3JpdGVBY2Nlc3NvcnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlV2F2ZVNoYXBlck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZVdhdmVTaGFwZXIoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogQnVnICMxMTk6IFNhZmFyaSBkb2VzIG5vdCBjb3JyZWN0bHkgbWFwIHRoZSB2YWx1ZXMuXG4gICAgICAgICAqIEB0b2RvIFVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm8gd2F5IHRvIHRlc3QgZm9yIHRoaXMgYmVoYXZpb3IgaW4gYSBzeW5jaHJvbm91cyBmYXNoaW9uIHdoaWNoIGlzIHdoeSB0ZXN0aW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mXG4gICAgICAgICAqIHRoZSB3ZWJraXRBdWRpb0NvbnRleHQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgaGVyZS4gVGVzdGluZyBmb3IgdGhlIGF1dG9tYXRpb25SYXRlIHByb3BlcnR5IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoaXMgd29ya2Fyb3VuZFxuICAgICAgICAgKiBpc24ndCBuZWNlc3NhcnkgYW55bW9yZSBzaW5jZSB2MTQuMC4yIG9mIFNhZmFyaS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvci5uYW1lID09PSAnd2Via2l0QXVkaW9Db250ZXh0JyAmJiBuYXRpdmVDb250ZXh0LmNyZWF0ZUdhaW4oKS5nYWluLmF1dG9tYXRpb25SYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGVGYWtlcihuYXRpdmVDb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGN1cnZlID0gb3B0aW9ucy5jdXJ2ZSA9PT0gbnVsbCB8fCBvcHRpb25zLmN1cnZlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gb3B0aW9ucy5jdXJ2ZSA6IG5ldyBGbG9hdDMyQXJyYXkob3B0aW9ucy5jdXJ2ZSk7XG4gICAgICAgIC8vIEJ1ZyAjMTA0OiBDaHJvbWUgYW5kIEVkZ2Ugd2lsbCB0aHJvdyBhbiBJbnZhbGlkQWNjZXNzRXJyb3Igd2hlbiB0aGUgY3VydmUgaGFzIGxlc3MgdGhhbiB0d28gc2FtcGxlcy5cbiAgICAgICAgaWYgKGN1cnZlICE9PSBudWxsICYmIGN1cnZlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdmFsdWVzIG9mIHR5cGUgRmxvYXQzMkFycmF5IGNhbiBiZSBhc3NpZ25lZCB0byB0aGUgY3VydmUgcHJvcGVydHkuXG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVXYXZlU2hhcGVyTm9kZSwge1xuICAgICAgICAgIGN1cnZlOiBjdXJ2ZVxuICAgICAgICB9LCAnY3VydmUnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBvcHRpb25zLCAnb3ZlcnNhbXBsZScpO1xuICAgICAgICB2YXIgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG51bGw7XG4gICAgICAgIHZhciBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBvdmVyd3JpdGVBY2Nlc3NvcnMobmF0aXZlV2F2ZVNoYXBlck5vZGUsICdjdXJ2ZScsIGZ1bmN0aW9uIChnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKG5hdGl2ZVdhdmVTaGFwZXJOb2RlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0LmNhbGwobmF0aXZlV2F2ZVNoYXBlck5vZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICBpZiAoaXNEQ0N1cnZlKHZhbHVlKSAmJiBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZUNvbm5lY3RlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShuYXRpdmVDb250ZXh0LCBuYXRpdmVXYXZlU2hhcGVyTm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzRENDdXJ2ZSh2YWx1ZSkgJiYgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgd2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChpc0RDQ3VydmUobmF0aXZlV2F2ZVNoYXBlck5vZGUuY3VydmUpKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZVdhdmVTaGFwZXJOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3aGVuRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKCk7XG4gICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb25pdG9yQ29ubmVjdGlvbnMobmF0aXZlV2F2ZVNoYXBlck5vZGUsIHdoZW5Db25uZWN0ZWQsIHdoZW5EaXNjb25uZWN0ZWQpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9leGNsdWRlZCA9IFtcImN1cnZlXCIsIFwib3ZlcnNhbXBsZVwiXTtcbiAgICBmdW5jdGlvbiBvd25LZXlzJGEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGVGYWtlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyRmFjdG9yeShjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgaXNEQ0N1cnZlLCBtb25pdG9yQ29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgX3JlZikge1xuICAgICAgICB2YXIgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgICAgIG92ZXJzYW1wbGUgPSBfcmVmLm92ZXJzYW1wbGUsXG4gICAgICAgICAgYXVkaW9Ob2RlT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICAgICAgICB2YXIgbmVnYXRpdmVXYXZlU2hhcGVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlV2F2ZVNoYXBlcigpO1xuICAgICAgICB2YXIgcG9zaXRpdmVXYXZlU2hhcGVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlV2F2ZVNoYXBlcigpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUsIGF1ZGlvTm9kZU9wdGlvbnMpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKHBvc2l0aXZlV2F2ZVNoYXBlck5vZGUsIGF1ZGlvTm9kZU9wdGlvbnMpO1xuICAgICAgICB2YXIgaW5wdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIGF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgaW52ZXJ0R2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBhdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICBnYWluOiAtMVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBvdXRwdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIGF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgcmV2ZXJ0R2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBhdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICBnYWluOiAtMVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdmFyIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB1bm1vZGlmaWVkQ3VydmUgPSBudWxsO1xuICAgICAgICB2YXIgbmF0aXZlV2F2ZVNoYXBlck5vZGVGYWtlciA9IHtcbiAgICAgICAgICBnZXQgYnVmZmVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUuY2hhbm5lbENvdW50O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudCh2YWx1ZSkge1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGludmVydEdhaW5Ob2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIG91dHB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgcG9zaXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldmVydEdhaW5Ob2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsQ291bnRNb2RlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudE1vZGUodmFsdWUpIHtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY2hhbm5lbENvdW50TW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgaW52ZXJ0R2Fpbk5vZGUuY2hhbm5lbENvdW50TW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICBvdXRwdXRHYWluTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICBwb3NpdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldmVydEdhaW5Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb247XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbEludGVycHJldGF0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgaW52ZXJ0R2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgb3V0cHV0R2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICBwb3NpdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgcmV2ZXJ0R2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLmNvbnRleHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY3VydmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5tb2RpZmllZEN1cnZlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGN1cnZlKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzEwMjogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIEludmFsaWRTdGF0ZUVycm9yIHdoZW4gdGhlIGN1cnZlIGhhcyBsZXNzIHRoYW4gdHdvIHNhbXBsZXMuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUuY3VydmUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgcG9zaXRpdmVXYXZlU2hhcGVyTm9kZS5jdXJ2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnZlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgbmVnYXRpdmVDdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoY3VydmVMZW5ndGggKyAyIC0gY3VydmVMZW5ndGggJSAyKTtcbiAgICAgICAgICAgICAgdmFyIHBvc2l0aXZlQ3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnZlTGVuZ3RoICsgMiAtIGN1cnZlTGVuZ3RoICUgMik7XG4gICAgICAgICAgICAgIG5lZ2F0aXZlQ3VydmVbMF0gPSB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgcG9zaXRpdmVDdXJ2ZVswXSA9IC12YWx1ZVtjdXJ2ZUxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5jZWlsKChjdXJ2ZUxlbmd0aCArIDEpIC8gMik7XG4gICAgICAgICAgICAgIHZhciBjZW50ZXJJbmRleCA9IChjdXJ2ZUxlbmd0aCArIDEpIC8gMiAtIDE7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlb3JldGljSW5kZXggPSBpIC8gbGVuZ3RoICogY2VudGVySW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGxvd2VySW5kZXggPSBNYXRoLmZsb29yKHRoZW9yZXRpY0luZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgdXBwZXJJbmRleCA9IE1hdGguY2VpbCh0aGVvcmV0aWNJbmRleCk7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVDdXJ2ZVtpXSA9IGxvd2VySW5kZXggPT09IHVwcGVySW5kZXggPyB2YWx1ZVtsb3dlckluZGV4XSA6ICgxIC0gKHRoZW9yZXRpY0luZGV4IC0gbG93ZXJJbmRleCkpICogdmFsdWVbbG93ZXJJbmRleF0gKyAoMSAtICh1cHBlckluZGV4IC0gdGhlb3JldGljSW5kZXgpKSAqIHZhbHVlW3VwcGVySW5kZXhdO1xuICAgICAgICAgICAgICAgIHBvc2l0aXZlQ3VydmVbaV0gPSBsb3dlckluZGV4ID09PSB1cHBlckluZGV4ID8gLXZhbHVlW2N1cnZlTGVuZ3RoIC0gMSAtIGxvd2VySW5kZXhdIDogLSgoMSAtICh0aGVvcmV0aWNJbmRleCAtIGxvd2VySW5kZXgpKSAqIHZhbHVlW2N1cnZlTGVuZ3RoIC0gMSAtIGxvd2VySW5kZXhdKSAtICgxIC0gKHVwcGVySW5kZXggLSB0aGVvcmV0aWNJbmRleCkpICogdmFsdWVbY3VydmVMZW5ndGggLSAxIC0gdXBwZXJJbmRleF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmVnYXRpdmVDdXJ2ZVtsZW5ndGhdID0gY3VydmVMZW5ndGggJSAyID09PSAxID8gdmFsdWVbbGVuZ3RoIC0gMV0gOiAodmFsdWVbbGVuZ3RoIC0gMl0gKyB2YWx1ZVtsZW5ndGggLSAxXSkgLyAyO1xuICAgICAgICAgICAgICBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLmN1cnZlID0gbmVnYXRpdmVDdXJ2ZTtcbiAgICAgICAgICAgICAgcG9zaXRpdmVXYXZlU2hhcGVyTm9kZS5jdXJ2ZSA9IHBvc2l0aXZlQ3VydmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bm1vZGlmaWVkQ3VydmUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICBpZiAoaXNEQ0N1cnZlKHVubW9kaWZpZWRDdXJ2ZSkgJiYgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwgaW5wdXRHYWluTm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGlucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRHYWluTm9kZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZJbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5udW1iZXJPZklucHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZk91dHB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5udW1iZXJPZk91dHB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgb3ZlcnNhbXBsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLm92ZXJzYW1wbGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgb3ZlcnNhbXBsZSh2YWx1ZSkge1xuICAgICAgICAgICAgbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5vdmVyc2FtcGxlID0gdmFsdWU7XG4gICAgICAgICAgICBwb3NpdGl2ZVdhdmVTaGFwZXJOb2RlLm92ZXJzYW1wbGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5hZGRFdmVudExpc3RlbmVyKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLmRpc3BhdGNoRXZlbnQoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN1cnZlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gT25seSB2YWx1ZXMgb2YgdHlwZSBGbG9hdDMyQXJyYXkgY2FuIGJlIGFzc2lnbmVkIHRvIHRoZSBjdXJ2ZSBwcm9wZXJ0eS5cbiAgICAgICAgICBuYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyLmN1cnZlID0gY3VydmUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBjdXJ2ZSA6IG5ldyBGbG9hdDMyQXJyYXkoY3VydmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyc2FtcGxlICE9PSBuYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyLm92ZXJzYW1wbGUpIHtcbiAgICAgICAgICBuYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aGVuQ29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkNvbm5lY3RlZCgpIHtcbiAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNvbm5lY3QobmVnYXRpdmVXYXZlU2hhcGVyTm9kZSkuY29ubmVjdChvdXRwdXRHYWluTm9kZSk7XG4gICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KGludmVydEdhaW5Ob2RlKS5jb25uZWN0KHBvc2l0aXZlV2F2ZVNoYXBlck5vZGUpLmNvbm5lY3QocmV2ZXJ0R2Fpbk5vZGUpLmNvbm5lY3Qob3V0cHV0R2Fpbk5vZGUpO1xuICAgICAgICAgIGlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNEQ0N1cnZlKHVubW9kaWZpZWRDdXJ2ZSkpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwgaW5wdXRHYWluTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgd2hlbkRpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5EaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgICAgaW5wdXRHYWluTm9kZS5kaXNjb25uZWN0KG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUpO1xuICAgICAgICAgIG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChvdXRwdXRHYWluTm9kZSk7XG4gICAgICAgICAgaW5wdXRHYWluTm9kZS5kaXNjb25uZWN0KGludmVydEdhaW5Ob2RlKTtcbiAgICAgICAgICBpbnZlcnRHYWluTm9kZS5kaXNjb25uZWN0KHBvc2l0aXZlV2F2ZVNoYXBlck5vZGUpO1xuICAgICAgICAgIHBvc2l0aXZlV2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChyZXZlcnRHYWluTm9kZSk7XG4gICAgICAgICAgcmV2ZXJ0R2Fpbk5vZGUuZGlzY29ubmVjdChvdXRwdXRHYWluTm9kZSk7XG4gICAgICAgICAgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSgpO1xuICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW9uaXRvckNvbm5lY3Rpb25zKGludGVyY2VwdENvbm5lY3Rpb25zKG5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFrZXIsIG91dHB1dEdhaW5Ob2RlKSwgd2hlbkNvbm5lY3RlZCwgd2hlbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnTm90U3VwcG9ydGVkRXJyb3InKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQ5KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ5KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ5KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciQ0KHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkNSA9IHtcbiAgICAgIG51bWJlck9mQ2hhbm5lbHM6IDFcbiAgICB9O1xuICAgIHZhciBjcmVhdGVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoYmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBfc3RhcnRSZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9iYXNlQXVkaW9Db250ZXh0Q29ucykge1xuICAgICAgICBmdW5jdGlvbiBPZmZsaW5lQXVkaW9Db250ZXh0KGEsIGIsIGMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIHZhciBvcHRpb25zO1xuICAgICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgbGVuZ3RoOiBiLFxuICAgICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiBhLFxuICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBnaXZlbiBwYXJhbWV0ZXJzIGFyZSBub3QgdmFsaWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfREVGQVVMVF9PUFRJT05TJG9wdGkgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KHt9LCBERUZBVUxUX09QVElPTlMkNSksIG9wdGlvbnMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gX0RFRkFVTFRfT1BUSU9OUyRvcHRpLmxlbmd0aCxcbiAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSBfREVGQVVMVF9PUFRJT05TJG9wdGkubnVtYmVyT2ZDaGFubmVscyxcbiAgICAgICAgICAgIHNhbXBsZVJhdGUgPSBfREVGQVVMVF9PUFRJT05TJG9wdGkuc2FtcGxlUmF0ZTtcbiAgICAgICAgICB2YXIgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobnVtYmVyT2ZDaGFubmVscywgbGVuZ3RoLCBzYW1wbGVSYXRlKTtcbiAgICAgICAgICAvLyAjMjEgU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJvbWlzZXMgYW5kIHRoZXJlZm9yZSB3b3VsZCBmaXJlIHRoZSBzdGF0ZWNoYW5nZSBldmVudCBiZWZvcmUgdGhlIHByb21pc2UgY2FuIGJlIHJlc29sdmVkLlxuICAgICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RQcm9taXNlU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RQcm9taXNlU3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICB2YXIgX2RlbGF5U3RhdGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIGRlbGF5U3RhdGVDaGFuZ2VFdmVudChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdGUgPT09ICdydW5uaW5nJykge1xuICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBfZGVsYXlTdGF0ZUNoYW5nZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl93YWl0Rm9yVGhlUHJvbWlzZVRvU2V0dGxlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBfZGVsYXlTdGF0ZUNoYW5nZUV2ZW50O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJDQodGhpcywgT2ZmbGluZUF1ZGlvQ29udGV4dCwgW25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG51bWJlck9mQ2hhbm5lbHNdKTtcbiAgICAgICAgICBfdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgICBfdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoT2ZmbGluZUF1ZGlvQ29udGV4dCwgX2Jhc2VBdWRpb0NvbnRleHRDb25zKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhPZmZsaW5lQXVkaW9Db250ZXh0LCBbe1xuICAgICAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTc6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgZXhwb3NlIHRoZSBsZW5ndGguXG4gICAgICAgICAgICBpZiAodGhpcy5fbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGF0ZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSBudWxsID8gdGhpcy5fbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zdGF0ZSA6IHRoaXMuX3N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGFydFJlbmRlcmluZ1wiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydFJlbmRlcmluZygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEJ1ZyAjOSAmICM1OTogSXQgaXMgdGhlb3JldGljYWxseSBwb3NzaWJsZSB0aGF0IHN0YXJ0UmVuZGVyaW5nKCkgd2lsbCBmaXJzdCByZW5kZXIgYSBwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dC4gVGhlcmVmb3JlXG4gICAgICAgICAgICAgKiB0aGUgc3RhdGUgb2YgdGhlIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgbWlnaHQgbm8gdHJhbnNpdGlvbiB0byBydW5uaW5nIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdydW5uaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9ICdydW5uaW5nJztcbiAgICAgICAgICAgIHJldHVybiBfc3RhcnRSZW5kZXJpbmcodGhpcy5kZXN0aW5hdGlvbiwgdGhpcy5fbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dClbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGRlYWN0aXZhdGVBdWRpb0dyYXBoKF90aGlzMik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiX3dhaXRGb3JUaGVQcm9taXNlVG9TZXR0bGVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhaXRGb3JUaGVQcm9taXNlVG9TZXR0bGUoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl93YWl0Rm9yVGhlUHJvbWlzZVRvU2V0dGxlKGV2ZW50KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkOChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkOChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkOChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkMyh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDMoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMyA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJDQgPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgIC8vIFRoaXMgYXR0cmlidXRlIGhhcyBubyBlZmZlY3QgZm9yIG5vZGVzIHdpdGggbm8gaW5wdXRzLlxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgLy8gVGhpcyBhdHRyaWJ1dGUgaGFzIG5vIGVmZmVjdCBmb3Igbm9kZXMgd2l0aCBubyBpbnB1dHMuXG4gICAgICBkZXR1bmU6IDAsXG4gICAgICBmcmVxdWVuY3k6IDQ0MCxcbiAgICAgIHBlcmlvZGljV2F2ZTogdW5kZWZpbmVkLFxuICAgICAgdHlwZTogJ3NpbmUnXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlT3NjaWxsYXRvck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU9zY2lsbGF0b3JOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBjcmVhdGVPc2NpbGxhdG9yTm9kZVJlbmRlcmVyLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHdyYXBFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gT3NjaWxsYXRvck5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3NjaWxsYXRvck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIERFRkFVTFRfT1BUSU9OUyQ0KSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZU9zY2lsbGF0b3JOb2RlID0gY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgb3NjaWxsYXRvck5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZU9zY2lsbGF0b3JOb2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgdmFyIG55cXVpc3QgPSBjb250ZXh0LnNhbXBsZVJhdGUgLyAyO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciQzKHRoaXMsIE9zY2lsbGF0b3JOb2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBvc2NpbGxhdG9yTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgLy8gQnVnICM4MTogRmlyZWZveCAmIFNhZmFyaSBkbyBub3QgZXhwb3J0IHRoZSBjb3JyZWN0IHZhbHVlcyBmb3IgbWF4VmFsdWUgYW5kIG1pblZhbHVlLlxuICAgICAgICAgIF90aGlzLl9kZXR1bmUgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmRldHVuZSwgMTUzNjAwLCAtMTUzNjAwKTtcbiAgICAgICAgICAvLyBCdWcgIzc2OiBTYWZhcmkgZG9lcyBub3QgZXhwb3J0IHRoZSBjb3JyZWN0IHZhbHVlcyBmb3IgbWF4VmFsdWUgYW5kIG1pblZhbHVlLlxuICAgICAgICAgIF90aGlzLl9mcmVxdWVuY3kgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmZyZXF1ZW5jeSwgbnlxdWlzdCwgLW55cXVpc3QpO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZSA9IG5hdGl2ZU9zY2lsbGF0b3JOb2RlO1xuICAgICAgICAgIF90aGlzLl9vbmVuZGVkID0gbnVsbDtcbiAgICAgICAgICBfdGhpcy5fb3NjaWxsYXRvck5vZGVSZW5kZXJlciA9IG9zY2lsbGF0b3JOb2RlUmVuZGVyZXI7XG4gICAgICAgICAgaWYgKF90aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyICE9PSBudWxsICYmIG1lcmdlZE9wdGlvbnMucGVyaW9kaWNXYXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyLnBlcmlvZGljV2F2ZSA9IG1lcmdlZE9wdGlvbnMucGVyaW9kaWNXYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKE9zY2lsbGF0b3JOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE9zY2lsbGF0b3JOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJkZXR1bmVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXR1bmU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImZyZXF1ZW5jeVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyZXF1ZW5jeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib25lbmRlZFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZW5kZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWRMaXN0ZW5lciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBFdmVudExpc3RlbmVyKHRoaXMsIHZhbHVlKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5vbmVuZGVkID0gd3JhcHBlZExpc3RlbmVyO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU9uRW5kZWQgPSB0aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5vbmVuZGVkO1xuICAgICAgICAgICAgdGhpcy5fb25lbmRlZCA9IG5hdGl2ZU9uRW5kZWQgIT09IG51bGwgJiYgbmF0aXZlT25FbmRlZCA9PT0gd3JhcHBlZExpc3RlbmVyID8gdmFsdWUgOiBuYXRpdmVPbkVuZGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ0eXBlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUudHlwZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS50eXBlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvck5vZGVSZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyLnBlcmlvZGljV2F2ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInNldFBlcmlvZGljV2F2ZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQZXJpb2RpY1dhdmUocGVyaW9kaWNXYXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5zZXRQZXJpb2RpY1dhdmUocGVyaW9kaWNXYXZlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIucGVyaW9kaWNXYXZlID0gcGVyaW9kaWNXYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5zdGFydCh3aGVuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIuc3RhcnQgPSB3aGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvQWN0aXZlKHRoaXMpO1xuICAgICAgICAgICAgICB2YXIgX3Jlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSA9IGZ1bmN0aW9uIHJlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX3Jlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKF90aGlzMikpIHtcbiAgICAgICAgICAgICAgICAgIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUoX3RoaXMyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX3Jlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0b3BcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgIHZhciB3aGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUuc3RvcCh3aGVuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIuc3RvcCA9IHdoZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU9zY2lsbGF0b3JOb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlT3NjaWxsYXRvck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVPc2NpbGxhdG9yTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgcGVyaW9kaWNXYXZlID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0b3AgPSBudWxsO1xuICAgICAgICB2YXIgY3JlYXRlT3NjaWxsYXRvck5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlT3NjaWxsYXRvck5vZGUsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVPc2NpbGxhdG9yTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7IC8vIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVPc2NpbGxhdG9yTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZU9zY2lsbGF0b3JOb2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlT3NjaWxsYXRvck5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVPc2NpbGxhdG9yTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVPc2NpbGxhdG9yTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlT3NjaWxsYXRvck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGRldHVuZTogbmF0aXZlT3NjaWxsYXRvck5vZGUuZGV0dW5lLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbmF0aXZlT3NjaWxsYXRvck5vZGUuZnJlcXVlbmN5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHBlcmlvZGljV2F2ZTogcGVyaW9kaWNXYXZlID09PSBudWxsID8gdW5kZWZpbmVkIDogcGVyaW9kaWNXYXZlLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG5hdGl2ZU9zY2lsbGF0b3JOb2RlLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlT3NjaWxsYXRvck5vZGUgPSBjcmVhdGVOYXRpdmVPc2NpbGxhdG9yTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmF0aXZlT3NjaWxsYXRvck5vZGUuc3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmF0aXZlT3NjaWxsYXRvck5vZGUuc3RvcChzdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVPc2NpbGxhdG9yTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVPc2NpbGxhdG9yTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZGV0dW5lLCBuYXRpdmVPc2NpbGxhdG9yTm9kZS5kZXR1bmUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZnJlcXVlbmN5LCBuYXRpdmVPc2NpbGxhdG9yTm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZGV0dW5lLCBuYXRpdmVPc2NpbGxhdG9yTm9kZS5kZXR1bmUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZnJlcXVlbmN5LCBuYXRpdmVPc2NpbGxhdG9yTm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVPc2NpbGxhdG9yTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9zY2lsbGF0b3JOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNldCBwZXJpb2RpY1dhdmUodmFsdWUpIHtcbiAgICAgICAgICAgIHBlcmlvZGljV2F2ZSA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IHN0YXJ0KHZhbHVlKSB7XG4gICAgICAgICAgICBzdGFydCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IHN0b3AodmFsdWUpIHtcbiAgICAgICAgICAgIHN0b3AgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVPc2NpbGxhdG9yTm9kZSA9IHJlbmRlcmVkTmF0aXZlT3NjaWxsYXRvck5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZU9zY2lsbGF0b3JOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZU9zY2lsbGF0b3JOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPc2NpbGxhdG9yTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQ3KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDcoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ3KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ3KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciQyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMigpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkMyA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdjbGFtcGVkLW1heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBjb25lSW5uZXJBbmdsZTogMzYwLFxuICAgICAgY29uZU91dGVyQW5nbGU6IDM2MCxcbiAgICAgIGNvbmVPdXRlckdhaW46IDAsXG4gICAgICBkaXN0YW5jZU1vZGVsOiAnaW52ZXJzZScsXG4gICAgICBtYXhEaXN0YW5jZTogMTAwMDAsXG4gICAgICBvcmllbnRhdGlvblg6IDEsXG4gICAgICBvcmllbnRhdGlvblk6IDAsXG4gICAgICBvcmllbnRhdGlvblo6IDAsXG4gICAgICBwYW5uaW5nTW9kZWw6ICdlcXVhbHBvd2VyJyxcbiAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgIHBvc2l0aW9uWTogMCxcbiAgICAgIHBvc2l0aW9uWjogMCxcbiAgICAgIHJlZkRpc3RhbmNlOiAxLFxuICAgICAgcm9sbG9mZkZhY3RvcjogMVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZVBhbm5lck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZVBhbm5lck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlUGFubmVyTm9kZSwgY3JlYXRlUGFubmVyTm9kZVJlbmRlcmVyLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHNldEF1ZGlvTm9kZVRhaWxUaW1lKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFubmVyTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYW5uZXJOb2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBERUZBVUxUX09QVElPTlMkMyksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVQYW5uZXJOb2RlID0gY3JlYXRlTmF0aXZlUGFubmVyTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBwYW5uZXJOb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVQYW5uZXJOb2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJDIodGhpcywgUGFubmVyTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVQYW5uZXJOb2RlLCBwYW5uZXJOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlUGFubmVyTm9kZSA9IG5hdGl2ZVBhbm5lck5vZGU7XG4gICAgICAgICAgLy8gQnVnICM3NDogU2FmYXJpIGRvZXMgbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZCBtaW5WYWx1ZS5cbiAgICAgICAgICBfdGhpcy5fb3JpZW50YXRpb25YID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVQYW5uZXJOb2RlLm9yaWVudGF0aW9uWCwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICBfdGhpcy5fb3JpZW50YXRpb25ZID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVQYW5uZXJOb2RlLm9yaWVudGF0aW9uWSwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICBfdGhpcy5fb3JpZW50YXRpb25aID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVQYW5uZXJOb2RlLm9yaWVudGF0aW9uWiwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICBfdGhpcy5fcG9zaXRpb25YID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVQYW5uZXJOb2RlLnBvc2l0aW9uWCwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICBfdGhpcy5fcG9zaXRpb25ZID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVQYW5uZXJOb2RlLnBvc2l0aW9uWSwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICBfdGhpcy5fcG9zaXRpb25aID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVQYW5uZXJOb2RlLnBvc2l0aW9uWiwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICAvLyBAdG9kbyBEZXRlcm1pbmUgYSBtZWFuaW5nZnVsIHRhaWwtdGltZSBpbnN0ZWFkIG9mIGp1c3QgdXNpbmcgb25lIHNlY29uZC5cbiAgICAgICAgICBzZXRBdWRpb05vZGVUYWlsVGltZShfdGhpcywgMSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhQYW5uZXJOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBhbm5lck5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImNvbmVJbm5lckFuZ2xlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5jb25lSW5uZXJBbmdsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmNvbmVJbm5lckFuZ2xlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNvbmVPdXRlckFuZ2xlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5jb25lT3V0ZXJBbmdsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmNvbmVPdXRlckFuZ2xlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNvbmVPdXRlckdhaW5cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmNvbmVPdXRlckdhaW47XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5jb25lT3V0ZXJHYWluID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRpc3RhbmNlTW9kZWxcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmRpc3RhbmNlTW9kZWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm1heERpc3RhbmNlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5tYXhEaXN0YW5jZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLm1heERpc3RhbmNlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm9yaWVudGF0aW9uWFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib3JpZW50YXRpb25ZXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25ZO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvcmllbnRhdGlvblpcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblo7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInBhbm5pbmdNb2RlbFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUucGFubmluZ01vZGVsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUucGFubmluZ01vZGVsID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInBvc2l0aW9uWFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicG9zaXRpb25ZXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25ZO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJwb3NpdGlvblpcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblo7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInJlZkRpc3RhbmNlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5yZWZEaXN0YW5jZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLnJlZkRpc3RhbmNlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInJvbGxvZmZGYWN0b3JcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLnJvbGxvZmZGYWN0b3I7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQ2KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDYoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ2KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ2KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgdmFyIGNyZWF0ZVBhbm5lck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVQYW5uZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTmF0aXZlUGFubmVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlLCByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnVmZmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHZhciBjcmVhdGVBdWRpb05vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUdhaW5Ob2RlLCBuYXRpdmVQYW5uZXJOb2RlLCBjb21tb25BdWRpb05vZGVPcHRpb25zLCBjb21tb25OYXRpdmVQYW5uZXJOb2RlT3B0aW9ucywgbmF0aXZlUGFubmVyTm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnMsIHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgcmVuZGVyZWRCdWZmZXIsIGlucHV0R2Fpbk5vZGUsIGNoYW5uZWxEYXRhcywgaSwgbGFzdE9yaWVudGF0aW9uLCBsYXN0UG9zaXRpb24sIGdhdGVHYWluTm9kZSwgcGFydGlhbFBhbm5lck5vZGUsIF9pLCBvcmllbnRhdGlvbiwgcG9zaXRvbiwgY3VycmVudFRpbWU7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUdhaW5Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpO1xuICAgICAgICAgICAgICAgICAgY29tbW9uQXVkaW9Ob2RlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVQYW5uZXJOb2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlUGFubmVyTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZVBhbm5lck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgY29tbW9uTmF0aXZlUGFubmVyTm9kZU9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBjb21tb25BdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZUlubmVyQW5nbGU6IG5hdGl2ZVBhbm5lck5vZGUuY29uZUlubmVyQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmVPdXRlckFuZ2xlOiBuYXRpdmVQYW5uZXJOb2RlLmNvbmVPdXRlckFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBjb25lT3V0ZXJHYWluOiBuYXRpdmVQYW5uZXJOb2RlLmNvbmVPdXRlckdhaW4sXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlTW9kZWw6IG5hdGl2ZVBhbm5lck5vZGUuZGlzdGFuY2VNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdGFuY2U6IG5hdGl2ZVBhbm5lck5vZGUubWF4RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHBhbm5pbmdNb2RlbDogbmF0aXZlUGFubmVyTm9kZS5wYW5uaW5nTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIHJlZkRpc3RhbmNlOiBuYXRpdmVQYW5uZXJOb2RlLnJlZkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICByb2xsb2ZmRmFjdG9yOiBuYXRpdmVQYW5uZXJOb2RlLnJvbGxvZmZGYWN0b3JcbiAgICAgICAgICAgICAgICAgIH0pOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlUGFubmVyTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVQYW5uZXJOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTsgLy8gQnVnICMxMjQ6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmeWluZyB0aGUgb3JpZW50YXRpb24gYW5kIHRoZSBwb3NpdGlvbiB3aXRoIEF1ZGlvUGFyYW1zLlxuICAgICAgICAgICAgICAgICAgaWYgKCdidWZmZXJTaXplJyBpbiBuYXRpdmVQYW5uZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgY29tbW9uQXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2FpbjogMVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFuYXRpdmVQYW5uZXJOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgY29tbW9uTmF0aXZlUGFubmVyTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uWDogbmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvblgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25ZOiBuYXRpdmVQYW5uZXJOb2RlLm9yaWVudGF0aW9uWS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvblo6IG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25aLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWDogbmF0aXZlUGFubmVyTm9kZS5wb3NpdGlvblgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25ZOiBuYXRpdmVQYW5uZXJOb2RlLnBvc2l0aW9uWS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblo6IG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25aLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlID0gY3JlYXRlTmF0aXZlUGFubmVyTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlR2Fpbk5vZGUgPT09IG51bGwgPyBuYXRpdmVQYW5uZXJOb2RlIDogbmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKCEobmF0aXZlR2Fpbk5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCEocmVuZGVyZWRCdWZmZXJQcm9taXNlID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIG5hdGl2ZSBPZmZsaW5lQXVkaW9Db250ZXh0IGNvbnN0cnVjdG9yLicpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoNixcbiAgICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTc6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgZXhwb3NlIHRoZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgICBwcm94eS5jb250ZXh0Lmxlbmd0aCwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mSW5wdXRzOiA2XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLmNvbm5lY3QocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgcmVuZGVyZWRCdWZmZXJQcm9taXNlID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZXMsIGk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3Byb3h5Lm9yaWVudGF0aW9uWCwgcHJveHkub3JpZW50YXRpb25ZLCBwcm94eS5vcmllbnRhdGlvblosIHByb3h5LnBvc2l0aW9uWCwgcHJveHkucG9zaXRpb25ZLCBwcm94eS5wb3NpdGlvblpdLm1hcCgvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhdWRpb1BhcmFtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogaW5kZXggPT09IDAgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LCBhdWRpb1BhcmFtLCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MywgX3g0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlcyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2Rlc1tpXS5jb25uZWN0KG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCAwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVzW2ldLnN0YXJ0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgICAgICAgICAgICB9KSkoKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJlZEJ1ZmZlclByb21pc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQnVmZmVyID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICBpbnB1dEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgY29tbW9uQXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIGlucHV0R2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICBjaGFubmVsRGF0YXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW5kZXJlZEJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbERhdGFzLnB1c2gocmVuZGVyZWRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGFzdE9yaWVudGF0aW9uID0gW2NoYW5uZWxEYXRhc1swXVswXSwgY2hhbm5lbERhdGFzWzFdWzBdLCBjaGFubmVsRGF0YXNbMl1bMF1dO1xuICAgICAgICAgICAgICAgICAgbGFzdFBvc2l0aW9uID0gW2NoYW5uZWxEYXRhc1szXVswXSwgY2hhbm5lbERhdGFzWzRdWzBdLCBjaGFubmVsRGF0YXNbNV1bMF1dO1xuICAgICAgICAgICAgICAgICAgZ2F0ZUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgY29tbW9uQXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIHBhcnRpYWxQYW5uZXJOb2RlID0gY3JlYXRlTmF0aXZlUGFubmVyTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBjb21tb25OYXRpdmVQYW5uZXJOb2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uWDogbGFzdE9yaWVudGF0aW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvblk6IGxhc3RPcmllbnRhdGlvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25aOiBsYXN0T3JpZW50YXRpb25bMl0sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWDogbGFzdFBvc2l0aW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblk6IGxhc3RQb3NpdGlvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25aOiBsYXN0UG9zaXRpb25bMl1cbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY29ubmVjdChnYXRlR2Fpbk5vZGUpLmNvbm5lY3QocGFydGlhbFBhbm5lck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgICAgICAgIHBhcnRpYWxQYW5uZXJOb2RlLmNvbm5lY3QobmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDEyODsgX2kgPCByZW5kZXJlZEJ1ZmZlci5sZW5ndGg7IF9pICs9IDEyOCkge1xuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IFtjaGFubmVsRGF0YXNbMF1bX2ldLCBjaGFubmVsRGF0YXNbMV1bX2ldLCBjaGFubmVsRGF0YXNbMl1bX2ldXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRvbiA9IFtjaGFubmVsRGF0YXNbM11bX2ldLCBjaGFubmVsRGF0YXNbNF1bX2ldLCBjaGFubmVsRGF0YXNbNV1bX2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uLnNvbWUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbGFzdE9yaWVudGF0aW9uW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgcG9zaXRvbi5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IGxhc3RQb3NpdGlvbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGFzdE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgbGFzdFBvc2l0aW9uID0gcG9zaXRvbjtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IF9pIC8gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgICAgICAgIGdhdGVHYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBnYXRlR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBjb21tb25BdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFBhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIF9vYmplY3RTcHJlYWQkNihfb2JqZWN0U3ByZWFkJDYoe30sIGNvbW1vbk5hdGl2ZVBhbm5lck5vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uWDogbGFzdE9yaWVudGF0aW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25ZOiBsYXN0T3JpZW50YXRpb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvblo6IGxhc3RPcmllbnRhdGlvblsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWDogbGFzdFBvc2l0aW9uWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25ZOiBsYXN0UG9zaXRpb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblo6IGxhc3RQb3NpdGlvblsyXVxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICBnYXRlR2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KGdhdGVHYWluTm9kZSkuY29ubmVjdChwYXJ0aWFsUGFubmVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxQYW5uZXJOb2RlLmNvbm5lY3QobmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBuYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVQYW5uZXJOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5vcmllbnRhdGlvblgsIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25YKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzNjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5Lm9yaWVudGF0aW9uWSwgbmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvblkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM4O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkub3JpZW50YXRpb25aLCBuYXRpdmVQYW5uZXJOb2RlLm9yaWVudGF0aW9uWik7XG4gICAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDA7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wb3NpdGlvblgsIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25YKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0MjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnBvc2l0aW9uWSwgbmF0aXZlUGFubmVyTm9kZS5wb3NpdGlvblkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucG9zaXRpb25aLCBuYXRpdmVQYW5uZXJOb2RlLnBvc2l0aW9uWik7XG4gICAgICAgICAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0ODtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5vcmllbnRhdGlvblgsIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25YKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ4OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1MDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5vcmllbnRhdGlvblksIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25ZKTtcbiAgICAgICAgICAgICAgICBjYXNlIDUwOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1MjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5vcmllbnRhdGlvblosIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25aKTtcbiAgICAgICAgICAgICAgICBjYXNlIDUyOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1NDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wb3NpdGlvblgsIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25YKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU0OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1NjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wb3NpdGlvblksIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25ZKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU2OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1ODtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wb3NpdGlvblosIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25aKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAgICAgaWYgKCFpc05hdGl2ZUF1ZGlvTm9kZUZha2VyKG5hdGl2ZVBhbm5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2MTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlUGFubmVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2MzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZVBhbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBuYXRpdmVQYW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMyk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBdWRpb05vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUdhaW5Ob2RlT3JOYXRpdmVQYW5uZXJOb2RlID0gcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUdhaW5Ob2RlT3JOYXRpdmVQYW5uZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZUdhaW5Ob2RlT3JOYXRpdmVQYW5uZXJOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkNShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkMiA9IHtcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZVBlcmlvZGljV2F2ZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlUGVyaW9kaWNXYXZlQ29uc3RydWN0b3IoY3JlYXRlTmF0aXZlUGVyaW9kaWNXYXZlLCBnZXROYXRpdmVDb250ZXh0LCBwZXJpb2RpY1dhdmVTdG9yZSwgc2FuaXRpemVQZXJpb2RpY1dhdmVPcHRpb25zKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGVyaW9kaWNXYXZlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyaW9kaWNXYXZlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBzYW5pdGl6ZVBlcmlvZGljV2F2ZU9wdGlvbnMoX29iamVjdFNwcmVhZCQ1KF9vYmplY3RTcHJlYWQkNSh7fSwgREVGQVVMVF9PUFRJT05TJDIpLCBvcHRpb25zKSk7XG4gICAgICAgICAgdmFyIHBlcmlvZGljV2F2ZSA9IGNyZWF0ZU5hdGl2ZVBlcmlvZGljV2F2ZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICBwZXJpb2RpY1dhdmVTdG9yZS5hZGQocGVyaW9kaWNXYXZlKTtcbiAgICAgICAgICAvLyBUaGlzIGRvZXMgdmlvbGF0ZSBhbGwgZ29vZCBwcmF0aWNlcyBidXQgaXQgaXMgdXNlZCBoZXJlIHRvIHNpbXBsaWZ5IHRoZSBoYW5kbGluZyBvZiBwZXJpb2RpYyB3YXZlcy5cbiAgICAgICAgICByZXR1cm4gcGVyaW9kaWNXYXZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUGVyaW9kaWNXYXZlLCBudWxsLCBbe1xuICAgICAgICAgIGtleTogU3ltYm9sLmhhc0luc3RhbmNlLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlICE9PSBudWxsICYmIF90eXBlb2YoaW5zdGFuY2UpID09PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpID09PSBQZXJpb2RpY1dhdmUucHJvdG90eXBlIHx8IHBlcmlvZGljV2F2ZVN0b3JlLmhhcyhpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVSZW5kZXJBdXRvbWF0aW9uID0gZnVuY3Rpb24gY3JlYXRlUmVuZGVyQXV0b21hdGlvbihnZXRBdWRpb1BhcmFtUmVuZGVyZXIsIHJlbmRlcklucHV0c09mQXVkaW9QYXJhbSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBhdWRpb1BhcmFtLCBuYXRpdmVBdWRpb1BhcmFtKSB7XG4gICAgICAgIHZhciBhdWRpb1BhcmFtUmVuZGVyZXIgPSBnZXRBdWRpb1BhcmFtUmVuZGVyZXIoYXVkaW9QYXJhbSk7XG4gICAgICAgIGF1ZGlvUGFyYW1SZW5kZXJlci5yZXBsYXkobmF0aXZlQXVkaW9QYXJhbSk7XG4gICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvUGFyYW0oYXVkaW9QYXJhbSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9QYXJhbSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUmVuZGVySW5wdXRzT2ZBdWRpb05vZGUgPSBmdW5jdGlvbiBjcmVhdGVSZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0QXVkaW9Ob2RlUmVuZGVyZXIsIGlzUGFydE9mQUN5Y2xlKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGF1ZGlvTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9Ob2RlKSB7XG4gICAgICAgICAgdmFyIGF1ZGlvTm9kZUNvbm5lY3Rpb25zO1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYXVkaW9Ob2RlQ29ubmVjdGlvbnMgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhhdWRpb05vZGUpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXVkaW9Ob2RlQ29ubmVjdGlvbnMuYWN0aXZlSW5wdXRzLm1hcChmdW5jdGlvbiAoY29ubmVjdGlvbnMsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShjb25uZWN0aW9ucykubWFwKC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNCwgc291cmNlLCBvdXRwdXQsIGF1ZGlvTm9kZVJlbmRlcmVyLCByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSwgZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLCBzb3VyY2UgPSBfcmVmNFswXSwgb3V0cHV0ID0gX3JlZjRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9Ob2RlUmVuZGVyZXIgPSBnZXRBdWRpb05vZGVSZW5kZXJlcihzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdWRpb05vZGVSZW5kZXJlci5yZW5kZXIoc291cmNlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IGF1ZGlvTm9kZS5jb250ZXh0LmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQYXJ0T2ZBQ3ljbGUoc291cmNlKSAmJiAoYXVkaW9Ob2RlICE9PSBkZXN0aW5hdGlvbiB8fCAhaXNQYXJ0T2ZBQ3ljbGUoYXVkaW9Ob2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlLmNvbm5lY3QobmF0aXZlQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhbGxSZW5kZXJpbmdQcm9taXNlcywgcmVuZGVyaW5nUHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsbFJlbmRlcmluZ1Byb21pc2VzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHJlbmRlcmluZ1Byb21pc2VzKSk7XG4gICAgICAgICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94MiwgX3gzKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJlbmRlcklucHV0c09mQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcklucHV0c09mQXVkaW9QYXJhbShnZXRBdWRpb05vZGVSZW5kZXJlciwgZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zLCBpc1BhcnRPZkFDeWNsZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhdWRpb1BhcmFtLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1BhcmFtKSB7XG4gICAgICAgICAgdmFyIGF1ZGlvUGFyYW1Db25uZWN0aW9ucztcbiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGF1ZGlvUGFyYW1Db25uZWN0aW9ucyA9IGdldEF1ZGlvUGFyYW1Db25uZWN0aW9ucyhhdWRpb1BhcmFtKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKEFycmF5LmZyb20oYXVkaW9QYXJhbUNvbm5lY3Rpb25zLmFjdGl2ZUlucHV0cykubWFwKC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoX3JlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0LCBzb3VyY2UsIG91dHB1dCwgYXVkaW9Ob2RlUmVuZGVyZXIsIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksIHNvdXJjZSA9IF9yZWY0WzBdLCBvdXRwdXQgPSBfcmVmNFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9Ob2RlUmVuZGVyZXIgPSBnZXRBdWRpb05vZGVSZW5kZXJlcihzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvTm9kZVJlbmRlcmVyLnJlbmRlcihzb3VyY2UsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQYXJ0T2ZBQ3ljbGUoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlLmNvbm5lY3QobmF0aXZlQXVkaW9QYXJhbSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94NCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpKSk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94LCBfeDIsIF94Mykge1xuICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVSZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlUmVuZGVyTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlLCB0ZXN0T2ZmbGluZUF1ZGlvQ29udGV4dEN1cnJlbnRUaW1lU3VwcG9ydCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgIC8vIEJ1ZyAjMjE6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHByb21pc2VzIHlldC5cbiAgICAgICAgaWYgKGNhY2hlVGVzdFJlc3VsdCh0ZXN0UHJvbWlzZVN1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdFByb21pc2VTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIC8vIEJ1ZyAjMTU4OiBDaHJvbWUgYW5kIEVkZ2UgZG8gbm90IGFkdmFuY2UgY3VycmVudFRpbWUgaWYgaXQgaXMgbm90IGFjY2Vzc2VkIHdoaWxlIHJlbmRlcmluZyB0aGUgYXVkaW8uXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZVRlc3RSZXN1bHQodGVzdE9mZmxpbmVBdWRpb0NvbnRleHRDdXJyZW50VGltZVN1cHBvcnQsIHRlc3RPZmZsaW5lQXVkaW9Db250ZXh0Q3VycmVudFRpbWVTdXBwb3J0KSkudGhlbihmdW5jdGlvbiAoaXNPZmZsaW5lQXVkaW9Db250ZXh0Q3VycmVudFRpbWVTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNPZmZsaW5lQXVkaW9Db250ZXh0Q3VycmVudFRpbWVTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHNjcmlwdFByb2Nlc3Nvck5vZGUgPSBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIDUxMiwgMCwgMSk7XG4gICAgICAgICAgICAgIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gbnVsbDsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICB9OyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuY29ubmVjdChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgLy8gQnVnICM0ODogU2FmYXJpIGRvZXMgbm90IHJlbmRlciBhbiBPZmZsaW5lQXVkaW9Db250ZXh0IHdpdGhvdXQgYW55IGNvbm5lY3RlZCBub2RlLlxuICAgICAgICAgIHZhciBnYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgICBnYWluOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBnYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXNvbHZlKGV2ZW50LnJlbmRlcmVkQnVmZmVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdhaW5Ob2RlLmNvbm5lY3QobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzID0gZnVuY3Rpb24gY3JlYXRlU2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyhhY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzU3RvcmUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgYWN0aXZlSW5wdXRzKSB7XG4gICAgICAgIGFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHNTdG9yZS5zZXQobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgYWN0aXZlSW5wdXRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTZXRBdWRpb05vZGVUYWlsVGltZSA9IGZ1bmN0aW9uIGNyZWF0ZVNldEF1ZGlvTm9kZVRhaWxUaW1lKGF1ZGlvTm9kZVRhaWxUaW1lU3RvcmUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9Ob2RlLCB0YWlsVGltZSkge1xuICAgICAgICByZXR1cm4gYXVkaW9Ob2RlVGFpbFRpbWVTdG9yZS5zZXQoYXVkaW9Ob2RlLCB0YWlsVGltZSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlU3RhcnRSZW5kZXJpbmcgPSBmdW5jdGlvbiBjcmVhdGVTdGFydFJlbmRlcmluZyhhdWRpb0J1ZmZlclN0b3JlLCBjYWNoZVRlc3RSZXN1bHQsIGdldEF1ZGlvTm9kZVJlbmRlcmVyLCBnZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydCwgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzLCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gZ2V0QXVkaW9Ob2RlUmVuZGVyZXIoZGVzdGluYXRpb24pLnJlbmRlcihkZXN0aW5hdGlvbiwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dClcbiAgICAgICAgLypcbiAgICAgICAgICogQnVnICM4NiAmICM4NzogSW52b2tpbmcgdGhlIHJlbmRlcmVyIG9mIGFuIEF1ZGlvV29ya2xldE5vZGUgbWlnaHQgYmUgbmVjZXNzYXJ5IGlmIGl0IGhhcyBubyBkaXJlY3Qgb3IgaW5kaXJlY3QgY29ubmVjdGlvbiB0byB0aGVcbiAgICAgICAgICogZGVzdGluYXRpb24uXG4gICAgICAgICAqLy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShnZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkpLm1hcChmdW5jdGlvbiAoYXVkaW9Xb3JrbGV0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEF1ZGlvTm9kZVJlbmRlcmVyKGF1ZGlvV29ya2xldE5vZGUpLnJlbmRlcihhdWRpb1dvcmtsZXROb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuICAgICAgICAgIC8vIEJ1ZyAjNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY29weUZyb21DaGFubmVsKCkgYW5kIGNvcHlUb0NoYW5uZWwoKS5cbiAgICAgICAgICAvLyBCdWcgIzEwMDogU2FmYXJpIGRvZXMgdGhyb3cgYSB3cm9uZyBlcnJvciB3aGVuIGNhbGxpbmcgZ2V0Q2hhbm5lbERhdGEoKSB3aXRoIGFuIG91dC1vZi1ib3VuZHMgdmFsdWUuXG4gICAgICAgICAgaWYgKHR5cGVvZiBhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kcyhhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJHZXRDaGFubmVsRGF0YU1ldGhvZChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICAvLyBCdWcgIzE1NzogRmlyZWZveCBkb2VzIG5vdCBhbGxvdyB0aGUgYnVmZmVyT2Zmc2V0IHRvIGJlIG91dC1vZi1ib3VuZHMuXG4gICAgICAgICAgfSBlbHNlIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXVkaW9CdWZmZXJTdG9yZS5hZGQoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlcjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJDQoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDEodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyQxID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgLypcbiAgICAgICAqIEJ1ZyAjMTA1OiBUaGUgY2hhbm5lbENvdW50TW9kZSBzaG91bGQgYmUgJ2NsYW1wZWQtbWF4JyBhY2NvcmRpbmcgdG8gdGhlIHNwZWMgYnV0IGlzIHNldCB0byAnZXhwbGljaXQnIHRvIGFjaGlldmUgY29uc2lzdGVudFxuICAgICAgICogYmVoYXZpb3IuXG4gICAgICAgKi9cbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBwYW46IDBcbiAgICB9O1xuICAgIHZhciBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUsIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RlcmVvUGFubmVyTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVyZW9QYW5uZXJOb2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBERUZBVUxUX09QVElPTlMkMSksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlID0gY3JlYXRlTmF0aXZlU3RlcmVvUGFubmVyTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBzdGVyZW9QYW5uZXJOb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJDEodGhpcywgU3RlcmVvUGFubmVyTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLCBzdGVyZW9QYW5uZXJOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICBfdGhpcy5fcGFuID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLnBhbik7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhTdGVyZW9QYW5uZXJOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFN0ZXJlb1Bhbm5lck5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcInBhblwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlU3RlcmVvUGFubmVyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSwgbmF0aXZlU3RlcmVvUGFubmVyTm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7XG4gICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAqIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlU3RlcmVvUGFubmVyTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBwYW46IG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUucGFuLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVTdGVyZW9QYW5uZXJOb2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmF0aXZlU3RlcmVvUGFubmVyTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wYW4sIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUucGFuKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucGFuLCBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLnBhbik7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIGlmICghaXNOYXRpdmVBdWRpb05vZGVGYWtlcihuYXRpdmVTdGVyZW9QYW5uZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVTdGVyZW9QYW5uZXJOb2RlID0gcmVuZGVyZWROYXRpdmVTdGVyZW9QYW5uZXJOb2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVTdGVyZW9QYW5uZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEJ1ZyAjMzM6IFNhZmFyaSBleHBvc2VzIGFuIEF1ZGlvQnVmZmVyIGJ1dCBpdCBjYW4ndCBiZSB1c2VkIGFzIGEgY29uc3RydWN0b3IuXG4gICAgdmFyIGNyZWF0ZVRlc3RBdWRpb0J1ZmZlckNvbnN0cnVjdG9yU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RBdWRpb0J1ZmZlckNvbnN0cnVjdG9yU3VwcG9ydChuYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBuYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGxlbmd0aDogMSxcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IDQ0MTAwXG4gICAgICAgICAgfSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogRmlyZWZveCB1cCB0byB2ZXJzaW9uIDY3IGRpZG4ndCBmdWxseSBzdXBwb3J0IHRoZSBjb3B5RnJvbUNoYW5uZWwoKSBhbmQgY29weVRvQ2hhbm5lbCgpIG1ldGhvZHMuIFRoZXJlZm9yZSB0ZXN0aW5nIG9uZSBvZiB0aG9zZSBtZXRob2RzXG4gICAgICogaXMgZW5vdWdoIHRvIGtub3cgaWYgdGhlIG90aGVyIG9uZSBpcyBzdXBwb3J0ZWQgYXMgd2VsbC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlVGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzU3ViYXJyYXlTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzU3ViYXJyYXlTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXIgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIC8vIEJ1ZyAjNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY29weUZyb21DaGFubmVsKCkgYW5kIGNvcHlUb0NoYW5uZWwoKS5cbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQnVmZmVyLmNvcHlUb0NoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbChzb3VyY2UsIDAsIDApO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRlc3RBdWRpb0NvbnRleHRDbG9zZU1ldGhvZFN1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0QXVkaW9Db250ZXh0Q2xvc2VNZXRob2RTdXBwb3J0KG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGNoZWNrIHRoZSBwcm90b3R5cGUgYmVmb3JlIGNvbnN0cnVjdGluZyB0aGUgQXVkaW9Db250ZXh0LlxuICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IucHJvdG90eXBlLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHZhciBpc0F1ZGlvQ29udGV4dENsb3NhYmxlID0gYXVkaW9Db250ZXh0LmNsb3NlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0F1ZGlvQ29udGV4dENsb3NhYmxlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRWRnZSB1cCB0byB2ZXJzaW9uIDE0LCBGaXJlZm94IHVwIHRvIHZlcnNpb24gNTIsIFNhZmFyaSB1cCB0byB2ZXJzaW9uIDkgYW5kIG1heWJlIG90aGVyIGJyb3dzZXJzXG4gICAgICogZGlkIG5vdCByZWZ1c2UgdG8gZGVjb2RlIGludmFsaWQgcGFyYW1ldGVycyB3aXRoIGEgVHlwZUVycm9yLlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVUZXN0QXVkaW9Db250ZXh0RGVjb2RlQXVkaW9EYXRhTWV0aG9kVHlwZUVycm9yU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RBdWRpb0NvbnRleHREZWNvZGVBdWRpb0RhdGFNZXRob2RUeXBlRXJyb3JTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIC8vIEJ1ZyAjMjE6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHByb21pc2VzIHlldC5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGlzUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgdmFyIHJlc29sdmVQcm9taXNlID0gZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UoZXJyKSB7XG4gICAgICAgICAgICBpZiAoaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgIGlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBvZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICAgIC8vIEJ1ZyAjMjY6IFNhZmFyaSB0aHJvd3MgYSBzeW5jaHJvbm91cyBlcnJvci5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG9mZmxpbmVBdWRpb0NvbnRleHRcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTogU2FmYXJpIHJlcXVpcmVzIGEgc3VjY2Vzc0NhbGxiYWNrLlxuICAgICAgICAgICAgLmRlY29kZUF1ZGlvRGF0YShudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICAgIH0sIHJlc29sdmVQcm9taXNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEJ1ZyAjMjE6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHByb21pc2VzIHlldC5cbiAgICAgICAgICBpZiAocHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzY6IENocm9tZSwgRWRnZSBhbmQgRmlyZWZveCBkbyBub3QgY2FsbCB0aGUgZXJyb3JDYWxsYmFjay5cbiAgICAgICAgICAgIHByb21pc2VbXCJjYXRjaFwiXShyZXNvbHZlUHJvbWlzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVUZXN0QXVkaW9Db250ZXh0T3B0aW9uc1N1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0QXVkaW9Db250ZXh0T3B0aW9uc1N1cHBvcnQobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXVkaW9Db250ZXh0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBsYXRlbmN5SGludDogJ2JhbGFuY2VkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFNhZmFyaSB1cCB0byB2ZXJzaW9uIDEyLjAgKGJ1dCBub3QgdjEyLjEpIGRpZG4ndCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIGluIGNhc2UgaXQgd2FzIGFuIEF1ZGlvTm9kZS5cbiAgICB2YXIgY3JlYXRlVGVzdEF1ZGlvTm9kZUNvbm5lY3RNZXRob2RTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdEF1ZGlvTm9kZUNvbm5lY3RNZXRob2RTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICB2YXIgbmF0aXZlR2Fpbk5vZGUgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgdmFyIGlzU3VwcG9ydGVkID0gbmF0aXZlR2Fpbk5vZGUuY29ubmVjdChuYXRpdmVHYWluTm9kZSkgPT09IG5hdGl2ZUdhaW5Ob2RlO1xuICAgICAgICBuYXRpdmVHYWluTm9kZS5kaXNjb25uZWN0KG5hdGl2ZUdhaW5Ob2RlKTtcbiAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hyb21lIHZlcnNpb24gNjYgYW5kIDY3IGRpZCBub3QgY2FsbCB0aGUgcHJvY2VzcygpIGZ1bmN0aW9uIG9mIGFuIEF1ZGlvV29ya2xldFByb2Nlc3NvciBpZiBpdCBoYWQgbm8gb3V0cHV0cy4gQXVkaW9Xb3JrbGV0IHN1cHBvcnQgd2FzXG4gICAgICogZW5hYmxlZCBieSBkZWZhdWx0IGluIHZlcnNpb24gNjYuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JOb091dHB1dHNTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdEF1ZGlvV29ya2xldFByb2Nlc3Nvck5vT3V0cHV0c1N1cHBvcnQobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgYmxvYiwgbWVzc2FnZUNoYW5uZWwsIG9mZmxpbmVBdWRpb0NvbnRleHQsIHVybCwgaXNDYWxsaW5nUHJvY2VzcywgYXVkaW9Xb3JrbGV0Tm9kZSwgb3NjaWxsYXRvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpZiAoIShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbJ2xldCBjLHA7Y2xhc3MgQSBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3Nvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7dGhpcy5wb3J0Lm9ubWVzc2FnZT0oZSk9PntwPWUuZGF0YTtwLm9ubWVzc2FnZT0oKT0+e3AucG9zdE1lc3NhZ2UoYyk7cC5jbG9zZSgpfTt0aGlzLnBvcnQucG9zdE1lc3NhZ2UoMCl9fXByb2Nlc3MoKXtjPTF9fXJlZ2lzdGVyUHJvY2Vzc29yKFwiYVwiLEEpJ10sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDsgY2hhcnNldD11dGYtOCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7IC8vIEJ1ZyAjMTQxOiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjcmVhdGluZyBhbiBPZmZsaW5lQXVkaW9Db250ZXh0IHdpdGggbGVzcyB0aGFuIDQ0MTAwIEh6LlxuICAgICAgICAgICAgICBvZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxMjgsIDQ0MTAwKTtcbiAgICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgaXNDYWxsaW5nUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICByZXR1cm4gb2ZmbGluZUF1ZGlvQ29udGV4dC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHVybCk7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBhdWRpb1dvcmtsZXROb2RlID0gbmV3IG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvcihvZmZsaW5lQXVkaW9Db250ZXh0LCAnYScsIHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG9zY2lsbGF0b3IgPSBvZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBhdWRpb1dvcmtsZXROb2RlLnBvcnQub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF1ZGlvV29ya2xldE5vZGUucG9ydC5wb3N0TWVzc2FnZShtZXNzYWdlQ2hhbm5lbC5wb3J0MiwgW21lc3NhZ2VDaGFubmVsLnBvcnQyXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgYXVkaW9Xb3JrbGV0Tm9kZS5wb3J0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDYWxsaW5nUHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIG9zY2lsbGF0b3IuY29ubmVjdChhdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgICAgICAgICAgb3NjaWxsYXRvci5zdGFydCgwKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICByZXR1cm4gb2ZmbGluZUF1ZGlvQ29udGV4dC5zdGFydFJlbmRlcmluZygpO1xuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIzO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEgPT09IDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgaXNDYWxsaW5nUHJvY2VzcyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjY7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg5KTtcbiAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyODtcbiAgICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEuY2xvc2UoKTtcbiAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDI4KTtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgaXNDYWxsaW5nUHJvY2Vzcyk7XG4gICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1s5LCAyNiwgMjgsIDMyXV0pO1xuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICAvLyBCdWcgIzE3OTogRmlyZWZveCBkb2VzIG5vdCBhbGxvdyB0byB0cmFuc2ZlciBhbnkgYnVmZmVyIHdoaWNoIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgcHJvY2VzcygpIG1ldGhvZCBhcyBhbiBhcmd1bWVudC5cbiAgICB2YXIgY3JlYXRlVGVzdEF1ZGlvV29ya2xldFByb2Nlc3NvclBvc3RNZXNzYWdlU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JQb3N0TWVzc2FnZVN1cHBvcnQobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgYmxvYiwgb2ZmbGluZUF1ZGlvQ29udGV4dCwgdXJsLCBpc0VtaXR0aW5nTWVzc2FnZUV2ZW50cywgaXNFbWl0dGluZ1Byb2Nlc3NvckVycm9yRXZlbnRzLCBhdWRpb1dvcmtsZXROb2RlLCBvc2NpbGxhdG9yO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCEobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGlmICghKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFsnY2xhc3MgQSBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3Nvcntwcm9jZXNzKGkpe3RoaXMucG9ydC5wb3N0TWVzc2FnZShpLFtpWzBdWzBdLmJ1ZmZlcl0pfX1yZWdpc3RlclByb2Nlc3NvcihcImFcIixBKSddLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7IGNoYXJzZXQ9dXRmLTgnXG4gICAgICAgICAgICAgIH0pOyAvLyBCdWcgIzE0MTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY3JlYXRpbmcgYW4gT2ZmbGluZUF1ZGlvQ29udGV4dCB3aXRoIGxlc3MgdGhhbiA0NDEwMCBIei5cbiAgICAgICAgICAgICAgb2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMTI4LCA0NDEwMCk7XG4gICAgICAgICAgICAgIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgIGlzRW1pdHRpbmdNZXNzYWdlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlzRW1pdHRpbmdQcm9jZXNzb3JFcnJvckV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICByZXR1cm4gb2ZmbGluZUF1ZGlvQ29udGV4dC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHVybCk7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBhdWRpb1dvcmtsZXROb2RlID0gbmV3IG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvcihvZmZsaW5lQXVkaW9Db250ZXh0LCAnYScsIHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG9zY2lsbGF0b3IgPSBvZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgICAgICAgYXVkaW9Xb3JrbGV0Tm9kZS5wb3J0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFbWl0dGluZ01lc3NhZ2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhdWRpb1dvcmtsZXROb2RlLm9ucHJvY2Vzc29yZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRW1pdHRpbmdQcm9jZXNzb3JFcnJvckV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIG9zY2lsbGF0b3IuY29ubmVjdChhdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgICAgICAgICAgb3NjaWxsYXRvci5zdGFydCgwKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICByZXR1cm4gb2ZmbGluZUF1ZGlvQ29udGV4dC5zdGFydFJlbmRlcmluZygpO1xuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI0O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oOSk7XG4gICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjY7XG4gICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyNik7XG4gICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGlzRW1pdHRpbmdNZXNzYWdlRXZlbnRzICYmICFpc0VtaXR0aW5nUHJvY2Vzc29yRXJyb3JFdmVudHMpO1xuICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbOSwgMjQsIDI2LCAyOV1dKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWZveCB1cCB0byB2ZXJzaW9uIDY5IGRpZCBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBzZXR0aW5nIGEgZGlmZmVyZW50IGNoYW5uZWxDb3VudCBvciBjaGFubmVsQ291bnRNb2RlLlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVUZXN0Q2hhbm5lbE1lcmdlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdENoYW5uZWxNZXJnZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgdmFyIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlID0gb2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWcgIzE1OiBTYWZhcmkgZG9lcyBub3QgcmV0dXJuIHRoZSBkZWZhdWx0IHByb3BlcnRpZXMuIEl0IHN0aWxsIG5lZWRzIHRvIGJlIHBhdGNoZWQuIFRoaXMgdGVzdCBpcyBzdXBwb3NlZCB0byB0ZXN0IHRoZSBzdXBwb3J0XG4gICAgICAgICAqIGluIG90aGVyIGJyb3dzZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZS5jaGFubmVsQ291bnQgPSAyO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRlc3RDb25zdGFudFNvdXJjZU5vZGVBY2N1cmF0ZVNjaGVkdWxpbmdTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdENvbnN0YW50U291cmNlTm9kZUFjY3VyYXRlU2NoZWR1bGluZ1N1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIC8vIEJ1ZyAjNjI6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IENvbnN0YW50U291cmNlTm9kZXMuXG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUNvbnN0YW50U291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlID0gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVDb25zdGFudFNvdXJjZSgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBAdG9kbyBUaGlzIGlzIHVzaW5nIGJ1ZyAjNzUgdG8gZGV0ZWN0IGJ1ZyAjNzAuIFRoYXQgd29ya3MgYmVjYXVzZSBib3RoIGJ1Z3Mgd2VyZSB1bmlxdWUgdG9cbiAgICAgICAgICogdGhlIGltcGxlbWVudGF0aW9uIG9mIEZpcmVmb3ggcmlnaHQgbm93LCBidXQgaXQgY291bGQgcHJvYmFibHkgYmUgZG9uZSBpbiBhIGJldHRlciB3YXkuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLm9mZnNldC5tYXhWYWx1ZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gT3BlcmEgdXAgdG8gdmVyc2lvbiA1NyBkaWQgbm90IGFsbG93IHRvIHJlYXNzaWduIHRoZSBidWZmZXIgb2YgYSBDb252b2x2ZXJOb2RlLlxuICAgIHZhciBjcmVhdGVUZXN0Q29udm9sdmVyTm9kZUJ1ZmZlclJlYXNzaWduYWJpbGl0eVN1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0Q29udm9sdmVyTm9kZUJ1ZmZlclJlYXNzaWduYWJpbGl0eVN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIHZhciBuYXRpdmVDb252b2x2ZXJOb2RlID0gb2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcbiAgICAgICAgbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXIgPSBvZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCBvZmZsaW5lQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5hdGl2ZUNvbnZvbHZlck5vZGUuYnVmZmVyID0gb2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgb2ZmbGluZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIENocm9tZSB1cCB0byB2ZXJzaW9uIHY4MCwgRWRnZSB1cCB0byB2ZXJzaW9uIHY4MCBhbmQgT3BlcmEgdXAgdG8gdmVyc2lvbiB2NjcgZGlkIG5vdCBhbGxvdyB0byBzZXQgdGhlIGNoYW5uZWxDb3VudCBwcm9wZXJ0eSBvZiBhIENvbnZvbHZlck5vZGUgdG8gMS4gVGhleSBhbHNvIGRpZCBub3QgYWxsb3cgdG8gc2V0IHRoZSBjaGFubmVsQ291bnRNb2RlIHRvICdleHBsaWNpdCcuXG4gICAgdmFyIGNyZWF0ZVRlc3RDb252b2x2ZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RDb252b2x2ZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgdmFyIG5hdGl2ZUNvbnZvbHZlck5vZGUgPSBvZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5hdGl2ZUNvbnZvbHZlck5vZGUuY2hhbm5lbENvdW50ID0gMTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVUZXN0SXNTZWN1cmVDb250ZXh0U3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RJc1NlY3VyZUNvbnRleHRTdXBwb3J0KHdpbmRvdykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdyAhPT0gbnVsbCAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2lzU2VjdXJlQ29udGV4dCcpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRmlyZWZveCB1cCB0byB2ZXJzaW9uIDY4IGRpZCBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBjcmVhdGluZyBhIE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlIHdpdGggYSBtZWRpYVN0cmVhbSB0aGF0IGhhZCBubyBhdWRpbyB0cmFjay5cbiAgICB2YXIgY3JlYXRlVGVzdE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlTWVkaWFTdHJlYW1XaXRob3V0QXVkaW9UcmFja1N1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVNZWRpYVN0cmVhbVdpdGhvdXRBdWRpb1RyYWNrU3VwcG9ydChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKCkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVUZXN0T2ZmbGluZUF1ZGlvQ29udGV4dEN1cnJlbnRUaW1lU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RPZmZsaW5lQXVkaW9Db250ZXh0Q3VycmVudFRpbWVTdXBwb3J0KGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICAvLyBCdWcgIzQ4OiBTYWZhcmkgZG9lcyBub3QgcmVuZGVyIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQgd2l0aG91dCBhbnkgY29ubmVjdGVkIG5vZGUuXG4gICAgICAgIHZhciBnYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQnVnICMyMTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJvbWlzZXMgeWV0LlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXNvbHZlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3VycmVudFRpbWUgIT09IDApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVmb3ggdXAgdG8gdmVyc2lvbiA2MiBkaWQgbm90IGtpY2sgb2ZmIHRoZSBwcm9jZXNzaW5nIG9mIHRoZSBTdGVyZW9QYW5uZXJOb2RlIGlmIHRoZSB2YWx1ZSBvZiBwYW4gd2FzIHplcm8uXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVRlc3RTdGVyZW9QYW5uZXJOb2RlRGVmYXVsdFZhbHVlU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RTdGVyZW9QYW5uZXJOb2RlRGVmYXVsdFZhbHVlU3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICAvKlxuICAgICAgICAgKiBCdWcgIzEwNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgdGhlIFN0ZXJlb1Bhbm5lck5vZGUuIFRoZXJlZm9yZSB0aGUgcmV0dXJuZWQgdmFsdWUgc2hvdWxkIG5vcm1hbGx5IGJlIGZhbHNlIGJ1dCB0aGUgZmFrZXIgZG9lc1xuICAgICAgICAgKiBzdXBwb3J0IHRoZSB0ZXN0ZWQgYmVoYXZpb3VyLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjNjI6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IENvbnN0YW50U291cmNlTm9kZXMuXG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUNvbnN0YW50U291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGUgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUNvbnN0YW50U291cmNlKCk7XG4gICAgICAgIHZhciBzdGVyZW9QYW5uZXIgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZVN0ZXJlb1Bhbm5lcigpO1xuICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuY2hhbm5lbENvdW50ID0gMTtcbiAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlLm9mZnNldC52YWx1ZSA9IDE7XG4gICAgICAgIHN0ZXJlb1Bhbm5lci5jaGFubmVsQ291bnQgPSAxO1xuICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuc3RhcnQoKTtcbiAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlLmNvbm5lY3Qoc3RlcmVvUGFubmVyKS5jb25uZWN0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICByZXR1cm4gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zdGFydFJlbmRlcmluZygpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMClbMF0gIT09IDE7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVVua25vd25FcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZVVua25vd25FcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnVW5rbm93bkVycm9yJyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkMyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgY3VydmU6IG51bGwsXG4gICAgICBvdmVyc2FtcGxlOiAnbm9uZSdcbiAgICB9O1xuICAgIHZhciBjcmVhdGVXYXZlU2hhcGVyTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlV2F2ZVNoYXBlck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBjcmVhdGVXYXZlU2hhcGVyTm9kZVJlbmRlcmVyLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHNldEF1ZGlvTm9kZVRhaWxUaW1lKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gV2F2ZVNoYXBlck5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2F2ZVNoYXBlck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIHdhdmVTaGFwZXJOb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVXYXZlU2hhcGVyTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIC8vIEB0b2RvIEFkZCBhIG1lY2hhbmlzbSB0byBvbmx5IHN3aXRjaCBhIFdhdmVTaGFwZXJOb2RlIHRvIGFjdGl2ZSB3aGlsZSBpdCBpcyBjb25uZWN0ZWQuXG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFdhdmVTaGFwZXJOb2RlLCBbY29udGV4dCwgdHJ1ZSwgbmF0aXZlV2F2ZVNoYXBlck5vZGUsIHdhdmVTaGFwZXJOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICBfdGhpcy5faXNDdXJ2ZU51bGxpZmllZCA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVXYXZlU2hhcGVyTm9kZSA9IG5hdGl2ZVdhdmVTaGFwZXJOb2RlO1xuICAgICAgICAgIC8vIEB0b2RvIERldGVybWluZSBhIG1lYW5pbmdmdWwgdGFpbC10aW1lIGluc3RlYWQgb2YganVzdCB1c2luZyBvbmUgc2Vjb25kLlxuICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKF90aGlzLCAxKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKFdhdmVTaGFwZXJOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFdhdmVTaGFwZXJOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJjdXJ2ZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ3VydmVOdWxsaWZpZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlV2F2ZVNoYXBlck5vZGUuY3VydmU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQnVnICMxMDM6IFNhZmFyaSBkb2VzIG5vdCBhbGxvdyB0byBzZXQgdGhlIGN1cnZlIHRvIG51bGwuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5faXNDdXJ2ZU51bGxpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZVdhdmVTaGFwZXJOb2RlLmN1cnZlID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQnVnICMxMDI6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBJbnZhbGlkU3RhdGVFcnJvciB3aGVuIHRoZSBjdXJ2ZSBoYXMgbGVzcyB0aGFuIHR3byBzYW1wbGVzLlxuICAgICAgICAgICAgICAvLyBCdWcgIzEwNDogQ2hyb21lIGFuZCBFZGdlIHdpbGwgdGhyb3cgYW4gSW52YWxpZEFjY2Vzc0Vycm9yIHdoZW4gdGhlIGN1cnZlIGhhcyBsZXNzIHRoYW4gdHdvIHNhbXBsZXMuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9pc0N1cnZlTnVsbGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZVdhdmVTaGFwZXJOb2RlLmN1cnZlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm92ZXJzYW1wbGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVXYXZlU2hhcGVyTm9kZS5vdmVyc2FtcGxlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVdhdmVTaGFwZXJOb2RlLm92ZXJzYW1wbGUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlV2F2ZVNoYXBlck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVXYXZlU2hhcGVyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlV2F2ZVNoYXBlck5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGNyZWF0ZVdhdmVTaGFwZXJOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBuYXRpdmVXYXZlU2hhcGVyTm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlV2F2ZVNoYXBlck5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlV2F2ZVNoYXBlck5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICBuYXRpdmVXYXZlU2hhcGVyTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlV2F2ZVNoYXBlck5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlV2F2ZVNoYXBlck5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZTogbmF0aXZlV2F2ZVNoYXBlck5vZGUuY3VydmUsXG4gICAgICAgICAgICAgICAgICAgICAgb3ZlcnNhbXBsZTogbmF0aXZlV2F2ZVNoYXBlck5vZGUub3ZlcnNhbXBsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVXYXZlU2hhcGVyTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZVdhdmVTaGFwZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNOYXRpdmVBdWRpb05vZGVGYWtlcihuYXRpdmVXYXZlU2hhcGVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZVdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVXYXZlU2hhcGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlV2F2ZVNoYXBlck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVXYXZlU2hhcGVyTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlV2F2ZVNoYXBlck5vZGUgPSByZW5kZXJlZE5hdGl2ZVdhdmVTaGFwZXJOb2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVXYXZlU2hhcGVyTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVXYXZlU2hhcGVyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlV2F2ZVNoYXBlck5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiBjcmVhdGVXaW5kb3coKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlV3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzID0gZnVuY3Rpb24gY3JlYXRlV3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzKGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZywgY3JlYXRlSW5kZXhTaXplRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgYXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBjaGFubmVsTnVtYmVyQXNOdW1iZXIpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0QXNOdW1iZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhidWZmZXJPZmZzZXRBc051bWJlcik7XG4gICAgICAgICAgdmFyIGNoYW5uZWxOdW1iZXIgPSBjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcoY2hhbm5lbE51bWJlckFzTnVtYmVyKTtcbiAgICAgICAgICBpZiAoY2hhbm5lbE51bWJlciA+PSBhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXVkaW9CdWZmZXJMZW5ndGggPSBhdWRpb0J1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbE51bWJlcik7XG4gICAgICAgICAgdmFyIGRlc3RpbmF0aW9uTGVuZ3RoID0gZGVzdGluYXRpb24ubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBidWZmZXJPZmZzZXQgPCAwID8gLWJ1ZmZlck9mZnNldCA6IDA7IGkgKyBidWZmZXJPZmZzZXQgPCBhdWRpb0J1ZmZlckxlbmd0aCAmJiBpIDwgZGVzdGluYXRpb25MZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25baV0gPSBjaGFubmVsRGF0YVtpICsgYnVmZmVyT2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGF1ZGlvQnVmZmVyLmNvcHlUb0NoYW5uZWwgPSBmdW5jdGlvbiAoc291cmNlLCBjaGFubmVsTnVtYmVyQXNOdW1iZXIpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0QXNOdW1iZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhidWZmZXJPZmZzZXRBc051bWJlcik7XG4gICAgICAgICAgdmFyIGNoYW5uZWxOdW1iZXIgPSBjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcoY2hhbm5lbE51bWJlckFzTnVtYmVyKTtcbiAgICAgICAgICBpZiAoY2hhbm5lbE51bWJlciA+PSBhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXVkaW9CdWZmZXJMZW5ndGggPSBhdWRpb0J1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbE51bWJlcik7XG4gICAgICAgICAgdmFyIHNvdXJjZUxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGJ1ZmZlck9mZnNldCA8IDAgPyAtYnVmZmVyT2Zmc2V0IDogMDsgaSArIGJ1ZmZlck9mZnNldCA8IGF1ZGlvQnVmZmVyTGVuZ3RoICYmIGkgPCBzb3VyY2VMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY2hhbm5lbERhdGFbaSArIGJ1ZmZlck9mZnNldF0gPSBzb3VyY2VbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzID0gZnVuY3Rpb24gY3JlYXRlV3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMoY29udmVydE51bWJlclRvVW5zaWduZWRMb25nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvQnVmZmVyKSB7XG4gICAgICAgIGF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbCA9IGZ1bmN0aW9uIChjb3B5RnJvbUNoYW5uZWwpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBjaGFubmVsTnVtYmVyQXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXJPZmZzZXRBc051bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgICAgIHZhciBidWZmZXJPZmZzZXQgPSBjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcoYnVmZmVyT2Zmc2V0QXNOdW1iZXIpO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxOdW1iZXIgPSBjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcoY2hhbm5lbE51bWJlckFzTnVtYmVyKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJPZmZzZXQgPCBhdWRpb0J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvcHlGcm9tQ2hhbm5lbC5jYWxsKGF1ZGlvQnVmZmVyLCBkZXN0aW5hdGlvbiwgY2hhbm5lbE51bWJlciwgYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KGF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbCk7XG4gICAgICAgIGF1ZGlvQnVmZmVyLmNvcHlUb0NoYW5uZWwgPSBmdW5jdGlvbiAoY29weVRvQ2hhbm5lbCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlLCBjaGFubmVsTnVtYmVyQXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXJPZmZzZXRBc051bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgICAgIHZhciBidWZmZXJPZmZzZXQgPSBjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcoYnVmZmVyT2Zmc2V0QXNOdW1iZXIpO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxOdW1iZXIgPSBjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcoY2hhbm5lbE51bWJlckFzTnVtYmVyKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJPZmZzZXQgPCBhdWRpb0J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvcHlUb0NoYW5uZWwuY2FsbChhdWRpb0J1ZmZlciwgc291cmNlLCBjaGFubmVsTnVtYmVyLCBidWZmZXJPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0oYXVkaW9CdWZmZXIuY29weVRvQ2hhbm5lbCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlV3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0b3BNZXRob2ROdWxsaWZpZWRCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVXcmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RvcE1ldGhvZE51bGxpZmllZEJ1ZmZlcihvdmVyd3JpdGVBY2Nlc3NvcnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBuYXRpdmVDb250ZXh0KSB7XG4gICAgICAgIHZhciBudWxsaWZpZWRCdWZmZXIgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIGlmIChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmJ1ZmZlciA9IG51bGxpZmllZEJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBvdmVyd3JpdGVBY2Nlc3NvcnMobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCAnYnVmZmVyJywgZnVuY3Rpb24gKGdldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXQuY2FsbChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsaWZpZWRCdWZmZXIgPyBudWxsIDogdmFsdWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXQuY2FsbChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIHZhbHVlID09PSBudWxsID8gbnVsbGlmaWVkQnVmZmVyIDogdmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdyYXBDaGFubmVsTWVyZ2VyTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZVdyYXBDaGFubmVsTWVyZ2VyTm9kZShjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgbW9uaXRvckNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIGNoYW5uZWxNZXJnZXJOb2RlKSB7XG4gICAgICAgIC8vIEJ1ZyAjMTU6IFNhZmFyaSBkb2VzIG5vdCByZXR1cm4gdGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgICAgY2hhbm5lbE1lcmdlck5vZGUuY2hhbm5lbENvdW50ID0gMTtcbiAgICAgICAgY2hhbm5lbE1lcmdlck5vZGUuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG4gICAgICAgIC8vIEJ1ZyAjMTY6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuIHNldHRpbmcgYSBkaWZmZXJlbnQgY2hhbm5lbENvdW50IG9yIGNoYW5uZWxDb3VudE1vZGUuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFubmVsTWVyZ2VyTm9kZSwgJ2NoYW5uZWxDb3VudCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFubmVsTWVyZ2VyTm9kZSwgJ2NoYW5uZWxDb3VudE1vZGUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2V4cGxpY2l0JztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCdWcgIzIwOiBTYWZhcmkgcmVxdWlyZXMgYSBjb25uZWN0aW9uIG9mIGFueSBraW5kIHRvIHRyZWF0IHRoZSBpbnB1dCBzaWduYWwgY29ycmVjdGx5LlxuICAgICAgICB2YXIgYXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgdmFyIHdoZW5Db25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuQ29ubmVjdGVkKCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBjaGFubmVsTWVyZ2VyTm9kZS5udW1iZXJPZklucHV0cztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgd2hlbkRpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5EaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbW9uaXRvckNvbm5lY3Rpb25zKGNoYW5uZWxNZXJnZXJOb2RlLCB3aGVuQ29ubmVjdGVkLCB3aGVuRGlzY29ubmVjdGVkKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBnZXRGaXJzdFNhbXBsZSA9IGZ1bmN0aW9uIGdldEZpcnN0U2FtcGxlKGF1ZGlvQnVmZmVyLCBidWZmZXIsIGNoYW5uZWxOdW1iZXIpIHtcbiAgICAgIC8vIEJ1ZyAjNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY29weUZyb21DaGFubmVsKCkgYW5kIGNvcHlUb0NoYW5uZWwoKS5cbiAgICAgIGlmIChhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbE51bWJlcilbMF07XG4gICAgICB9XG4gICAgICBhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwoYnVmZmVyLCBjaGFubmVsTnVtYmVyKTtcbiAgICAgIHJldHVybiBidWZmZXJbMF07XG4gICAgfTtcblxuICAgIHZhciBpc0RDQ3VydmUgPSBmdW5jdGlvbiBpc0RDQ3VydmUoY3VydmUpIHtcbiAgICAgIGlmIChjdXJ2ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gY3VydmUubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGN1cnZlW01hdGguZmxvb3IobGVuZ3RoIC8gMildICE9PSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnZlW2xlbmd0aCAvIDIgLSAxXSArIGN1cnZlW2xlbmd0aCAvIDJdICE9PSAwO1xuICAgIH07XG5cbiAgICB2YXIgb3ZlcndyaXRlQWNjZXNzb3JzID0gZnVuY3Rpb24gb3ZlcndyaXRlQWNjZXNzb3JzKG9iamVjdCwgcHJvcGVydHksIGNyZWF0ZUdldHRlciwgY3JlYXRlU2V0dGVyKSB7XG4gICAgICB2YXIgcHJvdG90eXBlID0gb2JqZWN0O1xuICAgICAgd2hpbGUgKCFwcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpO1xuICAgICAgfVxuICAgICAgdmFyIF9PYmplY3QkZ2V0T3duUHJvcGVydCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBwcm9wZXJ0eSksXG4gICAgICAgIGdldCA9IF9PYmplY3QkZ2V0T3duUHJvcGVydC5nZXQsXG4gICAgICAgIHNldCA9IF9PYmplY3QkZ2V0T3duUHJvcGVydC5zZXQ7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgICBnZXQ6IGNyZWF0ZUdldHRlcihnZXQpLFxuICAgICAgICBzZXQ6IGNyZWF0ZVNldHRlcihzZXQpXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQyKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQyKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQyKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgdmFyIHNhbml0aXplQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMgPSBmdW5jdGlvbiBzYW5pdGl6ZUF1ZGlvV29ya2xldE5vZGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgb3V0cHV0Q2hhbm5lbENvdW50OiBvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQgOiBvcHRpb25zLm51bWJlck9mSW5wdXRzID09PSAxICYmIG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzID09PSAxID9cbiAgICAgICAgLypcbiAgICAgICAgICogQnVnICM2MTogVGhpcyBzaG91bGQgYmUgdGhlIGNvbXB1dGVkTnVtYmVyT2ZDaGFubmVscywgYnV0IHVuZm9ydHVuYXRlbHkgdGhhdCBpcyBhbG1vc3QgaW1wb3NzaWJsZSB0byBmYWtlLiBUaGF0J3Mgd2h5XG4gICAgICAgICAqIHRoZSBjaGFubmVsQ291bnRNb2RlIGlzIHJlcXVpcmVkIHRvIGJlICdleHBsaWNpdCcgYXMgbG9uZyBhcyB0aGVyZSBpcyBub3QgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24gaW4gZXZlcnkgYnJvd3Nlci4gVGhhdFxuICAgICAgICAgKiBtYWtlcyBzdXJlIHRoZSBjb21wdXRlZE51bWJlck9mQ2hhbm5lbHMgaXMgZXF1aXZpbGFudCB0byB0aGUgY2hhbm5lbENvdW50IHdoaWNoIG1ha2VzIGl0IG11Y2ggZWFzaWVyIHRvIGNvbXB1dGUuXG4gICAgICAgICAqL1xuICAgICAgICBbb3B0aW9ucy5jaGFubmVsQ291bnRdIDogQXJyYXkuZnJvbSh7XG4gICAgICAgICAgbGVuZ3RoOiBvcHRpb25zLm51bWJlck9mT3V0cHV0c1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQxKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQxKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQxKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgdmFyIHNhbml0aXplQ2hhbm5lbFNwbGl0dGVyT3B0aW9ucyA9IGZ1bmN0aW9uIHNhbml0aXplQ2hhbm5lbFNwbGl0dGVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIGNoYW5uZWxDb3VudDogb3B0aW9ucy5udW1iZXJPZk91dHB1dHNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgdmFyIHNhbml0aXplUGVyaW9kaWNXYXZlT3B0aW9ucyA9IGZ1bmN0aW9uIHNhbml0aXplUGVyaW9kaWNXYXZlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZyA9IG9wdGlvbnMuaW1hZyxcbiAgICAgICAgcmVhbCA9IG9wdGlvbnMucmVhbDtcbiAgICAgIGlmIChpbWFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgaW1hZzogWzAsIDBdLFxuICAgICAgICAgICAgcmVhbDogWzAsIDBdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgaW1hZzogQXJyYXkuZnJvbShyZWFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByZWFsOiByZWFsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICBpbWFnOiBpbWFnLFxuICAgICAgICAgIHJlYWw6IEFycmF5LmZyb20oaW1hZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgaW1hZzogaW1hZyxcbiAgICAgICAgcmVhbDogcmVhbFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBfc2V0VmFsdWVBdFRpbWVVbnRpbFBvc3NpYmxlID0gZnVuY3Rpb24gc2V0VmFsdWVBdFRpbWVVbnRpbFBvc3NpYmxlKGF1ZGlvUGFyYW0sIHZhbHVlLCBzdGFydFRpbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlICE9PSA5KSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIF9zZXRWYWx1ZUF0VGltZVVudGlsUG9zc2libGUoYXVkaW9QYXJhbSwgdmFsdWUsIHN0YXJ0VGltZSArIDFlLTcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kQ29uc2VjdXRpdmVDYWxsc1N1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydChuYXRpdmVDb250ZXh0KSB7XG4gICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KCk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmdTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmdTdXBwb3J0KG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgNDQxMDApO1xuICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmJ1ZmZlciA9IG5hdGl2ZUF1ZGlvQnVmZmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KDAsIDEpO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyU3VwcG9ydCA9IGZ1bmN0aW9uIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyU3VwcG9ydChuYXRpdmVDb250ZXh0KSB7XG4gICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0b3AoKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydChuYXRpdmVDb250ZXh0KSB7XG4gICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgICB0cnkge1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoLTEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBSYW5nZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCA9IGZ1bmN0aW9uIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxsc1N1cHBvcnQobmF0aXZlQ29udGV4dCkge1xuICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgNDQxMDApO1xuICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID0gbmF0aXZlQXVkaW9CdWZmZXI7XG4gICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKTtcbiAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wKCk7XG4gICAgICB0cnkge1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wKC0xKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgUmFuZ2VFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RBdWRpb1dvcmtsZXROb2RlT3B0aW9uc0Nsb25hYmlsaXR5ID0gZnVuY3Rpb24gdGVzdEF1ZGlvV29ya2xldE5vZGVPcHRpb25zQ2xvbmFiaWxpdHkoYXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMpIHtcbiAgICAgIHZhciBfTWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydDEgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDEsXG4gICAgICAgIHBvcnQyID0gX01lc3NhZ2VDaGFubmVsLnBvcnQyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyBhcmUgbm90IGNsb25hYmxlLlxuICAgICAgICBwb3J0MS5wb3N0TWVzc2FnZShhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgICBwb3J0Mi5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEJ1ZyAjMTIyOiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3QgYWxsb3cgdG8gY29uc3RydWN0IGEgRE9NRXhjZXB0aW9uJy4gSXQgYWxzbyBoYWQgYSBjb3VwbGUgbW9yZSBidWdzIGJ1dCBzaW5jZSB0aGlzIGlzIGVhc3kgdG9cbiAgICAgKiB0ZXN0IGl0J3MgdXNlZCBoZXJlIGFzIGEgcGxhY2Vob2xkZXIuXG4gICAgICpcbiAgICAgKiBCdWcgIzI3OiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCByZWplY3QgYW4gaW52YWxpZCBhcnJheUJ1ZmZlciBwYXNzZWQgdG8gZGVjb2RlQXVkaW9EYXRhKCkgd2l0aCBhIERPTUV4Y2VwdGlvbi5cbiAgICAgKlxuICAgICAqIEJ1ZyAjNTA6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIG5vdCBhbGxvdyB0byBjcmVhdGUgQXVkaW9Ob2RlcyBvbiBhIGNsb3NlZCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQnVnICM1NzogRWRnZSB1cCB0byB2ZXJzaW9uIHYxOCBkaWQgbm90IHRocm93IGFuIGVycm9yIHdoZW4gYXNzaWduaW5nIHRoZSB0eXBlIG9mIGFuIE9zY2lsbGF0b3JOb2RlIHRvICdjdXN0b20nLlxuICAgICAqXG4gICAgICogQnVnICM2MzogRWRnZSB1cCB0byB2ZXJzaW9uIHYxOCBkaWQgbm90IGV4cG9zZSB0aGUgbWVkaWFFbGVtZW50IHByb3BlcnR5IG9mIGEgTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlLlxuICAgICAqXG4gICAgICogQnVnICM2NDogRWRnZSB1cCB0byB2ZXJzaW9uIHYxOCBkaWQgbm90IHN1cHBvcnQgdGhlIE1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUuXG4gICAgICpcbiAgICAgKiBCdWcgIzcxOiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3QgYWxsb3cgdG8gc2V0IHRoZSBidWZmZXIgb2YgYW4gQXVkaW9CdWZmZXJTb3VyY2VOb2RlIHRvIG51bGwuXG4gICAgICpcbiAgICAgKiBCdWcgIzkzOiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBzZXQgdGhlIHNhbXBsZVJhdGUgb2YgYW4gQXVkaW9Db250ZXh0IHRvIHplcm8gd2hlbiBpdCB3YXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogQnVnICMxMDE6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggcmVmdXNlZCB0byBleGVjdXRlIGRlY29kZUF1ZGlvRGF0YSgpIG9uIGEgY2xvc2VkIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBCdWcgIzEwNjogRWRnZSB1cCB0byB2ZXJzaW9uIHYxOCBkaWQgbm90IGV4cG9zZSB0aGUgbWF4VmFsdWUgYW5kIG1pblZhbHVlIHByb3BlcnRpZXMgb2YgdGhlIHBhbiBBdWRpb1BhcmFtIG9mIGEgU3RlcmVvUGFubmVyTm9kZS5cbiAgICAgKlxuICAgICAqIEJ1ZyAjMTEwOiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3QgZXhwb3NlIHRoZSBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgcHJvcGVydGllcyBvZiB0aGUgYXR0YWNrLCBrbmVlLCByYXRpbywgcmVsZWFzZSBhbmQgdGhyZXNob2xkIEF1ZGlvUGFyYW1zIG9mIGEgRHluYW1pY3NDb21wcmVzc29yTm9kZS5cbiAgICAgKlxuICAgICAqIEJ1ZyAjMTIzOiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3Qgc3VwcG9ydCBIUlRGIGFzIHRoZSBwYW5uaW5nTW9kZWwgZm9yIGEgUGFubmVyTm9kZS5cbiAgICAgKlxuICAgICAqIEJ1ZyAjMTQ1OiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCB0aHJvdyBhbiBJbmRleFNpemVFcnJvciB3aGVuIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQgd2FzIGNyZWF0ZWQgd2l0aCBhIHNhbXBsZVJhdGUgb2YgemVyby5cbiAgICAgKlxuICAgICAqIEJ1ZyAjMTYxOiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3QgZXhwb3NlIHRoZSBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgcHJvcGVydGllcyBvZiB0aGUgZGVsYXlUaW1lIEF1ZGlvUGFyYW0gb2YgYSBEZWxheU5vZGUuXG4gICAgICovXG4gICAgdmFyIHRlc3REb21FeGNlcHRpb25Db25zdHJ1Y3RvclN1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0RG9tRXhjZXB0aW9uQ29uc3RydWN0b3JTdXBwb3J0KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IERPTUV4Y2VwdGlvbigpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBTYWZhcmkgYXQgdmVyc2lvbiAxMSBkaWQgbm90IHN1cHBvcnQgdHJhbnNmZXJhYmxlcy5cbiAgICB2YXIgdGVzdFRyYW5zZmVyYWJsZXNTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdFRyYW5zZmVyYWJsZXNTdXBwb3J0KCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdmFyIF9NZXNzYWdlQ2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLFxuICAgICAgICAgIHBvcnQxID0gX01lc3NhZ2VDaGFubmVsLnBvcnQxLFxuICAgICAgICAgIHBvcnQyID0gX01lc3NhZ2VDaGFubmVsLnBvcnQyO1xuICAgICAgICBwb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBkYXRhID0gX3JlZi5kYXRhO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEgIT09IG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBwb3J0Mi5wb3N0TWVzc2FnZShhcnJheUJ1ZmZlciwgW2FycmF5QnVmZmVyXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZE9mZnNldENsYW1waW5nID0gZnVuY3Rpb24gd3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmcobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHZhciBidWZmZXIgPSBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyO1xuICAgICAgICAgIC8vIEJ1ZyAjMTU0OiBTYWZhcmkgZG9lcyBub3QgY2xhbXAgdGhlIG9mZnNldCBpZiBpdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gdGhlIGR1cmF0aW9uIG9mIHRoZSBidWZmZXIuXG4gICAgICAgICAgdmFyIGNsYW1wZWRPZmZzZXQgPSBidWZmZXIgPT09IG51bGwgPyBvZmZzZXQgOiBNYXRoLm1pbihidWZmZXIuZHVyYXRpb24sIG9mZnNldCk7XG4gICAgICAgICAgLy8gQnVnICMxNTU6IFNhZmFyaSBkb2VzIG5vdCBoYW5kbGUgdGhlIG9mZnNldCBjb3JyZWN0bHkgaWYgaXQgd291bGQgY2F1c2UgdGhlIGJ1ZmZlciB0byBiZSBub3QgYmUgcGxheWVkIGF0IGFsbC5cbiAgICAgICAgICBpZiAoYnVmZmVyICE9PSBudWxsICYmIGNsYW1wZWRPZmZzZXQgPiBidWZmZXIuZHVyYXRpb24gLSAwLjUgLyBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuY29udGV4dC5zYW1wbGVSYXRlKSB7XG4gICAgICAgICAgICBzdGFydC5jYWxsKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgd2hlbiwgMCwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LmNhbGwobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCB3aGVuLCBjbGFtcGVkT2Zmc2V0LCBkdXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfShuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQpO1xuICAgIH07XG5cbiAgICB2YXIgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzID0gZnVuY3Rpb24gd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzKG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZSwgbmF0aXZlQ29udGV4dCkge1xuICAgICAgdmFyIG5hdGl2ZUdhaW5Ob2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuY29ubmVjdChuYXRpdmVHYWluTm9kZSk7XG4gICAgICB2YXIgZGlzY29ubmVjdEdhaW5Ob2RlID0gZnVuY3Rpb24gKGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBAdG9kbyBUeXBlU2NyaXB0IGNhbm5vdCBpbmZlciB0aGUgb3ZlcmxvYWRlZCBzaWduYXR1cmUgd2l0aCAxIGFyZ3VtZW50IHlldC5cbiAgICAgICAgICBkaXNjb25uZWN0LmNhbGwobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLCBuYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZGlzY29ubmVjdEdhaW5Ob2RlKTtcbiAgICAgICAgfTtcbiAgICAgIH0obmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLmRpc2Nvbm5lY3QpO1xuICAgICAgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZGlzY29ubmVjdEdhaW5Ob2RlKTtcbiAgICAgIGludGVyY2VwdENvbm5lY3Rpb25zKG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZSwgbmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLnN0b3AgPSBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICB2YXIgaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgaWYgKGlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcC5jYWxsKG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZSwgd2hlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgICAgIG5hdGl2ZUdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgd2hlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AuY2FsbChuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUsIHdoZW4pO1xuICAgICAgICAgICAgaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZS5zdG9wKTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gd3JhcEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBkZXNjcmlwdG9yLFxuICAgICAgICAgIHRhcmdldDogZGVzY3JpcHRvclxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXIuY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlID0gY3JlYXRlQWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUoaW5zZXJ0RWxlbWVudEluU2V0KTtcbiAgICB2YXIgYWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlID0gY3JlYXRlQWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKGluc2VydEVsZW1lbnRJblNldCk7XG4gICAgdmFyIGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlID0gY3JlYXRlRGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUocGlja0VsZW1lbnRGcm9tU2V0KTtcbiAgICB2YXIgYXVkaW9Ob2RlVGFpbFRpbWVTdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIGdldEF1ZGlvTm9kZVRhaWxUaW1lID0gY3JlYXRlR2V0QXVkaW9Ob2RlVGFpbFRpbWUoYXVkaW9Ob2RlVGFpbFRpbWVTdG9yZSk7XG4gICAgdmFyIGNhY2hlVGVzdFJlc3VsdCA9IGNyZWF0ZUNhY2hlVGVzdFJlc3VsdChuZXcgTWFwKCksIG5ldyBXZWFrTWFwKCkpO1xuICAgIHZhciB3aW5kb3ckMSA9IGNyZWF0ZVdpbmRvdygpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVBbmFseXNlck5vZGUgPSBjcmVhdGVOYXRpdmVBbmFseXNlck5vZGVGYWN0b3J5KGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW5kZXhTaXplRXJyb3IpO1xuICAgIHZhciBnZXRBdWRpb05vZGVSZW5kZXJlciA9IGNyZWF0ZUdldEF1ZGlvTm9kZVJlbmRlcmVyKGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKTtcbiAgICB2YXIgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUgPSBjcmVhdGVSZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0QXVkaW9Ob2RlUmVuZGVyZXIsIGlzUGFydE9mQUN5Y2xlKTtcbiAgICB2YXIgY3JlYXRlQW5hbHlzZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVBbmFseXNlck5vZGVSZW5kZXJlckZhY3RvcnkoY3JlYXRlTmF0aXZlQW5hbHlzZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgZ2V0TmF0aXZlQ29udGV4dCA9IGNyZWF0ZUdldE5hdGl2ZUNvbnRleHQoQ09OVEVYVF9TVE9SRSk7XG4gICAgdmFyIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcih3aW5kb3ckMSk7XG4gICAgdmFyIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGNyZWF0ZUlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIHZhciBhdWRpb1BhcmFtQXVkaW9Ob2RlU3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBldmVudFRhcmdldENvbnN0cnVjdG9yID0gY3JlYXRlRXZlbnRUYXJnZXRDb25zdHJ1Y3Rvcih3cmFwRXZlbnRMaXN0ZW5lcik7XG4gICAgdmFyIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gY3JlYXRlTmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3Iod2luZG93JDEpO1xuICAgIHZhciBpc05hdGl2ZUF1ZGlvQ29udGV4dCA9IGNyZWF0ZUlzTmF0aXZlQXVkaW9Db250ZXh0KG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICB2YXIgaXNOYXRpdmVBdWRpb05vZGUgPSBjcmVhdGVJc05hdGl2ZUF1ZGlvTm9kZSh3aW5kb3ckMSk7XG4gICAgdmFyIGlzTmF0aXZlQXVkaW9QYXJhbSA9IGNyZWF0ZUlzTmF0aXZlQXVkaW9QYXJhbSh3aW5kb3ckMSk7XG4gICAgdmFyIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3Rvcih3aW5kb3ckMSk7XG4gICAgdmFyIGF1ZGlvTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlQXVkaW9Ob2RlQ29uc3RydWN0b3IoY3JlYXRlQWRkQXVkaW9Ob2RlQ29ubmVjdGlvbnMoQVVESU9fTk9ERV9DT05ORUNUSU9OU19TVE9SRSksIGNyZWF0ZUFkZENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShhZGRBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZSwgYWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlLCBjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUsIGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlLCBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZSwgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMsIGdldEF1ZGlvTm9kZVRhaWxUaW1lLCBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIGluc2VydEVsZW1lbnRJblNldCwgaXNBY3RpdmVBdWRpb05vZGUsIGlzUGFydE9mQUN5Y2xlLCBpc1Bhc3NpdmVBdWRpb05vZGUpLCBjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZUluY3JlbWVudEN5Y2xlQ291bnRlckZhY3RvcnkoQ1lDTEVfQ09VTlRFUlMsIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlLCBnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBnZXROYXRpdmVBdWRpb1BhcmFtLCBpc0FjdGl2ZUF1ZGlvTm9kZSksIGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBjcmVhdGVEZWNyZW1lbnRDeWNsZUNvdW50ZXIoY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlLCBDWUNMRV9DT1VOVEVSUywgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgZ2V0TmF0aXZlQXVkaW9QYXJhbSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNBY3RpdmVBdWRpb05vZGUsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCksIGNyZWF0ZURldGVjdEN5Y2xlcyhhdWRpb1BhcmFtQXVkaW9Ob2RlU3RvcmUsIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXRWYWx1ZUZvcktleSksIGV2ZW50VGFyZ2V0Q29uc3RydWN0b3IsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlQXVkaW9Db250ZXh0LCBpc05hdGl2ZUF1ZGlvTm9kZSwgaXNOYXRpdmVBdWRpb1BhcmFtLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3Rvcik7XG4gICAgdmFyIGFuYWx5c2VyTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlQW5hbHlzZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUFuYWx5c2VyTm9kZVJlbmRlcmVyLCBjcmVhdGVJbmRleFNpemVFcnJvciwgY3JlYXRlTmF0aXZlQW5hbHlzZXJOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBhdWRpb0J1ZmZlclN0b3JlID0gbmV3IFdlYWtTZXQoKTtcbiAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3RvciA9IGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3Iod2luZG93JDEpO1xuICAgIHZhciBjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcgPSBjcmVhdGVDb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcobmV3IFVpbnQzMkFycmF5KDEpKTtcbiAgICB2YXIgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzID0gY3JlYXRlV3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzKGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZywgY3JlYXRlSW5kZXhTaXplRXJyb3IpO1xuICAgIHZhciB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcyA9IGNyZWF0ZVdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzKGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyk7XG4gICAgdmFyIGF1ZGlvQnVmZmVyQ29uc3RydWN0b3IgPSBjcmVhdGVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yKGF1ZGlvQnVmZmVyU3RvcmUsIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIG5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgY3JlYXRlVGVzdEF1ZGlvQnVmZmVyQ29uc3RydWN0b3JTdXBwb3J0KG5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IpLCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMsIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzKTtcbiAgICB2YXIgYWRkU2lsZW50Q29ubmVjdGlvbiA9IGNyZWF0ZUFkZFNpbGVudENvbm5lY3Rpb24oY3JlYXRlTmF0aXZlR2Fpbk5vZGUpO1xuICAgIHZhciByZW5kZXJJbnB1dHNPZkF1ZGlvUGFyYW0gPSBjcmVhdGVSZW5kZXJJbnB1dHNPZkF1ZGlvUGFyYW0oZ2V0QXVkaW9Ob2RlUmVuZGVyZXIsIGdldEF1ZGlvUGFyYW1Db25uZWN0aW9ucywgaXNQYXJ0T2ZBQ3ljbGUpO1xuICAgIHZhciBjb25uZWN0QXVkaW9QYXJhbSA9IGNyZWF0ZUNvbm5lY3RBdWRpb1BhcmFtKHJlbmRlcklucHV0c09mQXVkaW9QYXJhbSk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZUZhY3RvcnkoYWRkU2lsZW50Q29ubmVjdGlvbiwgY2FjaGVUZXN0UmVzdWx0LCB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmdTdXBwb3J0LCB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RvcE1ldGhvZE51bGxpZmllZEJ1ZmZlclN1cHBvcnQsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxsc1N1cHBvcnQsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgd3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmcsIGNyZWF0ZVdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyKG92ZXJ3cml0ZUFjY2Vzc29ycyksIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxscyk7XG4gICAgdmFyIHJlbmRlckF1dG9tYXRpb24gPSBjcmVhdGVSZW5kZXJBdXRvbWF0aW9uKGNyZWF0ZUdldEF1ZGlvUGFyYW1SZW5kZXJlcihnZXRBdWRpb1BhcmFtQ29ubmVjdGlvbnMpLCByZW5kZXJJbnB1dHNPZkF1ZGlvUGFyYW0pO1xuICAgIHZhciBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlciA9IGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgY3JlYXRlQXVkaW9QYXJhbSA9IGNyZWF0ZUF1ZGlvUGFyYW1GYWN0b3J5KGNyZWF0ZUFkZEF1ZGlvUGFyYW1Db25uZWN0aW9ucyhBVURJT19QQVJBTV9DT05ORUNUSU9OU19TVE9SRSksIGF1ZGlvUGFyYW1BdWRpb05vZGVTdG9yZSwgQVVESU9fUEFSQU1fU1RPUkUsIGNyZWF0ZUF1ZGlvUGFyYW1SZW5kZXJlciwgYXV0b21hdGlvbkV2ZW50cy5jcmVhdGVDYW5jZWxBbmRIb2xkQXV0b21hdGlvbkV2ZW50LCBhdXRvbWF0aW9uRXZlbnRzLmNyZWF0ZUNhbmNlbFNjaGVkdWxlZFZhbHVlc0F1dG9tYXRpb25FdmVudCwgYXV0b21hdGlvbkV2ZW50cy5jcmVhdGVFeHBvbmVudGlhbFJhbXBUb1ZhbHVlQXV0b21hdGlvbkV2ZW50LCBhdXRvbWF0aW9uRXZlbnRzLmNyZWF0ZUxpbmVhclJhbXBUb1ZhbHVlQXV0b21hdGlvbkV2ZW50LCBhdXRvbWF0aW9uRXZlbnRzLmNyZWF0ZVNldFRhcmdldEF1dG9tYXRpb25FdmVudCwgYXV0b21hdGlvbkV2ZW50cy5jcmVhdGVTZXRWYWx1ZUF1dG9tYXRpb25FdmVudCwgYXV0b21hdGlvbkV2ZW50cy5jcmVhdGVTZXRWYWx1ZUN1cnZlQXV0b21hdGlvbkV2ZW50LCBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgX3NldFZhbHVlQXRUaW1lVW50aWxQb3NzaWJsZSk7XG4gICAgdmFyIGF1ZGlvQnVmZmVyU291cmNlTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHdyYXBFdmVudExpc3RlbmVyKTtcbiAgICB2YXIgYXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvRGVzdGluYXRpb25Ob2RlUmVuZGVyZXIsIGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBvdmVyd3JpdGVBY2Nlc3NvcnMpLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgY3JlYXRlQmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyID0gY3JlYXRlQmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSk7XG4gICAgdmFyIHNldEF1ZGlvTm9kZVRhaWxUaW1lID0gY3JlYXRlU2V0QXVkaW9Ob2RlVGFpbFRpbWUoYXVkaW9Ob2RlVGFpbFRpbWVTdG9yZSk7XG4gICAgdmFyIGJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZUJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlQmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyLCBjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IsIGNyZWF0ZU5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpO1xuICAgIHZhciBtb25pdG9yQ29ubmVjdGlvbnMgPSBjcmVhdGVNb25pdG9yQ29ubmVjdGlvbnMoaW5zZXJ0RWxlbWVudEluU2V0LCBpc05hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgdmFyIHdyYXBDaGFubmVsTWVyZ2VyTm9kZSA9IGNyZWF0ZVdyYXBDaGFubmVsTWVyZ2VyTm9kZShjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgbW9uaXRvckNvbm5lY3Rpb25zKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZUZhY3RvcnkobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHdyYXBDaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgdmFyIGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVDaGFubmVsTWVyZ2VyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSk7XG4gICAgdmFyIGNoYW5uZWxNZXJnZXJOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVDaGFubmVsTWVyZ2VyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVDaGFubmVsTWVyZ2VyTm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgY3JlYXRlQ2hhbm5lbFNwbGl0dGVyTm9kZVJlbmRlcmVyID0gY3JlYXRlQ2hhbm5lbFNwbGl0dGVyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgY2hhbm5lbFNwbGl0dGVyTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlQ2hhbm5lbFNwbGl0dGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2FuaXRpemVDaGFubmVsU3BsaXR0ZXJPcHRpb25zKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFrZXIgPSBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlckZhY3RvcnkoYWRkU2lsZW50Q29ubmVjdGlvbiwgY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgbW9uaXRvckNvbm5lY3Rpb25zKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFjdG9yeShhZGRTaWxlbnRDb25uZWN0aW9uLCBjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUZha2VyLCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQpO1xuICAgIHZhciBjcmVhdGVDb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlciA9IGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgY29uc3RhbnRTb3VyY2VOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVDb25zdGFudFNvdXJjZU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB3cmFwRXZlbnRMaXN0ZW5lcik7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUNvbnZvbHZlck5vZGUgPSBjcmVhdGVOYXRpdmVDb252b2x2ZXJOb2RlRmFjdG9yeShjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgb3ZlcndyaXRlQWNjZXNzb3JzKTtcbiAgICB2YXIgY3JlYXRlQ29udm9sdmVyTm9kZVJlbmRlcmVyID0gY3JlYXRlQ29udm9sdmVyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVDb252b2x2ZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgY29udm9sdmVyTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlQ29udm9sdmVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVDb252b2x2ZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUNvbnZvbHZlck5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpO1xuICAgIHZhciBjcmVhdGVEZWxheU5vZGVSZW5kZXJlciA9IGNyZWF0ZURlbGF5Tm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlRGVsYXlOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgZGVsYXlOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVEZWxheU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlRGVsYXlOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZURlbGF5Tm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSBjcmVhdGVOYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlRmFjdG9yeShjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcik7XG4gICAgdmFyIGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVSZW5kZXJlciA9IGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBkeW5hbWljc0NvbXByZXNzb3JOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpO1xuICAgIHZhciBjcmVhdGVHYWluTm9kZVJlbmRlcmVyID0gY3JlYXRlR2Fpbk5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgZ2Fpbk5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZUdhaW5Ob2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZUdhaW5Ob2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlRmFrZXIgPSBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlRmFrZXJGYWN0b3J5KGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKTtcbiAgICB2YXIgcmVuZGVyTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGNyZWF0ZVJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQoY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZSwgY3JlYXRlVGVzdE9mZmxpbmVBdWRpb0NvbnRleHRDdXJyZW50VGltZVN1cHBvcnQoY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcikpO1xuICAgIHZhciBjcmVhdGVJSVJGaWx0ZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVJSVJGaWx0ZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlLCByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWtlcik7XG4gICAgdmFyIGlJUkZpbHRlck5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZUlJUkZpbHRlck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZSwgY3JlYXRlSUlSRmlsdGVyTm9kZVJlbmRlcmVyLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHNldEF1ZGlvTm9kZVRhaWxUaW1lKTtcbiAgICB2YXIgY3JlYXRlQXVkaW9MaXN0ZW5lciA9IGNyZWF0ZUF1ZGlvTGlzdGVuZXJGYWN0b3J5KGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBnZXRGaXJzdFNhbXBsZSwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBvdmVyd3JpdGVBY2Nlc3NvcnMpO1xuICAgIHZhciB1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZVN0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgbWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGNyZWF0ZU1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoYXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9MaXN0ZW5lciwgZXZlbnRUYXJnZXRDb25zdHJ1Y3RvciwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZVN0b3JlLCB3cmFwRXZlbnRMaXN0ZW5lcik7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZU9zY2lsbGF0b3JOb2RlID0gY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGVGYWN0b3J5KGFkZFNpbGVudENvbm5lY3Rpb24sIGNhY2hlVGVzdFJlc3VsdCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMpO1xuICAgIHZhciBjcmVhdGVPc2NpbGxhdG9yTm9kZVJlbmRlcmVyID0gY3JlYXRlT3NjaWxsYXRvck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgb3NjaWxsYXRvck5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZU9zY2lsbGF0b3JOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBjcmVhdGVPc2NpbGxhdG9yTm9kZVJlbmRlcmVyLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHdyYXBFdmVudExpc3RlbmVyKTtcbiAgICB2YXIgY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlRmFjdG9yeShjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGVGYWtlckZhY3RvcnkoY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGlzRENDdXJ2ZSwgbW9uaXRvckNvbm5lY3Rpb25zKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUgPSBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZhY3RvcnkoY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGVGYWtlciwgaXNEQ0N1cnZlLCBtb25pdG9yQ29ubmVjdGlvbnMsIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBvdmVyd3JpdGVBY2Nlc3NvcnMpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFrZXIgPSBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFrZXJGYWN0b3J5KGNvbm5lY3ROYXRpdmVBdWRpb05vZGVUb05hdGl2ZUF1ZGlvTm9kZSwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZSwgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZSwgZ2V0Rmlyc3RTYW1wbGUsIG1vbml0b3JDb25uZWN0aW9ucyk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFjdG9yeShjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFrZXIpO1xuICAgIHZhciBjcmVhdGVQYW5uZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVQYW5uZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTmF0aXZlUGFubmVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlLCByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgcGFubmVyTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlUGFubmVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlLCBjcmVhdGVQYW5uZXJOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVQZXJpb2RpY1dhdmUgPSBjcmVhdGVOYXRpdmVQZXJpb2RpY1dhdmVGYWN0b3J5KGNyZWF0ZUluZGV4U2l6ZUVycm9yKTtcbiAgICB2YXIgcGVyaW9kaWNXYXZlQ29uc3RydWN0b3IgPSBjcmVhdGVQZXJpb2RpY1dhdmVDb25zdHJ1Y3RvcihjcmVhdGVOYXRpdmVQZXJpb2RpY1dhdmUsIGdldE5hdGl2ZUNvbnRleHQsIG5ldyBXZWFrU2V0KCksIHNhbml0aXplUGVyaW9kaWNXYXZlT3B0aW9ucyk7XG4gICAgdmFyIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVGYWtlckZhY3RvcnkgPSBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFrZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBtb25pdG9yQ29ubmVjdGlvbnMpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlID0gY3JlYXRlTmF0aXZlU3RlcmVvUGFubmVyTm9kZUZhY3RvcnkobmF0aXZlU3RlcmVvUGFubmVyTm9kZUZha2VyRmFjdG9yeSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IpO1xuICAgIHZhciBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgc3RlcmVvUGFubmVyTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlU3RlcmVvUGFubmVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlLCBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIGNyZWF0ZVdhdmVTaGFwZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVXYXZlU2hhcGVyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSk7XG4gICAgdmFyIHdhdmVTaGFwZXJOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVXYXZlU2hhcGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUsIGNyZWF0ZVdhdmVTaGFwZXJOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpO1xuICAgIHZhciBpc1NlY3VyZUNvbnRleHQgPSBjcmVhdGVJc1NlY3VyZUNvbnRleHQod2luZG93JDEpO1xuICAgIHZhciBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZSA9IGNyZWF0ZUV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lKHdpbmRvdyQxKTtcbiAgICB2YXIgYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dFN0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgZ2V0T3JDcmVhdGVCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlR2V0T3JDcmVhdGVCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0KGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHRTdG9yZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICAvLyBUaGUgYWRkQXVkaW9Xb3JrbGV0TW9kdWxlKCkgZnVuY3Rpb24gaXMgb25seSBhdmFpbGFibGUgaW4gYSBTZWN1cmVDb250ZXh0LlxuICAgIHZhciBhZGRBdWRpb1dvcmtsZXRNb2R1bGUgPSBpc1NlY3VyZUNvbnRleHQgPyBjcmVhdGVBZGRBdWRpb1dvcmtsZXRNb2R1bGUoY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgY3JlYXRlRXZhbHVhdGVTb3VyY2Uod2luZG93JDEpLCBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZSwgY3JlYXRlRmV0Y2hTb3VyY2UoY3JlYXRlQWJvcnRFcnJvciksIGdldE5hdGl2ZUNvbnRleHQsIGdldE9yQ3JlYXRlQmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5ldyBXZWFrTWFwKCksIG5ldyBXZWFrTWFwKCksIGNyZWF0ZVRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JQb3N0TWVzc2FnZVN1cHBvcnQobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLFxuICAgIC8vIEB0b2RvIHdpbmRvdyBpcyBndWFyYW50ZWVkIHRvIGJlIGRlZmluZWQgYmVjYXVzZSBpc1NlY3VyZUNvbnRleHQgY2hlY2tzIHRoYXQgYXMgd2VsbC5cbiAgICB3aW5kb3ckMSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGlzTmF0aXZlQ29udGV4dCA9IGNyZWF0ZUlzTmF0aXZlQ29udGV4dChpc05hdGl2ZUF1ZGlvQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgZGVjb2RlQXVkaW9EYXRhID0gY3JlYXRlRGVjb2RlQXVkaW9EYXRhKGF1ZGlvQnVmZmVyU3RvcmUsIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlRGF0YUNsb25lRXJyb3IsIGNyZWF0ZUVuY29kaW5nRXJyb3IsIG5ldyBXZWFrU2V0KCksIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlQ29udGV4dCwgdGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0LCB0ZXN0UHJvbWlzZVN1cHBvcnQsIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kcywgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMpO1xuICAgIHZhciBiYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBjcmVhdGVCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoYWRkQXVkaW9Xb3JrbGV0TW9kdWxlLCBhbmFseXNlck5vZGVDb25zdHJ1Y3RvciwgYXVkaW9CdWZmZXJDb25zdHJ1Y3RvciwgYXVkaW9CdWZmZXJTb3VyY2VOb2RlQ29uc3RydWN0b3IsIGJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3RvciwgY2hhbm5lbE1lcmdlck5vZGVDb25zdHJ1Y3RvciwgY2hhbm5lbFNwbGl0dGVyTm9kZUNvbnN0cnVjdG9yLCBjb25zdGFudFNvdXJjZU5vZGVDb25zdHJ1Y3RvciwgY29udm9sdmVyTm9kZUNvbnN0cnVjdG9yLCBkZWNvZGVBdWRpb0RhdGEsIGRlbGF5Tm9kZUNvbnN0cnVjdG9yLCBkeW5hbWljc0NvbXByZXNzb3JOb2RlQ29uc3RydWN0b3IsIGdhaW5Ob2RlQ29uc3RydWN0b3IsIGlJUkZpbHRlck5vZGVDb25zdHJ1Y3RvciwgbWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvciwgb3NjaWxsYXRvck5vZGVDb25zdHJ1Y3RvciwgcGFubmVyTm9kZUNvbnN0cnVjdG9yLCBwZXJpb2RpY1dhdmVDb25zdHJ1Y3Rvciwgc3RlcmVvUGFubmVyTm9kZUNvbnN0cnVjdG9yLCB3YXZlU2hhcGVyTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB2YXIgbWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlTmF0aXZlTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBtZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IgPSBjcmVhdGVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVGYWN0b3J5KGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBtZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGUsIGdldE5hdGl2ZUNvbnRleHQpO1xuICAgIHZhciBhdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGNyZWF0ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKGJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBjcmVhdGVVbmtub3duRXJyb3IsIG1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yLCBtZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IsIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IsIG1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciwgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIHZhciBnZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMgPSBjcmVhdGVHZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXModW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVTdG9yZSk7XG4gICAgdmFyIGFkZFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlID0gY3JlYXRlQWRkVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUoZ2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzKTtcbiAgICB2YXIgY29ubmVjdE11bHRpcGxlT3V0cHV0cyA9IGNyZWF0ZUNvbm5lY3RNdWx0aXBsZU91dHB1dHMoY3JlYXRlSW5kZXhTaXplRXJyb3IpO1xuICAgIHZhciBkZWxldGVVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZSA9IGNyZWF0ZURlbGV0ZVVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlKGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2Rlcyk7XG4gICAgdmFyIGRpc2Nvbm5lY3RNdWx0aXBsZU91dHB1dHMgPSBjcmVhdGVEaXNjb25uZWN0TXVsdGlwbGVPdXRwdXRzKGNyZWF0ZUluZGV4U2l6ZUVycm9yKTtcbiAgICB2YXIgYWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0c1N0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgZ2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyA9IGNyZWF0ZUdldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMoYWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0c1N0b3JlLCBnZXRWYWx1ZUZvcktleSk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlciA9IGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlckZhY3RvcnkoY29ubmVjdE11bHRpcGxlT3V0cHV0cywgY3JlYXRlSW5kZXhTaXplRXJyb3IsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGRpc2Nvbm5lY3RNdWx0aXBsZU91dHB1dHMsIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lLCBnZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzLCBtb25pdG9yQ29ubmVjdGlvbnMpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlID0gY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZhY3RvcnkoY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlciwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBtb25pdG9yQ29ubmVjdGlvbnMpO1xuICAgIHZhciBjcmVhdGVBdWRpb1dvcmtsZXROb2RlUmVuZGVyZXIgPSBjcmVhdGVBdWRpb1dvcmtsZXROb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjb25uZWN0TXVsdGlwbGVPdXRwdXRzLCBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBkZWxldGVVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZSwgZGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cywgZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlLCByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgZ2V0QmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGNyZWF0ZUdldEJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQoYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dFN0b3JlKTtcbiAgICB2YXIgc2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyA9IGNyZWF0ZVNldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMoYWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0c1N0b3JlKTtcbiAgICAvLyBUaGUgQXVkaW9Xb3JrbGV0Tm9kZSBjb25zdHJ1Y3RvciBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhIFNlY3VyZUNvbnRleHQuXG4gICAgdmFyIGF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciA9IGlzU2VjdXJlQ29udGV4dCA/IGNyZWF0ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvcihhZGRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZSwgYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZUF1ZGlvV29ya2xldE5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMsIGdldEJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yLCBzYW5pdGl6ZUF1ZGlvV29ya2xldE5vZGVPcHRpb25zLCBzZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzLCB0ZXN0QXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnNDbG9uYWJpbGl0eSwgd3JhcEV2ZW50TGlzdGVuZXIpIDogdW5kZWZpbmVkO1xuICAgIHZhciBtaW5pbWFsQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBjcmVhdGVNaW5pbWFsQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBjcmVhdGVVbmtub3duRXJyb3IsIG1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGNyZWF0ZUNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQoY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcik7XG4gICAgdmFyIHN0YXJ0UmVuZGVyaW5nID0gY3JlYXRlU3RhcnRSZW5kZXJpbmcoYXVkaW9CdWZmZXJTdG9yZSwgY2FjaGVUZXN0UmVzdWx0LCBnZXRBdWRpb05vZGVSZW5kZXJlciwgZ2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzLCByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kc1N1cHBvcnQsIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kcywgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMpO1xuICAgIHZhciBtaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gY3JlYXRlTWluaW1hbE9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBzdGFydFJlbmRlcmluZyk7XG4gICAgdmFyIG9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGNyZWF0ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihiYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHN0YXJ0UmVuZGVyaW5nKTtcbiAgICB2YXIgaXNBbnlBdWRpb0NvbnRleHQgPSBjcmVhdGVJc0FueUF1ZGlvQ29udGV4dChDT05URVhUX1NUT1JFLCBpc05hdGl2ZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIGlzQW55QXVkaW9Ob2RlID0gY3JlYXRlSXNBbnlBdWRpb05vZGUoQVVESU9fTk9ERV9TVE9SRSwgaXNOYXRpdmVBdWRpb05vZGUpO1xuICAgIHZhciBpc0FueUF1ZGlvUGFyYW0gPSBjcmVhdGVJc0FueUF1ZGlvUGFyYW0oQVVESU9fUEFSQU1fU1RPUkUsIGlzTmF0aXZlQXVkaW9QYXJhbSk7XG4gICAgdmFyIGlzQW55T2ZmbGluZUF1ZGlvQ29udGV4dCA9IGNyZWF0ZUlzQW55T2ZmbGluZUF1ZGlvQ29udGV4dChDT05URVhUX1NUT1JFLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUlzU3VwcG9ydGVkUHJvbWlzZShjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZVRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc1N1YmFycmF5U3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0QXVkaW9Db250ZXh0Q2xvc2VNZXRob2RTdXBwb3J0KG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgY3JlYXRlVGVzdEF1ZGlvQ29udGV4dERlY29kZUF1ZGlvRGF0YU1ldGhvZFR5cGVFcnJvclN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgY3JlYXRlVGVzdEF1ZGlvQ29udGV4dE9wdGlvbnNTdXBwb3J0KG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgY3JlYXRlVGVzdEF1ZGlvTm9kZUNvbm5lY3RNZXRob2RTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciksIGNyZWF0ZVRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JOb091dHB1dHNTdXBwb3J0KG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgY3JlYXRlVGVzdENoYW5uZWxNZXJnZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0Q29uc3RhbnRTb3VyY2VOb2RlQWNjdXJhdGVTY2hlZHVsaW5nU3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0Q29udm9sdmVyTm9kZUJ1ZmZlclJlYXNzaWduYWJpbGl0eVN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgY3JlYXRlVGVzdENvbnZvbHZlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciksIHRlc3REb21FeGNlcHRpb25Db25zdHJ1Y3RvclN1cHBvcnQsIGNyZWF0ZVRlc3RJc1NlY3VyZUNvbnRleHRTdXBwb3J0KHdpbmRvdyQxKSwgY3JlYXRlVGVzdE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlTWVkaWFTdHJlYW1XaXRob3V0QXVkaW9UcmFja1N1cHBvcnQobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0U3RlcmVvUGFubmVyTm9kZURlZmF1bHRWYWx1ZVN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgdGVzdFRyYW5zZmVyYWJsZXNTdXBwb3J0KTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5BbmFseXNlck5vZGUgPSBhbmFseXNlck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkF1ZGlvQnVmZmVyID0gYXVkaW9CdWZmZXJDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGF1ZGlvQnVmZmVyU291cmNlTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuQXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0Q29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5BdWRpb1dvcmtsZXROb2RlID0gYXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuQmlxdWFkRmlsdGVyTm9kZSA9IGJpcXVhZEZpbHRlck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkNoYW5uZWxNZXJnZXJOb2RlID0gY2hhbm5lbE1lcmdlck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkNoYW5uZWxTcGxpdHRlck5vZGUgPSBjaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5Db25zdGFudFNvdXJjZU5vZGUgPSBjb25zdGFudFNvdXJjZU5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkNvbnZvbHZlck5vZGUgPSBjb252b2x2ZXJOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5EZWxheU5vZGUgPSBkZWxheU5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSBkeW5hbWljc0NvbXByZXNzb3JOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5HYWluTm9kZSA9IGdhaW5Ob2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5JSVJGaWx0ZXJOb2RlID0gaUlSRmlsdGVyTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlID0gbWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5NZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlID0gbWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgPSBtZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSA9IG1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLk1pbmltYWxBdWRpb0NvbnRleHQgPSBtaW5pbWFsQXVkaW9Db250ZXh0Q29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5NaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG1pbmltYWxPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gb2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuT3NjaWxsYXRvck5vZGUgPSBvc2NpbGxhdG9yTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuUGFubmVyTm9kZSA9IHBhbm5lck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLlBlcmlvZGljV2F2ZSA9IHBlcmlvZGljV2F2ZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuU3RlcmVvUGFubmVyTm9kZSA9IHN0ZXJlb1Bhbm5lck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLldhdmVTaGFwZXJOb2RlID0gd2F2ZVNoYXBlck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLmFkZEF1ZGlvV29ya2xldE1vZHVsZSA9IGFkZEF1ZGlvV29ya2xldE1vZHVsZTtcbiAgICBleHBvcnRzLmRlY29kZUF1ZGlvRGF0YSA9IGRlY29kZUF1ZGlvRGF0YTtcbiAgICBleHBvcnRzLmlzQW55QXVkaW9Db250ZXh0ID0gaXNBbnlBdWRpb0NvbnRleHQ7XG4gICAgZXhwb3J0cy5pc0FueUF1ZGlvTm9kZSA9IGlzQW55QXVkaW9Ob2RlO1xuICAgIGV4cG9ydHMuaXNBbnlBdWRpb1BhcmFtID0gaXNBbnlBdWRpb1BhcmFtO1xuICAgIGV4cG9ydHMuaXNBbnlPZmZsaW5lQXVkaW9Db250ZXh0ID0gaXNBbnlPZmZsaW5lQXVkaW9Db250ZXh0O1xuICAgIGV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/standardized-audio-context/build/es5/bundle.js\n");

/***/ })

};
;